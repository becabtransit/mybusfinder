
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
@import url('https://fonts.googleapis.com/css?family=League+Spartan:400,700');

body {
    font-family: 'League Spartan', sans-serif;
    margin: 0;
    padding: 0;
    color: #333;
    background-color: #f5f5f5;
    transition: background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

h1, h2, h3, h4 {
    margin: 0.5em 0;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.container {
    margin: 0 auto;
    padding: 15px;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    margin-top: 10px;
    overflow: hidden;
}

.bus-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.bus-item {
    padding: 12px 18px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                box-shadow 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    border-radius: 12px;
    margin-bottom: 12px;
    background-color: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    position: relative;
    overflow: hidden;
}

.bus-item:hover {
    transform: scale(0.98);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
}

.bus-item:active {
    transform: translateY(0) scale(0.95);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.bus-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
    transition: left 1s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
}

.bus-item:hover::before {
    left: 120%;
}

.bus-item div {
    display: flex;
    align-items: center;
    margin: 5px 0;
    position: relative;
    z-index: 2;
}

.line-number {
    font-size: 1.3em;
    font-weight: bold;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.line-details {
    display: flex;
    align-items: center;
}

.bus-item:hover .color-box {
    transform: scale(1.2) rotate(45deg);
}

.initial-fade-in {
    animation: fadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
}

.hidden {
    display: none !important;
}

.controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding: 0 10px;
}

.btn {
    padding: 10px 18px;
    background-color: #363636;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    font-weight: bold;
    box-shadow: 0 3px 10px rgba(0, 123, 255, 0.2);
}

.btn:hover {
    background-color: #363636;
    transform: scale(0.98);
    box-shadow: 0 6px 15px rgba(0, 123, 255, 0.3);
}

.btn:active {
    transform: scale(0.95);
}

.btn-back {
    display: flex;
    align-items: center;
    gap: 8px;
}

.btn-back svg {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.btn-back:hover svg {
    transform: translateX(-5px);
}

select {
    padding: 10px 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-family: inherit;
    background-color: #f9f9f9;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    font-size: 0.95em;
}

select:hover {
    border-color: #363636;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

select:focus {
    outline: none;
    border-color: #363636;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

#loading-indicator {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 120px;
    flex-direction: column;
}


@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#error-message {
    text-align: center;
    color: #dc3545;
    padding: 20px;
    background-color: #f8d7da;
    border-radius: 10px;
    animation: shakeError 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    margin: 20px 0;
    box-shadow: 0 3px 10px rgba(220, 53, 69, 0.1);
}

@keyframes shakeError {
    0%, 100% { transform: translateX(0); }
    20%, 60% { transform: translateX(-8px); }
    40%, 80% { transform: translateX(8px); }
}

.page-transition {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                opacity 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                scale 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                filter 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    opacity: 0;
    filter: blur(10px);
    transform: translateY(50px);
}

.page-transition.slide-in {
    opacity: 1;
    filter: blur(0);
    transform: translateY(0);
}




.schedule-row {
    display: flex;
    padding: 12px 10px;
    border-bottom: 1px solid #eee;
    transition: background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.schedule-row:hover {
    background-color: #f5f9ff;
}

.schedule-row span {
    font-weight: bold;
    width: 60px;
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.schedule-row:hover span {
    transform: scale(1.1);
    color: #363636;
}

.schedule-row span1 {
    flex: 1;
}

#schedule-container {
    overflow-y: auto;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 10px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.05);
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

#schedule-container:hover {
    background-color: #f0f7ff;
}

.textpop {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    padding: 5px 10px;
}

.textpop:hover {
    transform: translateX(5px);
}

.textpop h1 {
    font-size: 1.6em;
    color: #363636;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.textpop:hover h1 {
    color: #363636;
}

.textpop h4 {
    font-size: 1em;
    color: #666;
    font-weight: normal;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.textpop:hover h4 {
    color: #333;
}

.view {
    display: none;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.view.active {
    display: block;
    animation: fadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.destination-item, .stop-item {
    padding: 18px;
    margin: 12px 0;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    position: relative;
    overflow: hidden;
}

.destination-item::before, .stop-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
    transition: left 1s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
}

.destination-item:hover::before, .stop-item:hover::before {
    left: 120%;
}

.destination-item:hover, .stop-item:hover {
    transform: scale(0.98);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
}

.destination-item:active, .stop-item:active {
    transform: translateY(0) scale(0.95);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.date-input {
    padding: 10px 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-family: inherit;
    background-color: #f9f9f9;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    font-size: 0.95em;
    margin-bottom: 15px;
}

.date-input:hover {
    border-color: #363636;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.date-input:focus {
    outline: none;
    border-color: #363636;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

.date-header {
    padding: 10px 0;
    border-bottom: 2px solid #eee;
    margin-bottom: 15px;
    text-align: center;
    color: #363636;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

    </style>
</head>
<body>
    <div class="container">
        <div id="loading-view" class="view active">
            <div id="loading-indicator">
                <p style="margin-top: 15px; color: #666;">Chargement en cours..</p>
            </div>
        </div>
        
        <div id="error-view" class="view">
            <div id="error-message">
                Erreur lors du chargement des donn√©es. Veuillez r√©essayer.
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="loadData()">R√©essayer</button>
            </div>
        </div>
        
        <div id="lines-view" class="view page-transition">
            <h2>S√©lectionnez une ligne</h2>
            <div id="lines-container" class="bus-list"></div>
        </div>
        
        <div id="destinations-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="showLines()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4>S√©lectionnez une destination</h4>
                <h1 id="route-title"></h1>
            </div>
            <div id="destinations-container"></div>
        </div>
        
        <div id="stops-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="goBack()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4>S√©lectionnez un arr√™t</h4>
                <h1 id="destination-title"></h1>
            </div>
            <div id="stops-container"></div>
        </div>
        
        <div id="schedule-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="goBack()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4 id="route-info"></h4>
                <h1 id="stop-title"></h1>
            </div>
            <div>
                <div>
                    <input type="date" id="date-select" class="date-input">
                </div>
            </div>
            <div id="schedule-container"></div>
        </div>
    </div>
    
    <script>
        let routes = {};
        let trips = {};
        let stopTimes = {};
        let stops = {};
        let calendar = {};
        let calendarDates = {};

        
        let navigationHistory = [];
        let currentRouteId = null;
        let currentStopId = null;
        let currentDestinationId = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            loadData();
        });
        
        function loadData() {
            showView('loading-view');
            

                loadGtfsData().then(() => {
                    showLines();
                }).catch(error => {
                    console.error('Erreur lors du chargement des donn√©es:', error);
                    showView('error-view');
                });
        }

async function extractGTFSFiles() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`√âchec du t√©l√©chargement: ${response.status} ${response.statusText}`);
        }
        
        const zipData = await response.arrayBuffer();
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        
        const filePromises = [];
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                    console.log(`Fichier extrait: ${relativePath}`);
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        console.log("Fichiers extraits:", Object.keys(extractedFiles));
        
        return extractedFiles;
    } catch (error) {
        console.error('Erreur lors de l\'extraction des fichiers GTFS:', error);
        throw error;
    }
}


async function loadGtfsData() {
    try {
        const extractedFiles = await extractGTFSFiles();
        
        routes = {};
        trips = {};
        stopTimes = {};
        stops = {};
        calendar = {};
        calendarDates = {};
        shapes = {};
        frequencies = {};
        transfers = {};
        pathways = {};
        levels = {};
        fareAttributes = {};
        fareRules = {};
        attributions = {};
        translations = {};
        
        console.log('Chargement des donn√©es GTFS en cours...');
        
        // Chargement des fichiers obligatoires du GTFS
        const requiredFiles = [
            loadRoutes(extractedFiles['routes.txt']),
            loadTrips(extractedFiles['trips.txt']),
            loadStopTimes(extractedFiles['stop_times.txt']),
            loadStops(extractedFiles['stops.txt']),
            loadCalendar(extractedFiles['calendar.txt'])
        ];
        
        await Promise.all(requiredFiles);
        
        // Chargement des fichiers optionnels du GTFS
        const optionalFiles = [
            loadCalendarDates(extractedFiles['calendar_dates.txt']),
            loadShapes(extractedFiles['shapes.txt']),
            loadFrequencies(extractedFiles['frequencies.txt']),
            loadTransfers(extractedFiles['transfers.txt']),
            loadPathways(extractedFiles['pathways.txt']),
            loadLevels(extractedFiles['levels.txt']),
            loadFareAttributes(extractedFiles['fare_attributes.txt']),
            loadFareRules(extractedFiles['fare_rules.txt']),
            loadAttributions(extractedFiles['attributions.txt']),
            loadTranslations(extractedFiles['translations.txt'])
        ];
        
        await Promise.all(optionalFiles);
        
        // Charger les m√©tadonn√©es du flux
        const feedData = await loadFeedInfo(extractedFiles['feed_info.txt']);
        
        // Pr√©traiter les donn√©es pour am√©liorer les performances
        preprocessData();
        
        console.log('Chargement des donn√©es GTFS termin√© avec succ√®s.');
        
        // Mettre √† jour les informations de version du flux
        if (feedData && feedData.publisher_name) {
            const versionInfoContainer = document.getElementById('version-info') || document.createElement('div');
            versionInfoContainer.id = 'version-info';
            versionInfoContainer.className = 'version-info';
            versionInfoContainer.innerHTML = `
                <div class="data-source">
                    Source des donn√©es : ${feedData.publisher_name}
                    ${feedData.version ? `(version ${feedData.version})` : ''}
                </div>
                <div class="data-validity">
                    ${feedData.start_date && feedData.end_date ? 
                        `Validit√© : ${formatGtfsDate(feedData.start_date)} - ${formatGtfsDate(feedData.end_date)}` : ''}
                </div>
            `;
            
            // Ajouter √† l'interface utilisateur
            const footer = document.querySelector('footer') || document.body;
            footer.appendChild(versionInfoContainer);
        }
        
        return true;
    } catch (error) {
        console.error('Erreur lors du chargement des donn√©es GTFS:', error);
        throw error;
    }
}

// Fonction pour formater les dates GTFS
function formatGtfsDate(gtfsDate) {
    if (!gtfsDate || gtfsDate.length !== 8) return '';
    const year = gtfsDate.substring(0, 4);
    const month = gtfsDate.substring(4, 6);
    const day = gtfsDate.substring(6, 8);
    return `${day}/${month}/${year}`;
}

// Fonction pour pr√©traiter les donn√©es pour de meilleures performances
function preprocessData() {
    console.log('Pr√©traitement des donn√©es...');
    
    // 1. Cr√©er un index des arr√™ts par ligne pour acc√©lerer l'affichage
    const stopsByRoute = {};
    
    Object.entries(trips).forEach(([routeId, routeTrips]) => {
        stopsByRoute[routeId] = new Set();
        
        routeTrips.forEach(trip => {
            const tripStops = stopTimes[trip.trip_id];
            if (tripStops) {
                tripStops.forEach(stop => {
                    stopsByRoute[routeId].add(stop.stop_id);
                });
            }
        });
    });
    
    // 2. Indexer les correspondances entre les lignes
    const routeConnections = {};
    
    // Trouver les arr√™ts partag√©s entre diff√©rentes lignes
    Object.entries(stopsByRoute).forEach(([routeId, routeStops]) => {
        routeConnections[routeId] = new Set();
        
        Object.entries(stopsByRoute).forEach(([otherRouteId, otherRouteStops]) => {
            if (routeId !== otherRouteId) {
                // V√©rifier si les deux lignes partagent au moins un arr√™t
                const intersection = [...routeStops].filter(stop => otherRouteStops.has(stop));
                if (intersection.length > 0) {
                    routeConnections[routeId].add(otherRouteId);
                }
            }
        });
    });
    
    // 3. Pr√©-calculer les destinations possibles pour chaque ligne
    const routeDestinations = {};
    
    Object.entries(trips).forEach(([routeId, routeTrips]) => {
        routeDestinations[routeId] = new Set();
        
        routeTrips.forEach(trip => {
            const tripStops = stopTimes[trip.trip_id];
            if (tripStops && tripStops.length > 0) {
                // Dernier arr√™t comme destination
                const lastStop = tripStops[tripStops.length - 1].stop_id;
                routeDestinations[routeId].add(lastStop);
                
                // Utiliser le headsign s'il existe
                if (trip.headsign) {
                    routeDestinations[routeId].add(trip.headsign);
                }
            }
        });
    });
    
    // Stocker les donn√©es pr√©trait√©es
    window.gtfsIndexes = {
        stopsByRoute,
        routeConnections,
        routeDestinations
    };
    
    console.log('Pr√©traitement termin√©.');
}



async function loadCalendarDates(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const serviceIdIndex = headers.indexOf('service_id');
        const dateIndex = headers.indexOf('date');
        const exceptionTypeIndex = headers.indexOf('exception_type');
        
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[serviceIdIndex] && values[dateIndex]) {
                const date = values[dateIndex]; 
                const exceptionType = parseInt(values[exceptionTypeIndex], 10); 
                
                if (!calendarDates[date]) {
                    calendarDates[date] = { added: [], removed: [] };
                }
                
                if (exceptionType === 1) {
                    calendarDates[date].added.push(values[serviceIdIndex]);
                } else if (exceptionType === 2) {
                    calendarDates[date].removed.push(values[serviceIdIndex]);
                }
            }
        });
        
        console.log(`Exceptions de calendrier charg√©es pour ${Object.keys(calendarDates).length} dates`);
    } catch (error) {
        console.error('Erreur lors du chargement des exceptions de calendrier', error);
    }
}

async function loadRoutes(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');        
        const headers = lines[0].split(',');
        const routeIdIndex = headers.indexOf('route_id');
        const shortNameIndex = headers.indexOf('route_short_name');
        const longNameIndex = headers.indexOf('route_long_name');
        const routeColorIndex = headers.indexOf('route_color');
        const routeTextColorIndex = headers.indexOf('route_text_color');
        
        
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[routeIdIndex]) {
                routes[values[routeIdIndex]] = {
                    short_name: values[shortNameIndex],
                    long_name: values[longNameIndex],
                    route_color: values[routeColorIndex] ? `#${values[routeColorIndex]}` : '#FFFFFF',
                    route_text_color: values[routeTextColorIndex] ? `#${values[routeTextColorIndex]}` : '#000000',
                };
            }
        });
        
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadTrips(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const tripRouteIdIndex = headers.indexOf('route_id');
        const tripIdIndex = headers.indexOf('trip_id');
        const tripServiceIdIndex = headers.indexOf('service_id');
        const tripHeadsignIndex = headers.indexOf('trip_headsign');
        const directionIdIndex = headers.indexOf('direction_id');
        const wheelchairAccessibleIndex = headers.indexOf('wheelchair_accessible');
        const bikesAllowedIndex = headers.indexOf('bikes_allowed');
                
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[tripRouteIdIndex] && values[tripIdIndex]) {
                if (!trips[values[tripRouteIdIndex]]) {
                    trips[values[tripRouteIdIndex]] = [];
                }
                trips[values[tripRouteIdIndex]].push({
                    trip_id: values[tripIdIndex],
                    service_id: values[tripServiceIdIndex],
                    headsign: values[tripHeadsignIndex] ? values[tripHeadsignIndex].replace(/"/g, '') : null,
                    direction_id: values[directionIdIndex] ? parseInt(values[directionIdIndex], 10) : null,
                    wheelchair_accessible: values[wheelchairAccessibleIndex] ? parseInt(values[wheelchairAccessibleIndex], 10) : 0,
                    bikes_allowed: values[bikesAllowedIndex] ? parseInt(values[bikesAllowedIndex], 10) : 0
                });
            }
        });
        
        console.log(`${Object.values(trips).reduce((sum, routeTrips) => sum + routeTrips.length, 0)} trajets charg√©s`);
    } catch (error) {
        console.error('Erreur lors du chargement des trajets:', error);
    }
}

async function loadStopTimes(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopTripIdIndex = headers.indexOf('trip_id');
        const stopIdIndex = headers.indexOf('stop_id');
        const arrivalTimeIndex = headers.indexOf('arrival_time');
        const departureTimeIndex = headers.indexOf('departure_time');
        const stopSequenceIndex = headers.indexOf('stop_sequence');
        const pickupTypeIndex = headers.indexOf('pickup_type');
        const dropOffTypeIndex = headers.indexOf('drop_off_type');
        const stopHeadsignIndex = headers.indexOf('stop_headsign');
        const timePointIndex = headers.indexOf('timepoint');
        
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[stopTripIdIndex]) {
                if (!stopTimes[values[stopTripIdIndex]]) {
                    stopTimes[values[stopTripIdIndex]] = [];
                }
                stopTimes[values[stopTripIdIndex]].push({
                    stop_id: values[stopIdIndex],
                    arrival_time: values[arrivalTimeIndex],
                    arrival_time_formatted: values[arrivalTimeIndex].split(':').slice(0, 2).join('h'),
                    departure_time: values[departureTimeIndex],
                    stop_sequence: values[stopSequenceIndex] ? parseInt(values[stopSequenceIndex], 10) : 0,
                    pickup_type: values[pickupTypeIndex] ? parseInt(values[pickupTypeIndex], 10) : 0,
                    drop_off_type: values[dropOffTypeIndex] ? parseInt(values[dropOffTypeIndex], 10) : 0,
                    stop_headsign: values[stopHeadsignIndex] ? values[stopHeadsignIndex].replace(/"/g, '') : null,
                    timepoint: values[timePointIndex] ? parseInt(values[timePointIndex], 10) : 1
                });
            }
        });
        
        Object.keys(stopTimes).forEach(tripId => {
            stopTimes[tripId].sort((a, b) => a.stop_sequence - b.stop_sequence);
        });
        
        console.log(`Horaires charg√©s pour ${Object.keys(stopTimes).length} trajets`);
    } catch (error) {
        console.error('Erreur lors du chargement des horaires d\'arr√™t:', error);
    }
}

async function loadStops(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopsIdIndex = headers.indexOf('stop_id');
        const stopsNameIndex = headers.indexOf('stop_name');
        const stopsLatIndex = headers.indexOf('stop_lat');
        const stopsLonIndex = headers.indexOf('stop_lon');
        const stopsCodeIndex = headers.indexOf('stop_code');
        const stopsDescIndex = headers.indexOf('stop_desc');
        const wheelchairBoardingIndex = headers.indexOf('wheelchair_boarding');
        const parentStationIndex = headers.indexOf('parent_station');
        
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[stopsIdIndex]) {
                stops[values[stopsIdIndex]] = {
                    name: values[stopsNameIndex] ? values[stopsNameIndex].replace(/"/g, '') : '',
                    lat: values[stopsLatIndex] ? parseFloat(values[stopsLatIndex]) : null,
                    lon: values[stopsLonIndex] ? parseFloat(values[stopsLonIndex]) : null,
                    code: values[stopsCodeIndex] ? values[stopsCodeIndex].replace(/"/g, '') : null,
                    description: values[stopsDescIndex] ? values[stopsDescIndex].replace(/"/g, '') : null,
                    wheelchair_boarding: values[wheelchairBoardingIndex] ? parseInt(values[wheelchairBoardingIndex], 10) : 0,
                    parent_station: values[parentStationIndex] || null
                };
            }
        });
        
        console.log(`${Object.keys(stops).length} arr√™ts charg√©s`);
    } catch (error) {
        console.error('Erreur lors du chargement des arr√™ts:', error);
    }
}

async function loadCalendar(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const serviceIdIndex = headers.indexOf('service_id');
        const startDateIndex = headers.indexOf('start_date');
        const endDateIndex = headers.indexOf('end_date');
        const mondayIndex = headers.indexOf('monday');
        const tuesdayIndex = headers.indexOf('tuesday');
        const wednesdayIndex = headers.indexOf('wednesday');
        const thursdayIndex = headers.indexOf('thursday');
        const fridayIndex = headers.indexOf('friday');
        const saturdayIndex = headers.indexOf('saturday');
        const sundayIndex = headers.indexOf('sunday');
        
        lines.slice(1).forEach(line => {
            if (!line.trim()) return;
            const values = line.split(',');
            if (values[serviceIdIndex]) {
                const serviceId = values[serviceIdIndex];
                
                calendar[serviceId] = {
                    weekdays: [
                        parseInt(values[mondayIndex], 10),
                        parseInt(values[tuesdayIndex], 10),
                        parseInt(values[wednesdayIndex], 10),
                        parseInt(values[thursdayIndex], 10),
                        parseInt(values[fridayIndex], 10)
                    ].includes(1),
                    saturday: parseInt(values[saturdayIndex], 10) === 1,
                    sunday: parseInt(values[sundayIndex], 10) === 1,
                    start_date: values[startDateIndex],
                    end_date: values[endDateIndex]
                };
            }
        });
        
        console.log(`${Object.keys(calendar).length} services de calendrier charg√©s`);
    } catch (error) {
        console.error('Erreur lors du chargement du calendrier', error);
    }
}

        function showView(viewId) {
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });
            
            const view = document.getElementById(viewId);
            view.classList.add('active');
            
            if (view.classList.contains('page-transition')) {
                setTimeout(() => {
                    view.classList.add('slide-in');
                }, 50);
            }
        }
        
        function showLines() {
            navigationHistory = [];
            currentRouteId = null;
            currentDestinationId = null;
            currentStopId = null;
            
            const container = document.getElementById('lines-container');
            container.innerHTML = '';
            
            Object.entries(routes).forEach(([routeId, route]) => {
                const lineItem = document.createElement('div');
                lineItem.className = 'bus-item';
                lineItem.innerHTML = `
                    <div class="line-details">
                        <span class="line-number" style="color: ${route.route_text_color}">Ligne ${route.short_name}</span>
                    </div>
                    <div style="color: ${route.route_text_color}; text-align: right;">${route.long_name.replace(/"/g, '')}</div>
                `;
                lineItem.style.backgroundColor = `${route.route_color}`;
                lineItem.onclick = () => showDestinations(routeId);
                container.appendChild(lineItem);
            });
            
            document.querySelectorAll('.page-transition').forEach(el => el.classList.remove('slide-in'));
            showView('lines-view');
        }
        
        function showDestinations(routeId) {
            currentRouteId = routeId;
            navigationHistory.push({ view: 'lines-view' });
            
            const container = document.getElementById('destinations-container');
            container.innerHTML = '';
            
            document.getElementById('route-title').textContent = `Ligne ${routes[routeId].short_name}`;
            
            const destinations = new Set();
            
            trips[routeId].forEach(({ trip_id }) => {
                const tripStops = stopTimes[trip_id];
                if (tripStops && tripStops.length > 0) {
                    const lastStop = tripStops[tripStops.length - 1].stop_id;
                    destinations.add(lastStop);
                }
            });
            
            Array.from(destinations).forEach(destinationId => {
                const destinationItem = document.createElement('div');
                destinationItem.className = 'destination-item';
                destinationItem.textContent = stops[destinationId].replace(/"/g, '');
                destinationItem.onclick = () => showStops(routeId, destinationId);
                destinationItem.style.backgroundColor = `${routes[routeId].route_color}`;
                destinationItem.style.color = `${routes[routeId].route_text_color}`;
                container.appendChild(destinationItem);
            });
            
            document.querySelectorAll('.page-transition').forEach(el => el.classList.remove('slide-in'));
            showView('destinations-view');
        }
        
        function showStops(routeId, destinationId) {
            currentDestinationId = destinationId;
            navigationHistory.push({ view: 'destinations-view', routeId });
            
            const container = document.getElementById('stops-container');
            container.innerHTML = '';
            
            document.getElementById('destination-title').textContent = 
                `Ligne ${routes[routeId].short_name} ‚ûú ${stops[destinationId].replace(/"/g, '')}`;
            
            const stopSet = new Set();
            
            trips[routeId].forEach(({ trip_id }) => {
                const tripStops = stopTimes[trip_id];
                if (tripStops) {
                    const destIndex = tripStops.findIndex(stop => stop.stop_id === destinationId);
                    if (destIndex !== -1) {
                        for (let i = 0; i < destIndex; i++) {
                            stopSet.add(tripStops[i].stop_id);
                        }
                    }
                }
            });
            
            Array.from(stopSet).forEach(stopId => {
                const stopItem = document.createElement('div');
                stopItem.className = 'stop-item';
                stopItem.textContent = stops[stopId].replace(/"/g, '');
                stopItem.onclick = () => showSchedule(routeId, stopId, destinationId);
                stopItem.style.backgroundColor = `${routes[routeId].route_color}`;
                stopItem.style.color = `${routes[routeId].route_text_color}`;
                container.appendChild(stopItem);
            });
            
            document.querySelectorAll('.page-transition').forEach(el => el.classList.remove('slide-in'));
            showView('stops-view');
        }
        
        function showSchedule(routeId, stopId, destinationId) {
    currentStopId = stopId;
    navigationHistory.push({ view: 'stops-view', routeId, destinationId });
    
    const routeColor = routes[routeId].route_color;
    const routeTextColor = routes[routeId].route_text_color;
    
    document.getElementById('route-info').textContent = 
        `Ligne ${routes[routeId].short_name} ‚Üí ${stops[destinationId].name}`;
    document.getElementById('stop-title').textContent = 
        `Horaires pour l'arr√™t ${stops[stopId].name}`;
    
    document.getElementById('route-info').style.backgroundColor = routeColor;
    document.getElementById('route-info').style.color = routeTextColor;
    document.getElementById('stop-title').style.color = routeColor;
    
    const stopInfoContainer = document.getElementById('stop-info') || document.createElement('div');
    stopInfoContainer.id = 'stop-info';
    stopInfoContainer.className = 'stop-info';
    
    const stopDetails = stops[stopId];
    let accessibilityInfo = '';
    if (stopDetails.wheelchair_boarding === 1) {
        accessibilityInfo = '<span class="accessibility-icon">‚ôø</span> Accessible aux fauteuils roulants';
    } else if (stopDetails.wheelchair_boarding === 2) {
        accessibilityInfo = '<span class="accessibility-icon">‚ö†Ô∏è</span> Non accessible aux fauteuils roulants';
    }
    
    let mapLink = '';
    if (stopDetails.lat && stopDetails.lon) {
        mapLink = `<a href="https://www.google.com/maps?q=${stopDetails.lat},${stopDetails.lon}" target="_blank" class="map-link">Voir sur la carte</a>`;
    }
    
    stopInfoContainer.innerHTML = `
        <div class="stop-details">
            ${stopDetails.code ? `<div>Code : ${stopDetails.code}</div>` : ''}
            ${stopDetails.description ? `<div>Description : ${stopDetails.description}</div>` : ''}
            ${accessibilityInfo ? `<div>${accessibilityInfo}</div>` : ''}
            ${mapLink}
        </div>
    `;
    
    const scheduleHeader = document.getElementById('schedule-header') || document.querySelector('.schedule-header');
    if (scheduleHeader) {
        scheduleHeader.after(stopInfoContainer);
    } else {
        document.getElementById('schedule-container').before(stopInfoContainer);
    }
    
    const dateSelect = document.getElementById('date-select');
    const today = new Date();
    dateSelect.value = today.toISOString().split('T')[0];
    
    dateSelect.innerHTML = '';
    for (let i = 0; i < 7; i++) {
        const date = new Date();
        date.setDate(today.getDate() + i);
        const dateStr = date.toISOString().split('T')[0];
        const option = document.createElement('option');
        option.value = dateStr;
        
        const dayNames = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        option.textContent = i === 0 ? 'Aujourd\'hui' : 
                             i === 1 ? 'Demain' : 
                             `${dayNames[date.getDay()]} ${date.getDate()}/${date.getMonth() + 1}`;
        
        dateSelect.appendChild(option);
    }
    
    dateSelect.onchange = () => updateScheduleByDate(routeId, stopId, destinationId, dateSelect.value);
    
    updateScheduleByDate(routeId, stopId, destinationId, dateSelect.value);
    
    document.querySelectorAll('.page-transition').forEach(el => el.classList.remove('slide-in'));
    showView('schedule-view');
}

function updateScheduleByDate(routeId, stopId, destinationId, dateString) {
    const scheduleContainer = document.getElementById('schedule-container');
    scheduleContainer.innerHTML = '';
    
    const selectedDate = new Date(dateString);
    const gtfsDate = selectedDate.toISOString().split('T')[0].replace(/-/g, '');
    const dayOfWeek = selectedDate.getDay(); 
    
    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const formattedDate = selectedDate.toLocaleDateString('fr-FR', dateOptions);
    
    const dateHeader = document.createElement('div');
    dateHeader.className = 'date-header';
    dateHeader.innerHTML = `<h3>Horaires pour le ${formattedDate}</h3>`;
    scheduleContainer.appendChild(dateHeader);
    
    const activeServiceIds = getActiveServiceIds(dayOfWeek, gtfsDate);
    
    if (activeServiceIds.length === 0) {
        scheduleContainer.innerHTML += `<p>Pas de service disponible pour cette date.</p>`;
        return;
    }
    
    const validTrips = trips[routeId].filter(({ trip_id, service_id }) => 
        activeServiceIds.includes(service_id)
    );
    
    if (validTrips.length === 0) {
        scheduleContainer.innerHTML += `<p>Pas de bus de cette ligne circulant √† cette date.</p>`;
        return;
    }
    
    // Cr√©er un tableau d'horaires avanc√© avec plus d'informations
    const scheduleFull = [];
    validTrips.forEach((trip) => {
        const tripStops = stopTimes[trip.trip_id];
        let destinationReached = false;
        
        if (tripStops) {
            const targetStopIndex = tripStops.findIndex(stop => stop.stop_id === stopId);
            const destinationIndex = tripStops.findIndex(stop => stop.stop_id === destinationId);
            
            if (targetStopIndex !== -1 && destinationIndex !== -1 && targetStopIndex < destinationIndex) {
                const targetStop = tripStops[targetStopIndex];
                const destinationStop = tripStops[destinationIndex];
                
                // Calculer le temps de trajet jusqu'√† destination
                const arrivalTime = parseTimeString(targetStop.arrival_time);
                const destinationTime = parseTimeString(destinationStop.arrival_time);
                const travelTimeMinutes = Math.round((destinationTime - arrivalTime) / 60000);
                
                // Extraire les informations d'accessibilit√©
                const wheelchairAccessible = trip.wheelchair_accessible === 1 ? true : false;
                const bikesAllowed = trip.bikes_allowed === 1 ? true : false;
                
                scheduleFull.push({
                    arrival_time: targetStop.arrival_time,
                    arrival_time_formatted: targetStop.arrival_time_formatted,
                    destination_time: destinationStop.arrival_time_formatted,
                    travel_time_minutes: travelTimeMinutes,
                    is_pickup_allowed: targetStop.pickup_type !== 1,
                    is_express: tripStops.length < 10, // Exemple simple pour identifier les trajets express
                    wheelchair_accessible: wheelchairAccessible,
                    bikes_allowed: bikesAllowed,
                    headsign: trip.headsign || stops[destinationId].name,
                    trip_id: trip.trip_id
                });
            }
        }
    });
    
    // Trier les horaires par heure d'arriv√©e
    scheduleFull.sort((a, b) => {
        return parseTimeString(a.arrival_time) - parseTimeString(b.arrival_time);
    });
    
    if (scheduleFull.length === 0) {
        scheduleContainer.innerHTML += `<p>Pas d'horaires disponibles pour cet arr√™t √† cette date.</p>`;
        return;
    }
    
    // Regrouper par heure
    const hours = {};
    scheduleFull.forEach(trip => {
        let [hourStr, minuteStr] = trip.arrival_time.split(':');
        let hour = parseInt(hourStr, 10);
        
        // Normaliser les heures apr√®s minuit
        if (hour >= 24) {
            hour -= 24;
        }
        
        if (!hours[hour]) hours[hour] = [];
        hours[hour].push(trip);
    });
    
    const sortedHours = Object.entries(hours).sort(([a], [b]) => parseInt(a) - parseInt(b));
    
    sortedHours.forEach(([hour, trips]) => {
        const hourContainer = document.createElement('div');
        hourContainer.className = 'hour-container';
        
        // Ent√™te de l'heure
        const hourHeader = document.createElement('div');
        hourHeader.className = 'hour-header';
        hourHeader.textContent = `${hour}h`;
        hourContainer.appendChild(hourHeader);
        
        // Liste des d√©parts pour cette heure
        const tripsList = document.createElement('div');
        tripsList.className = 'trips-list';
        
        trips.forEach(trip => {
            const minute = trip.arrival_time.split(':')[1];
            const tripItem = document.createElement('div');
            tripItem.className = 'trip-item';
            
            // Ajouter des classes pour les caract√©ristiques du trajet
            if (trip.wheelchair_accessible) tripItem.classList.add('accessible');
            if (trip.bikes_allowed) tripItem.classList.add('bikes-allowed');
            if (trip.is_express) tripItem.classList.add('express');
            if (!trip.is_pickup_allowed) tripItem.classList.add('no-pickup');
            
            let tripInfo = `
                <div class="trip-time">${minute}</div>
                <div class="trip-details">
                    <div class="trip-headsign">${trip.headsign}</div>
                    <div class="trip-duration">Arriv√©e √† ${trip.destination_time} (${trip.travel_time_minutes} min)</div>
                    <div class="trip-features">
                        ${trip.wheelchair_accessible ? '<span title="Accessible aux fauteuils roulants">‚ôø</span>' : ''}
                        ${trip.bikes_allowed ? '<span title="V√©los autoris√©s">üö≤</span>' : ''}
                        ${trip.is_express ? '<span title="Service express">‚ö°</span>' : ''}
                        ${!trip.is_pickup_allowed ? '<span title="Descente uniquement">üö´</span>' : ''}
                    </div>
                </div>
            `;
            
            tripItem.innerHTML = tripInfo;
            
            // Ajouter un √©v√©nement pour montrer plus de d√©tails sur le trajet
            tripItem.onclick = () => showTripDetails(trip.trip_id, stopId, destinationId);
            
            tripsList.appendChild(tripItem);
        });
        
        hourContainer.appendChild(tripsList);
        scheduleContainer.appendChild(hourContainer);
    });
}

function parseTimeString(timeStr) {
    const [hours, minutes, seconds] = timeStr.split(':').map(Number);
    let totalSeconds = hours * 3600 + minutes * 60 + (seconds || 0);
    // Convertir en millisecondes pour les calculs de diff√©rence
    return totalSeconds * 1000;
}

function showTripDetails(tripId, fromStopId, toStopId) {
    // Cr√©er un modal pour afficher les d√©tails du trajet
    const modalContainer = document.createElement('div');
    modalContainer.className = 'modal-container';
    
    const modal = document.createElement('div');
    modal.className = 'trip-details-modal';
    
    // R√©cup√©rer les informations du trajet
    const tripStops = stopTimes[tripId];
    if (!tripStops) {
        console.error('Trajet non trouv√©:', tripId);
        return;
    }
    
    // Trouver le trajet correspondant et sa ligne
    let routeId = null;
    let tripInfo = null;
    for (const [rid, routeTrips] of Object.entries(trips)) {
        const trip = routeTrips.find(t => t.trip_id === tripId);
        if (trip) {
            routeId = rid;
            tripInfo = trip;
            break;
        }
    }
    
    if (!routeId || !tripInfo) {
        console.error('Informations de trajet non trouv√©es');
        return;
    }
    
    const route = routes[routeId];
    const fromStopIndex = tripStops.findIndex(stop => stop.stop_id === fromStopId);
    const toStopIndex = tripStops.findIndex(stop => stop.stop_id === toStopId);
    
    // En-t√™te du modal
    const modalHeader = document.createElement('div');
    modalHeader.className = 'modal-header';
    modalHeader.style.backgroundColor = route.route_color;
    modalHeader.style.color = route.route_text_color;
    
    modalHeader.innerHTML = `
        <h3>D√©tails du trajet</h3>
        <div class="route-name">Ligne ${route.short_name} - ${tripInfo.headsign || stops[toStopId].name}</div>
        <button class="close-button">&times;</button>
    `;
    modal.appendChild(modalHeader);
    
    // Contenu du modal
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    
    // Informations sur le trajet
    const tripInfoSection = document.createElement('div');
    tripInfoSection.className = 'trip-info-section';
    
    let serviceInfo = '';
    if (calendar[tripInfo.service_id]) {
        const calData = calendar[tripInfo.service_id];
        if (calData.weekdays) serviceInfo += 'Circule en semaine. ';
        if (calData.saturday) serviceInfo += 'Circule le samedi. ';
        if (calData.sunday) serviceInfo += 'Circule le dimanche. ';
    }
    
    tripInfoSection.innerHTML = `
        <div class="trip-properties">
            <div><strong>Identifiant:</strong> ${tripId}</div>
            <div><strong>Service:</strong> ${serviceInfo}</div>
            ${tripInfo.wheelchair_accessible === 1 ? '<div>‚úì Accessible aux fauteuils roulants</div>' : ''}
            ${tripInfo.bikes_allowed === 1 ? '<div>‚úì V√©los autoris√©s</div>' : ''}
        </div>
    `;
    
    modalContent.appendChild(tripInfoSection);
    
    // Ajouter l'itin√©raire du trajet
    const itinerarySection = document.createElement('div');
    itinerarySection.className = 'itinerary-section';
    itinerarySection.innerHTML = '<h4>Itin√©raire</h4>';
    
    const timeline = document.createElement('div');
    timeline.className = 'timeline';
    
    // Obtenir les arr√™ts pertinents pour ce trajet
    const relevantStops = tripStops.slice(
        Math.min(fromStopIndex, toStopIndex),
        Math.max(fromStopIndex, toStopIndex) + 1
    );
    
    relevantStops.forEach((stop, index) => {
        const stopItem = document.createElement('div');
        stopItem.className = 'timeline-item';
        
        // Mettre en √©vidence les arr√™ts de d√©part et d'arriv√©e
        if (stop.stop_id === fromStopId) stopItem.classList.add('departure-stop');
        if (stop.stop_id === toStopId) stopItem.classList.add('arrival-stop');
        
        const stopDetails = stops[stop.stop_id];
        const timeDisplay = stop.arrival_time.split(':').slice(0, 2).join('h');
        
        stopItem.innerHTML = `
            <div class="time-marker">${timeDisplay}</div>
            <div class="stop-bullet"></div>
            <div class="stop-name">${stopDetails.name}</div>
        `;
        
        timeline.appendChild(stopItem);
    });
    
    itinerarySection.appendChild(timeline);
    modalContent.appendChild(itinerarySection);
    
    modal.appendChild(modalContent);
    
    // Ajouter un bouton pour fermer le modal
    const closeButton = modalHeader.querySelector('.close-button');
    closeButton.onclick = () => {
        document.body.removeChild(modalContainer);
    };
    
    // Ajouter un √©v√©nement pour fermer le modal en cliquant √† l'ext√©rieur
    modalContainer.onclick = (event) => {
        if (event.target === modalContainer) {
            document.body.removeChild(modalContainer);
        }
    };
    
    modalContainer.appendChild(modal);
    document.body.appendChild(modalContainer);
}

async function loadFeedInfo(fileContent) {
    try {
        if (!fileContent) {
            return;
        }
        
        let feedInfo = {};
        
        const lines = fileContent.split('\n');
        
        const headers = lines[0].split(',');
        const publisherNameIndex = headers.indexOf('feed_publisher_name');
        const publisherUrlIndex = headers.indexOf('feed_publisher_url');
        const langIndex = headers.indexOf('feed_lang');
        const startDateIndex = headers.indexOf('feed_start_date');
        const endDateIndex = headers.indexOf('feed_end_date');
        const versionIndex = headers.indexOf('feed_version');
        const contactEmailIndex = headers.indexOf('feed_contact_email');
        
        if (lines.length > 1) {
            const values = lines[1].split(',');
            
            feedInfo = {
                publisher_name: values[publisherNameIndex] ? values[publisherNameIndex].replace(/"/g, '') : null,
                publisher_url: values[publisherUrlIndex] ? values[publisherUrlIndex].replace(/"/g, '') : null,
                lang: values[langIndex] || null,
                start_date: values[startDateIndex] || null,
                end_date: values[endDateIndex] || null,
                version: values[versionIndex] || null,
                contact_email: values[contactEmailIndex] ? values[contactEmailIndex].replace(/"/g, '') : null
            };
            
            console.log('Informations sur le flux GTFS charg√©es:', feedInfo);
        }
        
        return feedInfo;
    } catch (error) {
        console.error('Erreur lors du chargement des informations du flux:', error);
        return {};
    }
}

function getActiveServiceIds(dayOfWeek, gtfsDate) {
    const activeServiceIds = [];
    
    Object.entries(calendar).forEach(([serviceId, service]) => {
        const isInDateRange = service.start_date && service.end_date && 
                              gtfsDate >= service.start_date && 
                              gtfsDate <= service.end_date;
        
        if (isInDateRange && 
            ((dayOfWeek === 0 && service.sunday) ||
             (dayOfWeek === 6 && service.saturday) ||
             (dayOfWeek >= 1 && dayOfWeek <= 5 && service.weekdays))) {
            activeServiceIds.push(serviceId);
        }
    });
    
    if (calendarDates[gtfsDate]) {
        calendarDates[gtfsDate].added.forEach(serviceId => {
            if (!activeServiceIds.includes(serviceId)) {
                activeServiceIds.push(serviceId);
            }
        });
        
        calendarDates[gtfsDate].removed.forEach(serviceId => {
            const index = activeServiceIds.indexOf(serviceId);
            if (index !== -1) {
                activeServiceIds.splice(index, 1);
            }
        });
    }
    
    return activeServiceIds;
}

function goBack() {
            if (navigationHistory.length === 0) {
                showLines();
                return;
            }
            
            const previousState = navigationHistory.pop();
            
            if (previousState.view === 'lines-view') {
                showLines();
            } else if (previousState.view === 'destinations-view') {
                showDestinations(previousState.routeId);
            } else if (previousState.view === 'stops-view') {
                showStops(previousState.routeId, previousState.destinationId);
            }
        }
    </script>
</body>
</html>