
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
@import url('https://fonts.googleapis.com/css?family=League+Spartan:400,700');

body {
    font-family: 'League Spartan', sans-serif;
    margin: 0;
    padding: 0;
    color: #333;
    background-color: #f5f5f5;
    transition: background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

h1, h2, h3, h4 {
    margin: 0.5em 0;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.container {
    margin: 0 auto;
    padding: 15px;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    margin-top: 10px;
    overflow: hidden;
}

.bus-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.bus-item {
    padding: 12px 18px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                box-shadow 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    border-radius: 12px;
    margin-bottom: 12px;
    background-color: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    position: relative;
    overflow: hidden;
}

.bus-item:hover {
    transform: scale(0.98);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
}

.bus-item:active {
    transform: translateY(0) scale(0.95);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.bus-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
    transition: left 1s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
}

.bus-item:hover::before {
    left: 120%;
}

.bus-item div {
    display: flex;
    align-items: center;
    margin: 5px 0;
    position: relative;
    z-index: 2;
}

.line-number {
    font-size: 1.3em;
    font-weight: bold;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.line-details {
    display: flex;
    align-items: center;
}

.bus-item:hover .color-box {
    transform: scale(1.2) rotate(45deg);
}

.initial-fade-in {
    animation: fadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
}

.hidden {
    display: none !important;
}

.controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding: 0 10px;
}

.btn {
    padding: 10px 18px;
    background-color: #363636;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    font-weight: bold;
    box-shadow: 0 3px 10px rgba(0, 123, 255, 0.2);
}

.btn:hover {
    background-color: #363636;
    transform: scale(0.98);
    box-shadow: 0 6px 15px rgba(0, 123, 255, 0.3);
}

.btn:active {
    transform: scale(0.95);
}

.btn-back {
    display: flex;
    align-items: center;
    gap: 8px;
}

.btn-back svg {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.btn-back:hover svg {
    transform: translateX(-5px);
}

select {
    padding: 10px 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-family: inherit;
    background-color: #f9f9f9;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    font-size: 0.95em;
}

select:hover {
    border-color: #363636;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

select:focus {
    outline: none;
    border-color: #363636;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

#loading-indicator {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 120px;
    flex-direction: column;
}


@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#error-message {
    text-align: center;
    color: #dc3545;
    padding: 20px;
    background-color: #f8d7da;
    border-radius: 10px;
    animation: shakeError 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    margin: 20px 0;
    box-shadow: 0 3px 10px rgba(220, 53, 69, 0.1);
}

@keyframes shakeError {
    0%, 100% { transform: translateX(0); }
    20%, 60% { transform: translateX(-8px); }
    40%, 80% { transform: translateX(8px); }
}

.page-transition {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                opacity 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                scale 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), 
                filter 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    opacity: 0;
    filter: blur(10px);
    transform: translateY(50px);
}

.page-transition.slide-in {
    opacity: 1;
    filter: blur(0);
    transform: translateY(0);
}




.schedule-row {
    display: flex;
    padding: 12px 10px;
    border-bottom: 1px solid #eee;
    transition: background-color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.schedule-row:hover {
    background-color: #f5f9ff;
}

.schedule-row span {
    font-weight: bold;
    width: 60px;
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.schedule-row:hover span {
    transform: scale(1.1);
    color: #363636;
}

.schedule-row span1 {
    flex: 1;
}

#schedule-container {
    overflow-y: auto;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 10px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.05);
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

#schedule-container:hover {
    background-color: #f0f7ff;
}

.textpop {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    padding: 5px 10px;
}

.textpop:hover {
    transform: translateX(5px);
}

.textpop h1 {
    font-size: 1.6em;
    color: #363636;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.textpop:hover h1 {
    color: #363636;
}

.textpop h4 {
    font-size: 1em;
    color: #666;
    font-weight: normal;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.textpop:hover h4 {
    color: #333;
}

.view {
    display: none;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.view.active {
    display: block;
    animation: fadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.destination-item, .stop-item {
    padding: 18px;
    margin: 12px 0;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    position: relative;
    overflow: hidden;
}

.destination-item::before, .stop-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
    transition: left 1s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
}

.destination-item:hover::before, .stop-item:hover::before {
    left: 120%;
}

.destination-item:hover, .stop-item:hover {
    transform: scale(0.98);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
}

.destination-item:active, .stop-item:active {
    transform: translateY(0) scale(0.95);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.date-input {
    padding: 10px 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-family: inherit;
    background-color: #f9f9f9;
    cursor: pointer;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    font-size: 0.95em;
    margin-bottom: 15px;
}

.date-input:hover {
    border-color: #363636;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.date-input:focus {
    outline: none;
    border-color: #363636;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

.date-header {
    padding: 10px 0;
    border-bottom: 2px solid #eee;
    margin-bottom: 15px;
    text-align: center;
    color: #363636;
    transition: color 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

/* Styles pour les périodes d'horaires */
.schedule-period {
    margin: 20px 0;
    padding: 15px;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.schedule-period:hover {
    transform: scale(0.995);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.period-header {
    color: #363636;
    font-size: 1.1em;
    margin-bottom: 15px;
    padding-bottom: 8px;
    border-bottom: 1px solid #eee;
}

.schedule-times {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 5px;
}

.time-slot {
    background-color: #f5f5f5;
    padding: 8px 12px;
    border-radius: 8px;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.time-slot:hover {
    transform: scale(1.05);
    background-color: #eeeeee;
}

.time {
    font-weight: bold;
    color: #363636;
}

.accessibility-icon,
.bike-icon {
    font-size: 0.9em;
    opacity: 0.8;
}

.frequency-note {
    font-size: 0.8em;
    color: #666;
    font-style: italic;
}

/* Navigation des dates */
.date-navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 15px;
}

.date-navigation button {
    background: none;
    border: none;
    font-size: 1.2em;
    color: #363636;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 50%;
    transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.date-navigation button:hover {
    background-color: #f0f0f0;
    transform: scale(1.1);
}

/* Informations de l'arrêt */
.stop-info {
    padding: 15px;
    margin-bottom: 20px;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.stop-info h4 {
    color: #363636;
    margin-bottom: 10px;
}

.stop-info p {
    color: #666;
    margin: 5px 0;
}

.accessibility,
.transfers {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    background-color: #f5f5f5;
    border-radius: 6px;
    margin-top: 10px;
    font-size: 0.9em;
    color: #363636;
}

/* Légende */
.schedule-legend {
    margin-top: 20px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    font-size: 0.9em;
    color: #666;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

/* Message d'absence de service */
.no-service-message {
    padding: 20px;
    text-align: center;
}

.alert {
    padding: 15px 20px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 10px;
    animation: fadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.alert-info {
    background-color: #e3f2fd;
    color: #0d47a1;
}

/* Route info */
.route-header {
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 12px;
}

.route-header h3 {
    margin: 0;
    font-size: 1.3em;
}

.route-header p {
    margin: 5px 0 0 0;
    font-size: 0.9em;
    opacity: 0.9;
}

    </style>
</head>
<body>
    <div class="container">
        <div id="loading-view" class="view active">
            <div id="loading-indicator">
                <p style="margin-top: 15px; color: #666;">Chargement en cours..</p>
            </div>
        </div>
        
        <div id="error-view" class="view">
            <div id="error-message">
                Erreur lors du chargement des données. Veuillez réessayer.
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="loadData()">Réessayer</button>
            </div>
        </div>
        
        <div id="lines-view" class="view page-transition">
            <h2>Sélectionnez une ligne</h2>
            <div id="lines-container" class="bus-list"></div>
        </div>
        
        <div id="destinations-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="showLines()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4>Sélectionnez une destination</h4>
                <h1 id="route-title"></h1>
            </div>
            <div id="destinations-container"></div>
        </div>
        
        <div id="stops-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="goBack()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4>Sélectionnez un arrêt</h4>
                <h1 id="destination-title"></h1>
            </div>
            <div id="stops-container"></div>
        </div>
        
        <div id="schedule-view" class="view page-transition">
            <div class="controls">
                <button class="btn btn-back" onclick="goBack()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Retour
                </button>
            </div>
            <div class="textpop">
                <h4 id="route-info"></h4>
                <h1 id="stop-title"></h1>
            </div>
            <div>
                <div>
                    <input type="date" id="date-select" class="date-input">
                </div>
            </div>
            <div id="schedule-container"></div>
        </div>
    </div>
    
    <script>
let routes = {};
let trips = {};
let stopTimes = {};
let stops = {};
let calendar = {};
let calendarDates = {};
let shapes = {};  // Nouveau : pour stocker les tracés des lignes
let frequencies = {};  // Nouveau : pour les services à fréquence fixe
let transfers = {};  // Nouveau : pour les correspondances
let fareAttributes = {};  // Nouveau : pour les informations tarifaires
let fareRules = {};  // Nouveau : pour les règles tarifaires
let agency = {};  // Nouveau : pour les informations sur l'opérateur

let navigationHistory = [];
let currentRouteId = null;
let currentStopId = null;
let currentDestinationId = null;

document.addEventListener('DOMContentLoaded', function() {
    loadData();
});

function loadData() {
    showView('loading-view');
    loadGtfsData().then(() => {
        showLines();
    }).catch(error => {
        console.error('Erreur lors du chargement des données:', error);
        showView('error-view');
    });
}

async function extractGTFSFiles() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`Échec du téléchargement: ${response.status} ${response.statusText}`);
        }
        
        const zipData = await response.arrayBuffer();
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        const filePromises = [];
        
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                    console.log(`Fichier extrait: ${relativePath}`);
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        return extractedFiles;
    } catch (error) {
        console.error('Erreur lors de l\'extraction des fichiers GTFS:', error);
        throw error;
    }
}

async function loadGtfsData() {
    try {
        const extractedFiles = await extractGTFSFiles();
        
        // Réinitialisation des structures de données
        routes = {};
        trips = {};
        stopTimes = {};
        stops = {};
        calendar = {};
        calendarDates = {};
        shapes = {};
        frequencies = {};
        transfers = {};
        fareAttributes = {};
        fareRules = {};
        agency = {};
        
        // Chargement de tous les fichiers GTFS
        await Promise.all([
            loadAgency(extractedFiles['agency.txt']),
            loadRoutes(extractedFiles['routes.txt']),
            loadTrips(extractedFiles['trips.txt']),
            loadStopTimes(extractedFiles['stop_times.txt']),
            loadStops(extractedFiles['stops.txt']),
            loadCalendar(extractedFiles['calendar.txt']),
            loadCalendarDates(extractedFiles['calendar_dates.txt']),
            loadShapes(extractedFiles['shapes.txt']),
            loadFrequencies(extractedFiles['frequencies.txt']),
            loadTransfers(extractedFiles['transfers.txt']),
            loadFareAttributes(extractedFiles['fare_attributes.txt']),
            loadFareRules(extractedFiles['fare_rules.txt'])
        ]);
        
        return true;
    } catch (error) {
        console.error('Erreur lors du chargement des données GTFS', error);
        throw error;
    }
}

// Nouvelle fonction pour charger les informations de l'agence
async function loadAgency(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const agencyIdIndex = headers.indexOf('agency_id');
    const agencyNameIndex = headers.indexOf('agency_name');
    const agencyUrlIndex = headers.indexOf('agency_url');
    const agencyTimezoneIndex = headers.indexOf('agency_timezone');
    const agencyLangIndex = headers.indexOf('agency_lang');
    const agencyPhoneIndex = headers.indexOf('agency_phone');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        const agencyId = values[agencyIdIndex] || 'default';
        agency[agencyId] = {
            name: values[agencyNameIndex]?.replace(/"/g, ''),
            url: values[agencyUrlIndex]?.replace(/"/g, ''),
            timezone: values[agencyTimezoneIndex],
            lang: values[agencyLangIndex],
            phone: values[agencyPhoneIndex]?.replace(/"/g, '')
        };
    });
}

// Fonction améliorée pour charger les routes
async function loadRoutes(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const routeIdIndex = headers.indexOf('route_id');
    const agencyIdIndex = headers.indexOf('agency_id');
    const shortNameIndex = headers.indexOf('route_short_name');
    const longNameIndex = headers.indexOf('route_long_name');
    const descIndex = headers.indexOf('route_desc');
    const typeIndex = headers.indexOf('route_type');
    const urlIndex = headers.indexOf('route_url');
    const colorIndex = headers.indexOf('route_color');
    const textColorIndex = headers.indexOf('route_text_color');
    const sortOrderIndex = headers.indexOf('route_sort_order');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        if (values[routeIdIndex]) {
            routes[values[routeIdIndex]] = {
                agency_id: values[agencyIdIndex],
                short_name: values[shortNameIndex]?.replace(/"/g, ''),
                long_name: values[longNameIndex]?.replace(/"/g, ''),
                description: values[descIndex]?.replace(/"/g, ''),
                type: parseInt(values[typeIndex], 10),
                url: values[urlIndex]?.replace(/"/g, ''),
                route_color: values[colorIndex] ? `#${values[colorIndex]}` : '#FFFFFF',
                route_text_color: values[textColorIndex] ? `#${values[textColorIndex]}` : '#000000',
                sort_order: values[sortOrderIndex] ? parseInt(values[sortOrderIndex], 10) : 0,
                trips_count: 0,  // Sera mis à jour lors du chargement des trips
                stops_count: 0,  // Sera calculé plus tard
                average_headway: 0  // Sera calculé à partir des fréquences
            };
        }
    });
}

// Fonction améliorée pour le chargement des arrêts
async function loadStops(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const stopIdIndex = headers.indexOf('stop_id');
    const codeIndex = headers.indexOf('stop_code');
    const nameIndex = headers.indexOf('stop_name');
    const descIndex = headers.indexOf('stop_desc');
    const latIndex = headers.indexOf('stop_lat');
    const lonIndex = headers.indexOf('stop_lon');
    const zoneIdIndex = headers.indexOf('zone_id');
    const urlIndex = headers.indexOf('stop_url');
    const locTypeIndex = headers.indexOf('location_type');
    const parentStationIndex = headers.indexOf('parent_station');
    const timezoneIndex = headers.indexOf('stop_timezone');
    const wheelchairIndex = headers.indexOf('wheelchair_boarding');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        if (values[stopIdIndex]) {
            stops[values[stopIdIndex]] = {
                code: values[codeIndex]?.replace(/"/g, ''),
                name: values[nameIndex]?.replace(/"/g, ''),
                description: values[descIndex]?.replace(/"/g, ''),
                lat: parseFloat(values[latIndex]),
                lon: parseFloat(values[lonIndex]),
                zone_id: values[zoneIdIndex],
                url: values[urlIndex]?.replace(/"/g, ''),
                location_type: parseInt(values[locTypeIndex] || '0', 10),
                parent_station: values[parentStationIndex] || null,
                timezone: values[timezoneIndex],
                wheelchair_boarding: parseInt(values[wheelchairIndex] || '0', 10),
                routes_serving: new Set(),  // Sera rempli pendant le traitement
                average_daily_departures: 0,  // Sera calculé
                transfer_points: []  // Sera rempli à partir des données de transfert
            };
        }
    });
}

// Nouvelle fonction pour charger les formes (tracés)
async function loadShapes(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const shapeIdIndex = headers.indexOf('shape_id');
    const latIndex = headers.indexOf('shape_pt_lat');
    const lonIndex = headers.indexOf('shape_pt_lon');
    const sequenceIndex = headers.indexOf('shape_pt_sequence');
    const distTraveledIndex = headers.indexOf('shape_dist_traveled');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        if (values[shapeIdIndex]) {
            const shapeId = values[shapeIdIndex];
            if (!shapes[shapeId]) {
                shapes[shapeId] = [];
            }
            
            shapes[shapeId].push({
                lat: parseFloat(values[latIndex]),
                lon: parseFloat(values[lonIndex]),
                sequence: parseInt(values[sequenceIndex], 10),
                dist_traveled: values[distTraveledIndex] ? parseFloat(values[distTraveledIndex]) : null
            });
        }
    });
    
    // Trier les points par séquence
    Object.values(shapes).forEach(shape => {
        shape.sort((a, b) => a.sequence - b.sequence);
    });
}

// Nouvelle fonction pour charger les fréquences
async function loadFrequencies(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const tripIdIndex = headers.indexOf('trip_id');
    const startTimeIndex = headers.indexOf('start_time');
    const endTimeIndex = headers.indexOf('end_time');
    const headwaySecsIndex = headers.indexOf('headway_secs');
    const exactTimesIndex = headers.indexOf('exact_times');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        if (values[tripIdIndex]) {
            const tripId = values[tripIdIndex];
            if (!frequencies[tripId]) {
                frequencies[tripId] = [];
            }
            
            frequencies[tripId].push({
                start_time: values[startTimeIndex],
                end_time: values[endTimeIndex],
                headway_secs: parseInt(values[headwaySecsIndex], 10),
                exact_times: values[exactTimesIndex] ? parseInt(values[exactTimesIndex], 10) : 0
            });
        }
    });
}

// Nouvelle fonction pour charger les transferts
async function loadTransfers(fileContent) {
    if (!fileContent) return;
    
    const lines = fileContent.split('\n');
    const headers = lines[0].split(',');
    
    const fromStopIndex = headers.indexOf('from_stop_id');
    const toStopIndex = headers.indexOf('to_stop_id');
    const transferTypeIndex = headers.indexOf('transfer_type');
    const minTimeIndex = headers.indexOf('min_transfer_time');
    
    lines.slice(1).forEach(line => {
        if (!line.trim()) return;
        const values = line.split(',');
        
        if (values[fromStopIndex] && values[toStopIndex]) {
            const fromStopId = values[fromStopIndex];
            const toStopId = values[toStopIndex];
            
            if (!transfers[fromStopId]) {
                transfers[fromStopId] = [];
            }
            
            transfers[fromStopId].push({
                to_stop_id: toStopId,
                transfer_type: parseInt(values[transferTypeIndex], 10),
                min_transfer_time: values[minTimeIndex] ? parseInt(values[minTimeIndex], 10) : null
            });
            
            // Mettre à jour les points de correspondance dans les stops
            if (stops[fromStopId]) {
                stops[fromStopId].transfer_points.push({
                    stop_id: toStopId,
                    transfer_type: parseInt(values[transferTypeIndex], 10),
                    min_time: values[minTimeIndex] ? parseInt(values[minTimeIndex], 10) : null
                });
            }
        }
    });
}

// Fonction améliorée pour afficher les horaires
function updateScheduleByDate(routeId, stopId, destinationId, dateString) {
    const scheduleContainer = document.getElementById('schedule-container');
    scheduleContainer.innerHTML = '';
    
    const selectedDate = new Date(dateString);
    const gtfsDate = selectedDate.toISOString().split('T')[0].replace(/-/g, '');
    const dayOfWeek = selectedDate.getDay();
    
    // Afficher les informations de l'arrêt
    const stopInfo = document.createElement('div');
    stopInfo.className = 'stop-info';
    if (stops[stopId]) {
        const stop = stops[stopId];
        stopInfo.innerHTML = `
            <h4>${stop.name}</h4>
            ${stop.description ? `<p>${stop.description}</p>` : ''}
            ${stop.wheelchair_boarding ? '<div class="accessibility">♿ Accessible PMR</div>' : ''}
            ${stop.transfer_points.length > 0 ? 
                `<div class="transfers">
                    🔄 Correspondances disponibles avec ${stop.transfer_points.length} ligne(s)
                </div>` : ''}
        `;
    }
    scheduleContainer.appendChild(stopInfo);
    
    // Afficher les informations de la ligne
    const routeInfo = document.createElement('div');
    routeInfo.className = 'route-info';
    if (routes[routeId]) {
        const route = routes[routeId];
        routeInfo.innerHTML = `
            <div class="route-header" style="background-color: ${route.route_color}; color: ${route.route_text_color}">
                <h3>Ligne ${route.short_name}</h3>
                ${route.description ? `<p>${route.description}</p>` : ''}
            </div>
        `;
    }
    scheduleContainer.appendChild(routeInfo);
    
    // Afficher la date
    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const formattedDate = selectedDate.toLocaleDateString('fr-FR', dateOptions);
    
    // En-tête de la date avec style amélioré
    const dateHeader = document.createElement('div');
    dateHeader.className = 'date-header';
    dateHeader.innerHTML = `
        <div class="date-navigation">
            <button onclick="navigateDate('${dateString}', -1)">◀</button>
            <h3>Horaires pour le ${formattedDate}</h3>
            <button onclick="navigateDate('${dateString}', 1)">▶</button>
        </div>
    `;
    scheduleContainer.appendChild(dateHeader);
    
    // Récupération des services actifs
    const activeServiceIds = getActiveServiceIds(dayOfWeek, gtfsDate);
    
    if (activeServiceIds.length === 0) {
        showNoServiceMessage(scheduleContainer, 'Pas de service disponible pour cette date.');
        return;
    }
    
    // Filtrer les trajets valides pour cette date
    const validTrips = trips[routeId].filter(({ trip_id, service_id }) => 
        activeServiceIds.includes(service_id)
    );
    
    if (validTrips.length === 0) {
        showNoServiceMessage(scheduleContainer, 'Pas de bus de cette ligne circulant à cette date.');
        return;
    }
    
    // Récupération et organisation des horaires
    const scheduleData = getScheduleData(validTrips, stopId, destinationId);
    
    // Si des fréquences sont définies, les ajouter aux horaires
    addFrequencyBasedSchedules(scheduleData, validTrips, stopId);
    
    // Affichage des horaires par période
    displayScheduleByPeriods(scheduleContainer, scheduleData);
}

// Fonction pour naviguer entre les dates
function navigateDate(currentDate, offset) {
    const date = new Date(currentDate);
    date.setDate(date.getDate() + offset);
    const newDate = date.toISOString().split('T')[0];
    document.getElementById('date-select').value = newDate;
    updateScheduleByDate(currentRouteId, currentStopId, currentDestinationId, newDate);
}

// Fonction pour afficher un message d'absence de service
function showNoServiceMessage(container, message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'no-service-message';
    messageDiv.innerHTML = `
        <div class="alert alert-info">
            <i class="fas fa-info-circle"></i>
            ${message}
        </div>
    `;
    container.appendChild(messageDiv);
}

// Fonction pour récupérer les données d'horaires
function getScheduleData(validTrips, stopId, destinationId) {
    const scheduleData = {
        morning: [],   // 5h-9h
        day: [],       // 9h-16h
        evening: [],   // 16h-20h
        night: []      // 20h-5h
    };
    
    validTrips.forEach(({ trip_id, wheelchair_accessible, bikes_allowed }) => {
        const tripStops = stopTimes[trip_id];
        let destinationReached = false;
        
        if (tripStops) {
            tripStops.forEach(({ stop_id: currentStopId, arrival_time }) => {
                if (currentStopId === destinationId) destinationReached = true;
                if (currentStopId === stopId && !destinationReached) {
                    const [hours, minutes] = arrival_time.split('h').map(num => parseInt(num, 10));
                    const normalizedHour = hours >= 24 ? hours - 24 : hours;
                    
                    const scheduleEntry = {
                        hour: normalizedHour,
                        minute: minutes,
                        wheelchair: wheelchair_accessible === 1,
                        bikes: bikes_allowed === 1,
                        realtime: false // À implémenter si des données temps réel sont disponibles
                    };
                    
                    // Classement par période
                    if (normalizedHour >= 5 && normalizedHour < 9) {
                        scheduleData.morning.push(scheduleEntry);
                    } else if (normalizedHour >= 9 && normalizedHour < 16) {
                        scheduleData.day.push(scheduleEntry);
                    } else if (normalizedHour >= 16 && normalizedHour < 20) {
                        scheduleData.evening.push(scheduleEntry);
                    } else {
                        scheduleData.night.push(scheduleEntry);
                    }
                }
            });
        }
    });
    
    // Trier les horaires dans chaque période
    Object.values(scheduleData).forEach(period => {
        period.sort((a, b) => a.hour * 60 + a.minute - (b.hour * 60 + b.minute));
    });
    
    return scheduleData;
}

// Fonction pour ajouter les horaires basés sur les fréquences
function addFrequencyBasedSchedules(scheduleData, validTrips, stopId) {
    validTrips.forEach(({ trip_id, wheelchair_accessible, bikes_allowed }) => {
        if (frequencies[trip_id]) {
            frequencies[trip_id].forEach(freq => {
                const [startHour, startMin] = freq.start_time.split(':').map(Number);
                const [endHour, endMin] = freq.end_time.split(':').map(Number);
                const headwayMinutes = freq.headway_secs / 60;
                
                let currentTime = startHour * 60 + startMin;
                const endTime = endHour * 60 + endMin;
                
                while (currentTime < endTime) {
                    const hour = Math.floor(currentTime / 60);
                    const minute = currentTime % 60;
                    
                    const scheduleEntry = {
                        hour,
                        minute,
                        wheelchair: wheelchair_accessible === 1,
                        bikes: bikes_allowed === 1,
                        frequency: true,
                        headway: headwayMinutes
                    };
                    
                    // Classer dans la période appropriée
                    if (hour >= 5 && hour < 9) {
                        scheduleData.morning.push(scheduleEntry);
                    } else if (hour >= 9 && hour < 16) {
                        scheduleData.day.push(scheduleEntry);
                    } else if (hour >= 16 && hour < 20) {
                        scheduleData.evening.push(scheduleEntry);
                    } else {
                        scheduleData.night.push(scheduleEntry);
                    }
                    
                    currentTime += headwayMinutes;
                }
            });
        }
    });
}

// Fonction pour afficher les horaires par période
function displayScheduleByPeriods(container, scheduleData) {
    const periods = [
        { key: 'morning', label: 'Matin (5h-9h)', icon: '🌅' },
        { key: 'day', label: 'Journée (9h-16h)', icon: '☀️' },
        { key: 'evening', label: 'Soir (16h-20h)', icon: '🌆' },
        { key: 'night', label: 'Nuit (20h-5h)', icon: '🌙' }
    ];
    
    periods.forEach(({ key, label, icon }) => {
        if (scheduleData[key].length > 0) {
            const periodContainer = document.createElement('div');
            periodContainer.className = 'schedule-period';
            
            periodContainer.innerHTML = `
                <h4 class="period-header">${icon} ${label}</h4>
                <div class="schedule-times">
                    ${scheduleData[key].map(time => `
                        <div class="time-slot">
                            <span class="time">${String(time.hour).padStart(2, '0')}:${String(time.minute).padStart(2, '0')}</span>
                            ${time.wheelchair ? '<span class="accessibility-icon">♿</span>' : ''}
                            ${time.bikes ? '<span class="bike-icon">🚲</span>' : ''}
                            ${time.frequency ? `<span class="frequency-note">~${time.headway}min</span>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
            
            container.appendChild(periodContainer);
        }
    });
    
    // Ajouter une légende
    const legend = document.createElement('div');
    legend.className = 'schedule-legend';
    legend.innerHTML = `
        <div class="legend-item">♿ Accessible PMR</div>
        <div class="legend-item">🚲 Vélos autorisés</div>
        <div class="legend-item">~ Fréquence approximative</div>
    `;
    container.appendChild(legend);

function goBack() {
            if (navigationHistory.length === 0) {
                showLines();
                return;
            }
            
            const previousState = navigationHistory.pop();
            
            if (previousState.view === 'lines-view') {
                showLines();
            } else if (previousState.view === 'destinations-view') {
                showDestinations(previousState.routeId);
            } else if (previousState.view === 'stops-view') {
                showStops(previousState.routeId, previousState.destinationId);
            }
        }
    }
    </script>
</body>
</html>