<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="MyBusFinder">
	<link rel="canonical" href="https://mybusfinder.fr">
	<link rel="apple-touch-icon" href="src/logo.png">
    <title>MyBusFinder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protobufjs/6.11.2/protobuf.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <meta name="google-adsense-account" content="ca-pub-5815761294049475">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
        <style>
        html, body {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
            font-family: 'League Spartan', sans-serif;
            background-color: #f4f4f4; 
            color: #333; 
            transition: background-color 0.5s ease; 
        }

        @font-face {
            font-family: 'League Spartan';
            src: url('src/fonts/leaguespartan.ttf') format('truetype');
        }

        #map {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
			
			
        .update-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 95%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    overflow-y: hidden;
}

.popup-content {
    background: white;
    width: 100%;
    height: 100%;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
}


.timepopup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 95%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper, .leaflet-popup-tip {
  background-color: transparent;
  border-radius: 15px;
  box-shadow: none !important;
  padding: 0px 0px 0px 0px;
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(13px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
  transform-origin: center bottom;
}

.leaflet-popup-content-wrapper.show, .leaflet-popup-tip.show {
  transform: scale(1) translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper.hide, .leaflet-popup-tip.hide {
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.leaflet-popup-content {
  margin: 0px;
  width: 400px;
}


.leaflet-popup-close-button {
visibility: hidden;
}

.popup-zoom-in {
    transform: scale(1) translateY(0px); 
    opacity: 1;
}

.popup-zoom-out {
    transform: scale(0.9) translateY(20px); 
    opacity: 0;
}

#menubtm {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out, background-color 0.5s ease;
}




@keyframes fadeInPopupSvc {
    from {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

@keyframes fadeOutPopupSvc {
    from {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
}

@keyframes fadeInPopup {
    from {
        opacity: 0;
        transform: translate(0%, 30%);
    }
    to {
        opacity: 1;
        transform: translate(0%, 0%);
    }
}

@keyframes fadeOutPopup {
    from {
        opacity: 1;
        transform: translate(0%, -30%);
    }
    to {
        opacity: 0;
        transform: translate(0%, 0%);
    }
}

.custom-scrollbar::-webkit-scrollbar {
    height: 8px; 
}
.custom-scrollbar::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 10px;
    border: 2px solid #f1f1f1;
}

.custom-scrollbar {
    -webkit-overflow-scrolling: touch;
}

			
.popup-content h2 {
    font-size: 24px;
    font-family: 'League Spartan', sans-serif;
    color: #333;
    margin-bottom: 15px;
}

#update-notes {
    font-family: 'League Spartan', sans-serif;
    font-size: 16px;
    color: #555;
    line-height: 1;
}

#update-notes li {
    margin-bottom: 10px;
}



#menu {
    position: absolute;
    top: 0px;
    right: 0px;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 10px;
    border-radius: 0px 0px 0px 0px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 1);
    z-index: 1000;
    height: -webkit-fill-available; 
    overflow-y: auto;
    transition: all 0.3s ease;
    display: none;
}





        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: scale(0);
            opacity: 0;
            animation: ripple-animation 0.6s linear forwards;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 1;
            }
        }

        ul {
    padding: 0;
    margin: 0;
    list-style-type: none;
    padding-inline-start: 0;
}


        .menu-item {
            cursor: pointer;
            padding: 6px;
            transition: background-color 0.3s ease; 
            border-radius: 5px;
            z-index: 100000;
        }

        .menu-item:hover {
            background-color: #0000001f; 
            animation: jspcommentlappelercettekeyframe 0.1s linear forwards;
        }

        .linesection {
            cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        }

        @keyframes jspcommentlappelercettekeyframe {
            to {
                transform: scale(0.95);
            }
        }

        .popup-content {
            font-family: 'League Spartan', sans-serif;
            font-size: 12px;
            line-height: 1.1;
        }

        .popup-header {
            padding: 5px;
            border-radius: 10px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }





@keyframes textFadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}

.loading-animation {
    font-family: 'League Spartan', sans-serif;
    font-size: 50px;  
    font-weight: bold;
    background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0); 
    -webkit-background-clip: text;
    color: transparent;
    animation: gradientTextAnimation 3s ease infinite; 
}


.share-btn, .donate-btn {
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes slideInBounce {
    0% {
        right: -100%; 
    }
    100% {
        right: 0; 
    }
}

@keyframes slideInBounceInv {
    0% {
        right: 0; 
    }
    100% {
        right: -100%; 
    }
}

#menu {
    animation: slideInBounce 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
}

#menu.hidden {
  animation: slideInBounceInv 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
}

@keyframes bounceIn {
    0% {
        transform: scale(0.9);
        opacity: 0.7;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.popup-content, .popup-content1, .popup1 {
    animation: zoomFadeIn 0.6s cubic-bezier(0.25, 1.5, 0.5, 1) forwards;
}

@keyframes zoomFadeIn {
    0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(13px); 

    }
    100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0); 
    }
}


.marker-icon {
    animation: zoomInOut 2s infinite;
}

@keyframes zoomInOut {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.13); }
}


span[style*="padding: 5px 10px;"] {
    animation: badgePulse 1.5s infinite;
}
@keyframes badgePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

#nextStopsContent div {
    animation: fadeInScroll 0.3s ease-in;
	display: inherit;
}
@keyframes fadeInScroll {
    from { opacity: 0; }
    to { opacity: 1; }
}

.marker-icon:hover {
    animation: hoverBounce 0.3s ease-in-out;
}
@keyframes hoverBounce {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.glass-effect {
    position: relative;
    overflow: hidden;
}

.glass-effect::before {
    content: '';
    position: absolute;
    top: 0;
    left: -140%;
    width: 140%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
}

.glass-effect.animate::before {
    animation: glass-slide 1s ease forwards;
}

@keyframes glass-slide {
    0% {
        left: -100%;
    }
    100% {
        left: 150%;
    }
}
			
@keyframes gradientTextAnimation {
    0% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
    50% {
        background: linear-gradient(45deg, #ffffff, #f0f0f0, #ffffff);
    }
    100% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
}

:root {
  --base_scale: 3vh;
  --floor: 15vh;
  --color: #836ee5;
}

body {
  margin: 0;
  overflow: hidden;
}

#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #000000;
  background-size: cover;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 10000;
}

.shapes-container {
  width: 100%;
  overflow: hidden;
}

shape {
  position: absolute;
  display: block;
  left: 50%;
  bottom: 0;
  margin-left: calc(-1 * (var(--base_scale) / 2));
  margin-bottom: var(--floor);
  transform-origin: center;
}

shape.circle {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
  border-radius: 50%;
}

shape.semi-circle {
  width: var(--base_scale);
  height: calc(var(--base_scale) * 2);
  background: var(--color);
  border-bottom-right-radius: calc(var(--base_scale) * 2);
  border-top-right-radius: calc(var(--base_scale) * 2);
}

shape.square {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
}

shape.bounce-up {
  animation: bounceUp 600ms cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
}

shape.bounce-down {
  animation: bounceDown 600ms cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards;
}

@keyframes bounceUp {
  0% {
    transform: translateY(0) rotate(0deg);
  }
  100% {
    transform: translateY(-30vh) rotate(180deg);
  }
}

@keyframes bounceDown {
  0% {
    transform: translateY(-30vh) rotate(180deg);
  }
  100% {
    transform: translateY(0) rotate(360deg);
  }
}

#stop-suggestions li {
    padding: 10px;
    cursor: pointer;
    border-bottom: 1px solid #ddd;
}

#stop-suggestions li:hover {
    background-color: #f4f4f4;
}


#loading-text {
  margin-top: 20px;
  font-size: 18px;
  color: black;
  animation: fadeIn 1.5s ease forwards;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.filtre {
    display: flex;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%) translateY(-100%);
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    padding: 10px 15px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.filtre-texte {
    color: #ffffff;
}

.menubottom-ul {
    display: flex;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%);
    padding: 12px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    padding: 0;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5); 
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.menubottom ul li {
    margin: 0 8px; 
}

        .menubottom ul li a {
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 20px;
            font-family: League Spartan;
            text-decoration: none;
            height: 70px;
            width: 70px;
            position: relative;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
                }

        .menubottom ul li a .icon {
            position: relative;
            font-size: 20px;
            transition: transform 0.2s ease-in-out;
            transition: .3s;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .menubottom ul li a .title {
    margin-bottom: 8px; 
    font-size: 14px;
    text-align: center;
    opacity: 1; 
    transition: none; 
}

.menubottom ul li a:hover .icon {
    transform: scale(0.8); 
}

        .menubottom ul li a:active {
    transform: scaleX(70%)scaleY(70%); 
    background-color: rgba(255, 255, 255, 0); 
}


@keyframes barFadeIn {
    0% {
        opacity: 0;
        transform: translateY(60px); 
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}


			
.next-stops-container {
	max-height: 100px;
    padding: 10px;
    background: #f9f9f9;
    border-top: 1px solid #ddd;
    position: relative;
}

.next-stops-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.next-stops-content {
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
    padding-inline-start: 0;
    list-style-type: none; 
    overflow-y: auto;
}

@media (max-width: 1024px) {
  .next-stops-content {
    scrollbar-width: none; 
  }

  .next-stops-content::-webkit-scrollbar {
    display: none;
  }
}

.popup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: fadeInPopup 0.5s forwards;
    background-color: #ffffff; 
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
    max-height: 80%;
    width: 90%;
    max-width: 500px;
    z-index: 1001;
    overflow-y: auto;
    opacity: 0; 
        }

        .popup-content {
            text-align: center;
        }

        .close-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #333;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    transition: background-color 0.3s;
}

.close-btn:hover {
    background-color: #555;
}

        .textpop h4 {
    margin-bottom: 0.3rem;
}

.textpop h1 {
    margin-top: 0;
}



.slide-down {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.logoscr {
  transform: translateY(100px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
}

.popup-slide {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}

.popup-slide-hidden {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(-30%);
    opacity: 0;
}

.popup-slide-right {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(30%);
    opacity: 0;
}

.popup-slide-active {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}



.schedule-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    padding: 5px;
    background: #f8f9fa;
    border-radius: 8px;
}

.schedule-row span {
    font-weight: bold;
    color: #333;
}


.logoscrapp {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
}

.logoscrappp {
  transform: scale(0.8); 
  filter: blur(0); 
}

.logoscrapppp {
  opacity: 0; 
}

@media (max-width: 600px) {
    #logoscr {
      width: 50%;  
      max-width: 200px;  
    }
  }

  @media (min-width: 1200px) {
    #logoscr {
      width: 10%;  
      max-width: 400px;  
    }
  }

.slide-up {
  transform: translateY(-100%); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.slide-downb {
  transform: translateY(0) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upb {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.2s ease-in, filter 0.2s ease-in;
}


.slide-downc {
  transform: translateY(-220%) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upc {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

#popup1::-webkit-scrollbar {
        width: 8px;
    }
    #popup1::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb:hover {
        background: #555;
    }


@keyframes loadingBarAnimation {
    0% {
        width: 0%;
    }
    50% {
        width: 100%;
    }
    100% {
        width: 100%;
    }
}


        .marker-icon:hover {
        transform: scale(0.8);
        transition: transform 0.2s ease;
        }

      

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes zoomOut {
            from {
                transform: scale(1);
                opacity: 1;
            }
            to {
                transform: scale(1.5);
                opacity: 0;
            }
        }

@keyframes fadeColors {
    0% { background-color: rgb(0, 0, 0); }
    25% { background-color: rgb(0, 0, 168); }
    50% { background-color: rgb(0, 158, 158); }
    75% { background-color: rgb(155, 155, 0); }
    100% { background-color: rgb(0, 0, 0); }
}

.logobkg {
  transition: opacity 0.3s ease-out;
}
.loading-screen-fade {
    animation: fadeColors 1s ease-in; 
}

#webview-frame {
    width: 100%;
    height: 100%;
    border-radius: 10px;
}

.vehicle-thumbnail {
    width: 95.5%;
    margin-left: auto;
    border-radius: 5px;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 2px;
}

.vehicle-model {
    display: flex;
    align-items: right;
    justify-content: flex-end;
    flex-direction: column;
}

.stops-timeline-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 400px;
    z-index: 1000;
    overflow: hidden;
    max-height: 80vh;
    display: none;
    opacity: 0;
    filter: blur(5px);
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                opacity 0.3s ease-out,
                filter 0.3s ease-out;
}

.stops-timeline-menu.visible {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    filter: blur(0);
}

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

.overlay.visible {
    opacity: 1;
}

.show-in-map-btn {
    margin: 20px;
    padding: 12px;
    background: #363636;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    width: calc(100% - 40px);
    position: sticky;
    bottom: 0;
    transition: transform 0.3s ease, background-color 0.3s ease;
}

.show-in-map-btn:hover {
    background: #2c2c2c;
    transform: scale(0.98);
}

.show-in-map-btn:active {
    transform: scale(0.95);
}

.leaflet-control-locate a {
  cursor: pointer;
}
.leaflet-control-locate a .leaflet-control-locate-location-arrow {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate a .leaflet-control-locate-spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M304 48a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48 368a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm208-208a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM96 256a48 48 0 1 0-96 0 48 48 0 0 0 96 0zm13 99a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm294 0a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM109 61a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"/></svg>');
  animation: leaflet-control-locate-spin 2s linear infinite;
}
.leaflet-control-locate.active a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(32, 116, 182)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate.following a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(252, 132, 40)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}

.leaflet-touch .leaflet-bar .leaflet-locate-text-active {
  width: 100%;
  max-width: 200px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  padding: 0 10px;
}
.leaflet-touch .leaflet-bar .leaflet-locate-text-active .leaflet-locate-icon {
  padding: 0 5px 0 0;
}

.leaflet-control-locate-location circle {
  animation: leaflet-control-locate-throb 4s ease infinite;
}

@keyframes leaflet-control-locate-throb {
  0% {
    stroke-width: 1;
  }
  50% {
    stroke-width: 3;
    transform: scale(0.8, 0.8);
  }
  100% {
    stroke-width: 1;
  }
}
@keyframes leaflet-control-locate-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.alerts-button {
    display: flex;
    align-items: center;
    background-color: #000000;
    color: #ffffff;
    padding: 15px 18px;
    margin-bottom: 8px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), 
                box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1),
                background-color 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
    position: relative;
    overflow: hidden;
    animation: fadeInUp 0.3s ease-out forwards;
}

.alerts-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
    transform: skewX(-25deg);
    transition: left 0.8s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
    pointer-events: none;
}

.alerts-button:hover::before {
    left: 120%;
}

.alerts-button:hover {
    transform: scale(0.98);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    background-color: #222222;
}

.alerts-button:active {
    transform: scale(0.95);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    background-color: #333333;
    transition: all 0.1s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.alerts-button:active .alerts-icon {
    transform: scale(1.2) rotate(5deg);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.alerts-icon {
    margin-right: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
    transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
}


.alerts-button:hover .alerts-icon {
    transform: scale(1.2);
}

.alerts-content {
    z-index: 2;
}

.alerts-title {
    font-weight: normal;
    font-size: 20px;
}

.alerts-description {
    font-size: 14px;
    opacity: 0.8;
}

@media (max-width: 1024px) {
  .options {
    scrollbar-width: none; 
  }

  .options::-webkit-scrollbar {
    display: none;
  }
}

.bus-stop-marker {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: white;
    border: 1px solid black;
}

.line-popup, .stop-popup {
    padding: 5px;
}

.line-popup h4, .stop-popup h4 {
    margin: 0 0 5px 0;
    font-weight: bold;
}


    </style>

</head>
<body>
<!--          _   __                         ________                                                                          -->
<!--         //   ) )                __     /__  ___/                                                                          -->
<!--        ((                  ___ / /       / /   __      ___       __      ___      ___      ___      __    __  ___  ___    -->
<!--          \\     //   / / //   ) /       / /  //  ) ) //   ) ) //   ) ) ((   ) ) //   ) ) //   ) ) //  ) )  / /   ((   ) ) -->
<!--            ) ) //   / / //   / /       / /  //      //   / / //   / /   \ \    //___/ / //   / / //       / /     \ \     -->
<!--     ((___ / / ((___( ( ((___/ /       / /  //      ((___( ( //   / / //   ) ) //       ((___/ / //       / /   //   ) )   -->
<!--                                                          Code ayant pour entière propriété Sud Transports/Bechir Abidi    -->
<!--                                                                Réutilisation non autorisée sauf en cas de dérogation !    -->

<div class="filtre" id="filtre">
    <span class="filtre-texte">Réinitialiser les filtres</span>
</div>


 <div class="menubottom">
        <ul id="menubtm" class="menubottom-ul">
            <li>
                <a href="https://mybusfinder.fr/"><span class="icon"><img src="src/menu.png" style="width: 40px; height: 40px;"></img></span> <span
                    class="title">Menu</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('schedule.html');" id="clock"><span class="icon"><img src="src/horloge.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Horaires</span></a>
            </li>
            <li>
                <a id="menubutton"><span class="icon"><img src="src/bus.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Réseau</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('alerts.html');" id="histovecbutton"><span class="icon"><img src="src/newspaper.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Actualités</span></a>
            </li>
        </ul>
</div>
	



	<amp-auto-ads type="adsense"
        data-ad-client="ca-pub-5815761294049475">
</amp-auto-ads>


    <div id="map"></div>


    <div id="menu"></div>
    <div id="update-popup" class="update-popup">
        <div class="popup-content">
            <button id="close-popup" class="close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            <iframe id="webview-frame" src="" frameborder="0"></iframe>
        </div>
    </div>
                


	
	
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


	
<div id="loading-screen" class="logobkg">
    <img id="logoscr" class="logoscr" src="src/whitelogo.png" style="display: block; margin: 0 auto; max-width: 50%; height: auto;"/>
</div>
  

 <script src="src/js/toastjs.js"></script>       
 <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5815761294049475"
     crossorigin="anonymous"></script>

<script>
async function getSetvar() {
    try {
        const response5 = await fetch('setvar/settings/theme/maincolor.txt');
        const setvar5 = await response5.text();  
        const colorbkg = setvar5.trim();

        const response = await fetch('setvar/settings/map/defaultzoom.txt');
        const setvar = await response.text();
        const view = setvar.trim();  

        const response1 = await fetch('setvar/settings/networkname.txt');
        const setvar1 = await response1.text();
        const nomdureseau = setvar1.trim();  

        return { colorbkg, view, nomdureseau };

    } catch (error) {
        console.error('Erreur chargement setvar ! ', error);
    }
}

getSetvar();



const vehicleModels = {};

const vehicleTypes = {
    'elec': new Set(),
    'hybrid': new Set(),
    'gnv': new Set(),
    'usb': new Set(),
    'clim': new Set()
};

let map;

async function setColors() {
    const data = await getSetvar();
    if (data) {
        document.getElementById("menubtm").style.backgroundColor = `${data.colorbkg}9c`;
        document.getElementById("menu").style.backgroundColor = `${data.colorbkg}9c`;
        document.getElementById("filtre").style.backgroundColor = `${data.colorbkg}9c`;

    }
}
setColors();

setTimeout(() => {
    const logoscr = document.getElementById('logoscr');
    logoscr.classList.add('logoscrapp');
}, 10); 

async function initMap() {
    const data = await getSetvar();
    let defaultCoords = [43.125463, 5.930077];
    let defaultZoom = 13;
    
    if (data && data.view) {
        try {
            const viewConfig = data.view.match(/\[(.*?)\],\s*(\d+)/);
            if (viewConfig && viewConfig.length >= 3) {
                const coords = viewConfig[1].split(',').map(coord => parseFloat(coord.trim()));
                defaultCoords = [coords[0], coords[1]];
                defaultZoom = parseInt(viewConfig[2]);
            }
        } catch (error) {
            console.error('Erreur parsing des coord gps', error);
        }
    }
    
    const mapInstance = L.map('map', {
        zoomControl: false 
    }).setView(defaultCoords, defaultZoom);
    
    L.popup({
        closeButton: false
    });
    
    mapInstance.on('popupopen', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-out', 'popup-zoom-in');
        setTimeout(() => {
            popupWrapper.classList.add('popup-zoom-in');
        }, 10); 
    });
    
    mapInstance.on('popupclose', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-in');
        popupWrapper.classList.add('popup-zoom-out');
        popupWrapper.addEventListener(
            'transitionend',
            () => {
                popupWrapper.classList.remove('popup-zoom-out');
            },
            { once: true }
        );
    });

    
   const getSunTimes = (latitude, longitude) => {
        const currentDate = new Date();
        const sunTimes = SunCalc.getTimes(currentDate, latitude, longitude);
        return {
            sunrise: sunTimes.sunrise,
            sunset: sunTimes.sunset
        };
    };

    const { sunrise, sunset } = getSunTimes(defaultCoords[0], defaultCoords[1]);
    const currentTime = new Date();
    
    const isNightMode = currentTime >= sunset || currentTime <= sunrise;

    const isStandardView = localStorage.getItem('isStandardView') === 'true';
    
    if (!isStandardView) {
    const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
    
    const tileLayer = L.tileLayer(tileLayerUrl, {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(mapInstance);
    
    if (isNightMode) {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'none';
    }
} else {
    const mapPane = mapInstance.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(mapInstance);
}




mapInstance.attributionControl.setPrefix('');

    mapInstance.on('locationfound', onLocationFound);
    mapInstance.on('locationerror', onLocationError);

    return mapInstance;
}

function onLocationFound(e) {
    const radius = e.accuracy / 2;

    if (window.locationMarker) {
        map.removeLayer(window.locationMarker);
    }
    if (window.locationCircle) {
        map.removeLayer(window.locationCircle);
    }

    window.locationCircle = L.circle(e.latlng, {
        radius: radius,
        color: '#136AEC',
        fillColor: '#136AEC',
        fillOpacity: 0.15,
        weight: 2
    }).addTo(map);

    map.setView(e.latlng, 16);
}

function onLocationError(e) {
    toastBottomRight.warning("Vous avez refusé la localisation.");
}

function locateUser() {
    if (!map) return;
    
    if ("geolocation" in navigator) {
        const locationOptions = {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
        };

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;

                map.fireEvent('locationfound', {
                    latlng: L.latLng(lat, lng),
                    accuracy: accuracy,
                    timestamp: position.timestamp
                });
            },
            (error) => {
                map.fireEvent('locationerror', {
                    code: error.code,
                    message: error.message
                });
            },
            locationOptions
        );
    } else {
        toastBottomRight.error("La géolocalisation n'est pas supportée par votre navigateur");
    }
}

(async function() {
    map = await initMap();
})();


        const markers = {};
        let lineColors = {};
        let lineName = {};
        let stopIds = [];
        let stopNameMap = {}
        let selectedLine = null;
        let geoJsonLines = []; 
        let tripUpdates = {};
        let loadingInterval;


        function showLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    loadingScreen.style.display = 'flex';


    loadingInterval = setInterval(() => {}, 1000);
}
		


        var audio = new Audio("src/sounds/musique.mp3"); 

function showUpdatePopup(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = link; 
    popup.style.display = 'flex'; 


    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');

            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
                const filtre = document.getElementById('filtre');
                filtre.classList.add('slide-upc');
                filtre.classList.remove('slide-downc');
                resetMapView();
            }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });


}

window.addEventListener('message', function(event) {
    if (event.data && event.data.action === 'showUpdatePopup') {
        if (window.parent && typeof window.parent.showUpdatePopup === 'function') {
            window.parent.showUpdatePopup(event.data.url);
        }
    }
}, false);



function focusOnVehicle(vehicleId) {
    try {        
        closeUpdatePopup();
        
        const marker = Object.values(markers).find(m => m.id === vehicleId);
        
        if (!marker) {
            toastBottomRight.error('La position du véhicule est indisponible');
            return;
        }
        
        
        try {
            map.setView(marker.getLatLng(), 17);
            marker.openPopup();
            
            const markerIcon = marker._icon.querySelector('.marker-icon');
            if (!markerIcon) {
                toastBottomRight.error('La position du véhicule est indisponible');

                return;
            }
            
            markerIcon.style.transform = 'scale(1.3)';
            setTimeout(() => {
                markerIcon.style.transform = 'scale(1)';
            }, 500);
            
        } catch (mapError) {
            toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : manipulating marker error');
        }
    } catch (error) {
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : focusOnVehicle function error');
    }
}

window.addEventListener('message', function(event) {
    try {        
        if (event.data && event.data.type === 'vehicleSelected') {
            const vehicleId = event.data.vehicleId;
            focusOnVehicle(vehicleId);
        }
    } catch (error) {
        console.error('Error ', error);
    }
});

function closeUpdatePopup() {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = ""; 
    popup.style.display = 'none'; 
    
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    menu.classList.add('hidden');
    menu.addEventListener('transitionend', function onTransitionEnd(event) {
        if (event.target === menu) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false; 
    menubottom1.style.display = 'flex';
    
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);
    
    if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
    }
}


function musique() {
    if (audio.paused) {
        audio.play();
    }
}


document.getElementById('close-popup').addEventListener('click', closeUpdatePopup);




function hideLoadingScreen() {
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.classList.add('loading-screen-fade');


        setTimeout(() => {
            const logoscr = document.getElementById('logoscr');
            logoscr.classList.add('logoscrappp');
            loadingScreen.classList.add('logoscrapppp');


            setTimeout(() => {
                loadingScreen.style.display = 'none';
                if(!localStorage.getItem('premierLancement')) {
                    showUpdatePopup('https://mybusfinder.fr/updatecm/updatecm.html');
                    localStorage.setItem('premierLancement', 'true');
                } 
            }, 300);
        }, 900);
    }, 100);
}


document.addEventListener('DOMContentLoaded', initializeApp);
const doc = document;
showLoadingScreen();


let data;

let DB_NAME;
let STORE_NAME;
const DB_VERSION = 4;

async function initConstants() {
    try {
        const { nomdureseau } = await getSetvar();
        DB_NAME = `MyBusFinder${nomdureseau}`;
        STORE_NAME = `gtfsStore${nomdureseau}`;
        return { DB_NAME, STORE_NAME };
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des constantes', error);
        DB_NAME = 'MyBusFinderDefault';
        STORE_NAME = 'gtfsStoreDefault';
        return { DB_NAME, STORE_NAME };
    }
}

async function initDB() {
    if (!DB_NAME || !STORE_NAME) {
        await initConstants();
    }
    
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function calculateSHA256(data) {
    let buffer;
    if (data instanceof ArrayBuffer) {
        buffer = data;
    } else if (typeof data === 'string') {
        const encoder = new TextEncoder();
        buffer = encoder.encode(data).buffer;
    } else if (data instanceof Blob) {
        buffer = await data.arrayBuffer();
    } else {
        const jsonString = JSON.stringify(data);
        const encoder = new TextEncoder();
        buffer = encoder.encode(jsonString).buffer;
    }

    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return hashHex;
}

async function getFileHash() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php', {
            method: 'GET',
            headers: {
                'X-Content-Only-Header': 'true'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Échec de la vérif ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const partialData = buffer.slice(0, Math.min(buffer.byteLength, 1024 * 50));
        
        const fileHash = await calculateSHA256(partialData);
        
        return { fileHash, needsFullDownload: true };
    } catch (error) {
        console.error('Erreur lors de la vérif du hash', error);
        return { needsFullDownload: true };
    }
}

async function checkGTFSUpdate() {
    try {
        const db = await initDB();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        
        const storedMetadata = await new Promise((resolve, reject) => {
            const request = store.get('gtfsMetadata');
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        if (!storedMetadata || !storedMetadata.fileHash) {
            return { needsUpdate: true };
        }
        
        const { fileHash, needsFullDownload } = await getFileHash();
        
        if (fileHash !== storedMetadata.fileHash) {
            return { needsUpdate: true, fileHash };
        }
        
        return { needsUpdate: false, metadata: storedMetadata };
    } catch (error) {
        console.error('Erreur vérif maj GTFS', error);
        return { needsUpdate: true };
    }
}

async function saveToCache(data, metadata) {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            store.put(data, 'gtfsData');
            
            if (!metadata) {
                metadata = {};
            }
            metadata.lastUpdate = new Date().toISOString();
            store.put(metadata, 'gtfsMetadata');

            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('Erreur sauvegarde dans le cache', error);
        throw error;
    }
}

async function getFromCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('gtfsData');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de la récup cache', error);
        return null;
    }
}

async function extractGTFSFiles() {
    try {

        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`Échec téléchargement ${response.status} ${response.statusText}`);
        }
        
        const zipData = await response.arrayBuffer();
        
        const fileHash = await calculateSHA256(zipData.slice(0, Math.min(zipData.byteLength, 1024 * 50)));
        
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        
        const filePromises = [];
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        
        const metadata = {
            fileHash,
            lastUpdate: new Date().toISOString()
        };
        
        return { extractedFiles, metadata };
    } catch (error) {
        throw error;
    }
}

async function loadLineColors(routesFileContent) {
    try {
        if (!routesFileContent) {
            return;
        }
        
        const data = await getSetvar();
        if (!data) {
            console.error('Échec récupération variables de config');
            return;
        }
        
        const lines = routesFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const routeIdIndex = headers.indexOf('route_id');
        const routeLongNameIndex = headers.indexOf('route_short_name');
        const routeColorIndex = headers.indexOf('route_color');
        
        if (routeIdIndex === -1 || routeLongNameIndex === -1 || routeColorIndex === -1) {
            console.error('Impossible de trouver tous les entêttes requis dans fichier routes.txt');
            return;
        }
        
        const startIndex = data.slicelinecolor ? parseInt(data.slicelinecolor) : 1;
        
        lines.slice(startIndex).forEach(line => {
            if (!line.trim()) return;
            
            const columns = line.split(',');
            
            if (columns.length <= Math.max(routeIdIndex, routeLongNameIndex, routeColorIndex)) {
                return;
            }
            
            const routeId = columns[routeIdIndex];
            const routeLongName = columns[routeLongNameIndex];
            let routeColor = columns[routeColorIndex];
            if (routeColor && !routeColor.startsWith('#') && routeColor.trim() !== '') {
                routeColor = `#${routeColor}`;
            }
            
            let cleanedLineName = routeLongName ? routeLongName.replace(/\"/g, '').trim() : '';
            if (routeId) {
                lineColors[routeId] = routeColor;
                lineName[routeId] = cleanedLineName;
            }
        });
        
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadStopIds(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        
        if (stopIdIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    if (stopId) {
                        stopIds.push(stopId);
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadLineTerminusData(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        const stopNameIndex = headers.indexOf('stop_name');
        
        if (stopIdIndex !== -1 && stopNameIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    let stopName = columns[stopNameIndex];
                    
                    stopName = stopName.replace(/\"/g, '');
                    
                    if (stopId && stopName) {
                        stopNameMap[stopId] = stopName;
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function initializeGTFS() {
    try {
        Object.keys(lineColors).forEach(key => delete lineColors[key]);
        Object.keys(lineName).forEach(key => delete lineName[key]);
        stopIds.length = 0;
        Object.keys(stopNameMap).forEach(key => delete stopNameMap[key]);
        
        let extractedFiles;
        
        const { needsUpdate, fileHash, metadata } = await checkGTFSUpdate();
        
        if (needsUpdate) {
            const result = await extractGTFSFiles();
            extractedFiles = result.extractedFiles;
            
            await saveToCache(extractedFiles, result.metadata);
            
        } else {
            extractedFiles = await getFromCache();
            if (!extractedFiles) {
                const result = await extractGTFSFiles();
                extractedFiles = result.extractedFiles;
                await saveToCache(extractedFiles, result.metadata);
                toastBottomRight.success('Données téléchargées avec succès !');
            } 
        }
        
        if (extractedFiles['routes.txt']) {
            await loadLineColors(extractedFiles['routes.txt']);
        }
        
        if (extractedFiles['stops.txt']) {
            await loadStopIds(extractedFiles['stops.txt']);
            await loadLineTerminusData(extractedFiles['stops.txt']);
        } else {
            console.error('Fichier stops.txt non trouvé');
        }
        
        return {
            lineColors,
            lineName,
            stopIds,
            stopNameMap
        };
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation data théorique gtfs', error);
        throw error;
    }
}

async function clearGTFSCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
                toastBottomRight.success('Cache effacé avec succès !');
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de l\'effacement du cache', error);
        toastBottomRight.error('Erreur lors de l\'effacement du cache');
        throw error;
    }
}

async function decodeProtobuf(buffer) {
            const root = await protobuf.load('gtfs-realtime.proto');
            const FeedMessage = root.lookupType('transit_realtime.FeedMessage');
            const message = FeedMessage.decode(new Uint8Array(buffer));
            return FeedMessage.toObject(message, { longs: String });
        }

        window.addEventListener('message', function(event) {
    if (event.data.type === 'vehicleSelected') {
        const vehicleId = event.data.vehicleId;
        const tripId = event.data.tripId;
        const stopId = event.data.stopId;
        const routeId = event.data.routeId;
        
        const marker = findMarkerByVehicleId(vehicleId);
        if (marker) {
            map.setView(marker.getLatLng(), 17);
            
            marker.openPopup();
            
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            menu.addEventListener('transitionend', function onTransitionEnd(event) {
                if (event.target === menu) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false;
            
            if (selectedLine) {
                resetMapView();
            }
        }
    }
});

function findMarkerByVehicleId(vehicleId) {
    for (const [id, marker] of Object.entries(markers)) {
        if (marker.id === vehicleId) {
            return marker;
        }
    }
    return null;
}

let lastActiveMarkerId = null;

let lastActiveColor = null;

function createColoredMarker(lat, lon, route_id, bearing = 0) {
    const generateUniqueId = () => `popup-style-${Math.random().toString(36).substr(2, 9)}`;
    
    const color = lineColors[route_id] || '#000000';
    const markerHtmlStyles = `
        background-color: ${color};
        width: 12px;
        height: 12px;
        display: block;
        left: -6px;
        top: -6px;
        position: relative;
        border-radius: 50%;
        border: 2px solid white;
        transition: transform 0.2s ease, background-color 0.3s ease;
    `;

    const arrowSvg = `
        <svg class="marker-arrow" style="
            position: absolute;
            width: 16px;
            height: 16px;
            left: 4px;
            top: -2px;
            transform-origin: 2px; 
            transform: rotate(${bearing - 90}deg);
            transition: transform 0.5s ease;"
            viewBox="0 0 24 24">
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="white"
                stroke-width="6"
                stroke-linecap="round"
                stroke-linejoin="round"
            />
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="${color}"
                stroke-width="3"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="marker-arrow-path"
            />
        </svg>
    `;

    const icon = L.divIcon({
        className: "my-custom-pin",
        iconAnchor: [0, 0],
        popupAnchor: [0, 5],
        html: `
            <div style="position: relative;">
                <span style="${markerHtmlStyles}" class="marker-icon" />
                ${arrowSvg}
            </div>
        `
    });

    const marker = L.marker([lat, lon], { icon });
    const styleId = generateUniqueId();
    
    marker.on('popupopen', function(e) {
        const menubtm = document.getElementById('menubtm');
        const filtre = document.getElementById('filtre');

        if (menubtm) {
            const markerId = marker.id;
            const color = lineColors[route_id] || '#000000';
            

            if (lastActiveMarkerId !== null && lastActiveMarkerId !== markerId && lastActiveColor !== null) {
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                let textColor = '#FFFFFF';
                if (rgb) {
                    const r = parseInt(rgb[1], 16);
                    const g = parseInt(rgb[2], 16);
                    const b = parseInt(rgb[3], 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                }
                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                    #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            } else {
                const currentColor = window.getComputedStyle(menubtm).backgroundColor;
                
                const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                let textColor = '#FFFFFF';
                if (rgb) {
                    const r = parseInt(rgb[1], 16);
                    const g = parseInt(rgb[2], 16);
                    const b = parseInt(rgb[3], 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                }
                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                        #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            }
            
            lastActiveMarkerId = markerId;
            lastActiveColor = color;
        }
    });

    marker.on('popupclose', async function(e) {
    const menubtm = document.getElementById('menubtm');
    const filtre = document.getElementById('filtre');
    
    if (menubtm && filtre) {
        try {
            setTimeout(async () => {
                if (lastActiveMarkerId === marker.id) {
                    const data = await getSetvar();
                    
                    if (data) {
                        const menubtmCurrentTransition = window.getComputedStyle(menubtm).transition;
                        const filtreCurrentTransition = window.getComputedStyle(filtre).transition;
                        
                        if (!menubtmCurrentTransition.includes('background-color')) {
                            menubtm.style.transition = menubtmCurrentTransition 
                                ? `${menubtmCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        if (!filtreCurrentTransition.includes('background-color')) {
                            filtre.style.transition = filtreCurrentTransition 
                                ? `${filtreCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        menubtm.style.backgroundColor = `${data.colorbkg}9c`;
                        filtre.style.backgroundColor = `${data.colorbkg}9c`;
                        
                        document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                        const styleSheet = document.createElement('style');
                        styleSheet.id = styleId;
                        styleSheet.classList.add('menu-color-style');
                        
                        const rgb = data.colorbkg.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                        let textColor = '#000000';
                        if (rgb) {
                            const r = parseInt(rgb[1], 16);
                            const g = parseInt(rgb[2], 16);
                            const b = parseInt(rgb[3], 16);
                            const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                            textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                        }
                        
                        styleSheet.textContent = `
                            #menubtm * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }

                            #filtre * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }
                        `;
                        
                        document.head.appendChild(styleSheet);
                        
                        lastActiveMarkerId = null;
                        lastActiveColor = null;
                        
                        if (marker.styleId) {
                            const oldStyle = document.getElementById(marker.styleId);
                            if (oldStyle) {
                                setTimeout(() => {
                                    oldStyle.remove();
                                }, 500);
                            }
                        }
                    }
                }
            }, 50); 
        } catch (error) {
            return false;
        }
    }
});
    return marker;
}

function animateMarker(marker, newPosition) {
    const startLatLng = marker.getLatLng();
    const endLatLng = L.latLng(newPosition[0], newPosition[1]);
    const duration = 1000; 
    const startTime = performance.now();

    if (marker.animationFrame) {
        cancelAnimationFrame(marker.animationFrame);
    }

    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function animate(time) {
        const elapsed = time - startTime;
        const linearProgress = Math.min(elapsed / duration, 1);
        
        const easedProgress = easeInOutQuad(linearProgress);
        
        const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * easedProgress;
        const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * easedProgress;
        
        marker.setLatLng([lat, lng]);

        if (linearProgress < 1) {
            marker.animationFrame = requestAnimationFrame(animate);
        }
    }

    marker.animationFrame = requestAnimationFrame(animate);
}

let busStopLayers = [];

async function loadGeoJsonLines() {
    const response = await fetch('proxy-cors/proxy_geojson.php');
    const geoJsonData = await response.json();

    const busLines = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry.type === 'LineString';
        },
        style: function(feature) {
            return {
                color: lineColors[feature.properties.route_id] || '#3388ff',
                weight: 6,
                opacity: 0.7,  
                lineJoin: 'round',
                lineCap: 'round',
                className: 'bus-line', 
                dashArray: feature.properties.route_type === '3' ? '5, 5' : null
            };
        },
        onEachFeature: function(feature, layer) {
            
            if (feature.properties && feature.properties.route_id) {
                geoJsonLines.push(layer);
            }
        }
    }).addTo(map);

    const busStops = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry && feature.geometry.type === 'Point';
        },
        pointToLayer: function(feature, latlng) {
            return L.circleMarker(latlng, {
                radius: 3,
                fillColor: '#ffffff',
                color: '#000000',
                weight: 0.5,
                opacity: 0.7,
                fillOpacity: 0.6
            });
        }
    }).addTo(map);
    
    busStops.eachLayer(function(layer) {
        if (layer.feature && layer.feature.properties) {
            layer.busLine = layer.feature.properties.route_id || null;
            busStopLayers.push(layer);
        }
    });
    
    addAnimationStyles();
}

function addAnimationStyles() {
    if (!document.getElementById('bus-line-styles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'bus-line-styles';
        styleEl.textContent = `
            .bus-line {
                transition: opacity 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), stroke-width 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
            }
            
            .line-hover {
                opacity: 1 !important;
                stroke-width: 6px;
                filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.5));
                animation: linePulse 1.5s infinite;
            }
            
            @keyframes linePulse {
                0% { stroke-opacity: 0.7; }
                50% { stroke-opacity: 1; }
                100% { stroke-opacity: 0.7; }
            }
        `;
        document.head.appendChild(styleEl);
    }
}


let selectedLines = [];

function filterByLine(lineId) {
  const lineIndex = selectedLines.indexOf(lineId);

  if (lineIndex !== -1) {
    selectedLines.splice(lineIndex, 1);
  } else {
    selectedLines.push(lineId);
  }

  updateLinesDisplay();

  if (selectedLines.length === 0) {
    const filtre = document.getElementById('filtre');
    filtre.classList.add('slide-upc');
    filtre.classList.remove('slide-downc');
    resetMapView();
  } else if (selectedLines.length === 1) {
    zoomToSelectedLine(selectedLines[0]);
  } else if (selectedLines.length > 1) {
    zoomToMultipleLines(selectedLines);
  }
}

function zoomToSelectedLine(lineId) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (layer.feature.properties.route_id === lineId) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [10, 10], 
      maxZoom: 17        
    });
  }
}

function zoomToMultipleLines(lineIds) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (lineIds.includes(layer.feature.properties.route_id)) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [50, 50], 
      maxZoom: 15       
    });
  }
}

function updateLinesDisplay() {
  geoJsonLines.forEach(layer => {
    const routeId = layer.feature.properties.route_id;

    if (selectedLines.length === 0 || selectedLines.includes(routeId)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  busStopLayers.forEach(layer => {
    const busLine = layer.busLine;
    
    if (selectedLines.length === 0 || selectedLines.includes(busLine)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  Object.entries(markers).forEach(([id, marker]) => {
    if (selectedLines.length === 0 || selectedLines.includes(marker.line)) {
      if (!map.hasLayer(marker)) {
        map.addLayer(marker);
      }
    } else {
      if (map.hasLayer(marker)) {
        if (marker.isPopupOpen()) {
          marker.closePopup();
        }
        map.removeLayer(marker);
      }
    }
  });
}

function resetMapView() {
    selectedLines = [];

    selectedLine = null;

    geoJsonLines.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    busStopLayers.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    Object.values(markers).forEach(marker => {
        if (!map.hasLayer(marker)) {
            map.addLayer(marker);
        }
    });
}

function showPopup() {
    const popup2 = document.getElementById('popup2');

    popup2.style.display = 'block';
    

    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });



}

function closePopup() {
    const popup2 = document.getElementById('popup2');
    popup2.style.display = 'none';
    const menubottom1 = document.getElementById('menubtm');
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            menu.addEventListener('transitionend', function onTransitionEnd(event) {
                if (event.target === menu) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);


}



const filtre = document.getElementById('filtre');
        filtre.onclick = () => {
            if (selectedLine) {
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        resetMapView();
        }
};










async function loadVehicleModels() {
    try {
        const response = await fetch('setvar/vehicules/index.php');
        const fileList = await response.json();
        
        for (const file of fileList) {
            if (file.endsWith('.txt')) {
                await loadVehicleModelFile(file);
            }
        }
        
    } catch (error) {
        console.error('Erreur lors du chargement des modèles de véhicules ', error);
        toastBottomRight.error('Erreur lors du chargement des modèles de véhicules ', error);
    }
}

async function loadVehicleModelFile(fileName) {
    try {
        const response = await fetch(`setvar/vehicules/${fileName}`);
        const content = await response.text();
        const lines = content.split('\n').map(line => line.trim()).filter(line => line !== '');
        
        if (lines.length < 8) {
            console.error(`Format invalide pour le fichier ${fileName}`);
            toastBottomRight.error(`Format invalide pour le fichier ${fileName}`);
            return;
        }
        
        const modelName = lines[0];
        const thumbnailPath = lines[1];
        
        const params = {
            isElectric: parseParamValue(lines[2]),       
            isHybrid: parseParamValue(lines[3]),       
            isGnv: parseParamValue(lines[4]),     
            isUsbPlugs: parseParamValue(lines[5]),  
            isAirConditioned: parseParamValue(lines[6]), 
            isHeatingUnit: parseParamValue(lines[7])
        };
        
        const vehicleIds = lines.slice(8);
        
        const modelKey = fileName.replace('.txt', '');
        
        vehicleModels[modelKey] = {
            name: modelName,
            thumbnail: thumbnailPath,
            params: params,
            vehicles: new Set(vehicleIds)
        };
        
        vehicleIds.forEach(id => {
            if (params.isElectric) vehicleTypes['elec'].add(id);
            if (params.isHybrid) vehicleTypes['hybrid'].add(id);
            if (params.isGnv) vehicleTypes['gnv'].add(id);
            if (params.isUsbPlugs) vehicleTypes['usb'].add(id);
            if (params.isAirConditioned || params.isHeatingUnit) vehicleTypes['clim'].add(id);
        });
        
    } catch (error) {
        console.error(`Erreur lors du chargement du fichier ${fileName}:`, error);
        toastBottomRight.error('Une erreur est survenue.');

    }
}

function parseParamValue(paramLine) {
    const parts = paramLine.split('=');
    if (parts.length !== 2) return false;
    
    return parts[1].toLowerCase() === 'true';
}

function getVehicleModel(parkNumber) {
    const parkId = String(parkNumber);    
    for (const [modelKey, model] of Object.entries(vehicleModels)) {
        if (model.vehicles.has(parkId)) {
            return model;
        }
    }
    return null;
}

function getVehicleOptionsBadges(parkNumber) {
    const model = getVehicleModel(parkNumber);
    let badges = '';
    
    if (model) {
        const params = model.params;
        
        if (params.isElectric) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;">
                <img src="src/elec.png" alt="Électrique" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isHybrid) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;"">
                <img src="src/hyb.png" alt="Hybride" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isGnv) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;">
                <img src="src/gnv.png" alt="Gaz Naturel" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isUsbPlugs) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;">⚡ USB</span> `;
        }
        if (params.isAirConditioned) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;">❄️ Climatisé</span> `;
        }
        if (params.isHeatingUnit) {
            badges += `<span style="padding: 6px 10px; background: #00000077; font-weight: normal; white-space: nowrap; -webkit-backdrop-filter: blur(8px); border-radius: 10px;">🌡️ Chauffé</span> `;
        }
    } 
    
    return badges;
}

function getVehicleBrandHtml(parkNumber) {
    const model = getVehicleModel(parkNumber);
    const defaultImagePath = "src/generic.png";
    
    if (model) {
        return `
            <div class="vehicle-model">

                <img src="${model.thumbnail}" 
                     onerror="this.onerror=null; this.src='${defaultImagePath}';" 
                     alt="Thumbnail ${model.name}" 
                     class="vehicle-thumbnail"  />

                <span style="margin-top: 6px; margin-left: 20px; font-size: 12px; ">Un ${model.name}</span>
            </div>
        `;
    }

    return `
        <div class="vehicle-model">
            <img src="${defaultImagePath}" 
                 alt="Bus par défaut" 
                 class="vehicle-thumbnail"  />
            <span style="margin-top: 6px; margin-left: 20px; font-size: 12px;">Un bus</span>
        </div>
    `;
}


async function initializeApp() {
    try {
        
        for (const key in vehicleTypes) {
            vehicleTypes[key] = new Set();
        }
        
        await loadVehicleModels();
        
        await fetchVehiclePositions();
    } catch (error) {
        console.error('BECAB Launcher : erreur lors de l\'initialisation :', error);
        toastBottomRight.error('BECAB Launcher : erreur lors de l\'initialisation :', error);

    }
}



let gtfsInitialized = false;

async function fetchVehiclePositions() {

    if (!gtfsInitialized) {
        console.log("fetchVehiclePositions: GTFS pas encore initialisé, attente...");
        return; 
    }
        if (!window.timeAnimationStyleAdded) {
        const timeAnimationStyle = `
        <style id="time-animation-styles">
            .time-display {
                transition: opacity 0.3s ease-out;
            }
            
            .time-display.fade-out {
                opacity: 0;
            }
            
            @keyframes radiateWaves {
                0% { transform: scale(0.7); opacity: 0.5; }
                50% { transform: scale(1.2); opacity: 1; }
                100% { transform: scale(1); opacity: 0.7; }
            }
            
            .time-indicator .rss-waves {
                transform-origin: 5px 19px; 
            }
            
            .time-indicator.animate .rss-waves {
                animation: radiateWaves 0.6s ease-out;
            }
            
            @keyframes scrollText {
                0% { transform: translateX(0); }
                10% { transform: translateX(0); }
                60% { transform: translateX(calc(-100% + 70px)); }
                90% { transform: translateX(calc(-100% + 70px)); }
                100% { transform: translateX(0); }
            }
            
            .stop-name-container:hover .stop-name-wrapper[style*="animation"] {
                animation-play-state: running !important;
            }
        </style>
        `;
        document.head.insertAdjacentHTML('beforeend', timeAnimationStyle);
        window.timeAnimationStyleAdded = true;
    }
    try {
        const response = await fetch('proxy-cors/proxy_vehpos.php');
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);

        const activeVehicleIds = new Set();

                const tempElement = document.createElement('div');
        tempElement.style.font = getComputedStyle(document.body).font;
        tempElement.style.visibility = 'hidden';
        tempElement.style.position = 'absolute';
        tempElement.style.whiteSpace = 'nowrap';
        document.body.appendChild(tempElement);
        


            data.entity.forEach(entity => {
                const vehicle = entity.vehicle;
                if (vehicle) {

                const id = vehicle.vehicle.id;
                const vehicleOptionsBadges = getVehicleOptionsBadges(id);
                const vehicleBrandHtml = getVehicleBrandHtml(id);
                const line = vehicle.trip && vehicle.trip.routeId ? vehicle.trip.routeId : 'Inconnu';
                const directionId = vehicle.trip ? vehicle.trip.directionId : undefined;
                activeVehicleIds.add(id);

                const statusMap = {
                    0: '❌ Hors service commercial',
                    1: ' En service - Portes ouvertes',
                    2: ' En service'
                };
                const status = statusMap[vehicle.currentStatus] || 'Inconnu';

                const stopIdun = vehicle.stopId || 'Inconnu';
                let stopId = stopIdun.replace("0:", "");
                const latitude = vehicle.position.latitude;
                const longitude = vehicle.position.longitude;

                if (isNaN(latitude) || isNaN(longitude)) {
                    return; 
                }

                const speed = vehicle.position.speed ? (vehicle.position.speed).toFixed(0) + ' km/h' : 'Arrêté';
                const bearing = vehicle.position.bearing || 'Inconnu';
                const tripId = vehicle.trip && vehicle.trip.tripId ? vehicle.trip.tripId : 'Inconnu';

                const lastStopId = tripUpdates[tripId] ? tripUpdates[tripId].lastStopId : 'Inconnu';
                const lastStopNameun = stopNameMap[lastStopId] || 'Destination inconnue';
                let lastStopName = lastStopNameun.replace("0:", "");
                
                const nextStops = tripUpdates[tripId]?.nextStops || [];
                let currentStopIndex = nextStops.findIndex(stop => stop.stopId.replace("0:", "") === stopId.replace("0:", ""));
                const now = Math.floor(Date.now() / 1000);

                let filteredStops = [];
                if (currentStopIndex !== -1) {
                    filteredStops = nextStops.slice(currentStopIndex).filter(stop => {
                        return stop.delay === null || stop.delay >= -60;
                    });
                } else {
                    filteredStops = nextStops.filter(stop => stop.delay === null || stop.delay > 0);
                }

                let stopsHeaderText = "Chargement en cours";
                if (currentStopIndex !== -1 && filteredStops.length > 0) {
                    const firstStopDelay = filteredStops[0].delay || 0;
                    const minutes = Math.max(0, Math.ceil(firstStopDelay / 60));
                    
                    stopsHeaderText = "Prochains arrêts";
                    
                    if (filteredStops.length === 1) {
                        stopsHeaderText = minutes === 0 ? "Départ imminent" : `Départ dans ${minutes} min`;
                    } else if (minutes > 3) {
                        stopsHeaderText = `Départ dans ${minutes} minutes`;
                    }
                }
                
                let stopsListHTML = '';
                if (filteredStops.length > 0) {
                    stopsListHTML = filteredStops.map(stop => {
                        const timeLeft = stop.delay;
                        const timeLeftText = timeLeft !== null 
                            ? timeLeft <= 0 ? 'imminent' : `${Math.ceil(timeLeft / 60)} min`
                            : '';
                        
                        const stopName = stopNameMap[stop.stopId] || stop.stopId;
                        
                        tempElement.textContent = stopName;
                        
                        return `
                        <li style="list-style: none; padding: 0px; display: flex; justify-content: space-between;">
                            <div class="stop-name-container" style="position: relative; overflow: hidden; max-width: 70%; white-space: nowrap;">
                                <div class="stop-name-wrapper" style="position: relative; display: inline-block; padding-right: 10px;">
                                    <div class="stop-name" style="position: relative; display: inline-block;">${stopName}</div>
                                </div>
                            </div>
                            <div class="time-container" style="position: relative; min-height: 1.2em; text-align: right;">
                                <div class="time-display" 
                                    data-time-left="${timeLeftText}" 
                                    data-departure-time="${stop.departureTime || stop.arrivalTime || "Inconnu"}">
                                    ${timeLeftText}
                                </div>
                                <svg class="time-indicator" xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <g class="rss-waves">
                                        <path class="rss-arc-large" d="M4 4a16 16 0 0 1 16 16"></path>
                                        <path class="rss-arc-small" d="M4 11a9 9 0 0 1 9 9"></path>
                                    </g>
                                    <circle class="rss-dot" cx="5" cy="19" r="1"></circle>
                                </svg>
                            </div>
                        </li>`;
                    }).join('');
                }

                const nextStopsHTML = `
                    <div style="position: relative; max-height: 120px;">
                        <ul style="padding: 0; margin: 0; list-style-type: none; max-height: 120px;">
                            ${stopsListHTML}
                        </ul>
                    </div>
                `;

                if (!window.toggleTimeDisplay) {
                    window.isAnimating = false;
                    window.showTimeLeft = true;
                    
                    window.toggleTimeDisplay = function() {
                        if (window.isAnimating) return;
                        
                        window.isAnimating = true;
                        
                        const timeDisplays = document.querySelectorAll('.time-display');
                        const indicators = document.querySelectorAll('.time-indicator');
                        
                        timeDisplays.forEach(display => {
                            display.classList.add('fade-out');
                        });
                        
                        indicators.forEach(indicator => {
                            indicator.classList.add('animate');
                            
                            setTimeout(() => {
                                indicator.classList.remove('animate');
                            }, 600);
                        });
                        
                        setTimeout(() => {
                            window.showTimeLeft = !window.showTimeLeft;
                            
                            timeDisplays.forEach(display => {
                                const timeLeft = display.getAttribute('data-time-left');
                                const departureTime = display.getAttribute('data-departure-time');
                                display.textContent = window.showTimeLeft ? timeLeft : departureTime;
                            });
                            
                            timeDisplays.forEach(display => {
                                display.classList.remove('fade-out');
                            });
                            
                            setTimeout(() => {
                                window.isAnimating = false;
                            }, 350);
                        }, 350);
                    };

                    if (window.timeToggleInterval) {
                        clearInterval(window.timeToggleInterval);
                    }
                    window.timeToggleInterval = setInterval(window.toggleTimeDisplay, 4000);
                }

                const delayInfo = tripUpdates[tripId] ? tripUpdates[tripId].stopUpdates.find(update => update.stopId === stopId) : null;

                const arrivalDelay = delayInfo ? delayInfo.arrivalDelay : 0; 
                const scheduledArrival = delayInfo ? delayInfo.scheduledArrival : null; 

                                
                function getTextColorForBackground(bgColor) {
                    const color = bgColor.replace('#', '');
                    const r = parseInt(color.substring(0, 2), 16);
                    const g = parseInt(color.substring(2, 4), 16);
                    const b = parseInt(color.substring(4, 6), 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    return brightness > 150 ? '#000000' : '#FFFFFF';
                }

                const backgroundColor = lineColors[line] || '#000000';
                const textColor = getTextColorForBackground(backgroundColor);

                let arrivalTime = 'Inconnu';
                if (scheduledArrival) {
                    const arrivalDate = new Date(scheduledArrival * 1000);
                    arrivalTime = arrivalDate.toLocaleTimeString();
                }

                let delayMessage = 'À l\'heure';
                if (arrivalDelay > 0) {
                    delayMessage = `En retard de ${arrivalDelay} secondes`;
                } else if (arrivalDelay < 0) {
                    delayMessage = `En avance de ${Math.abs(arrivalDelay)} secondes`;
                }

                let remainingTimeMessage = 'terminus arrivée.';
                if (nextStops.length > 1) {
                    const penultimateStop = nextStops[nextStops.length - 2]; // avant der arrêt
                    const scheduledArrivalPenultimate = penultimateStop.departureTime;

                    if (scheduledArrivalPenultimate && scheduledArrivalPenultimate.includes(":")) {
                        const [hours, minutes] = scheduledArrivalPenultimate.split(':').map(num => parseInt(num, 10));

                        const now = new Date();
                        const scheduledArrivalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);

                        const currentTime = new Date();
                        const timeRemaining = Math.max(scheduledArrivalDate - currentTime, 0);
                        const minutesRemaining = Math.floor(timeRemaining / 60000);
                        const secondsRemaining = Math.floor((timeRemaining % 60000) / 1000);

                        remainingTimeMessage = ` ${minutesRemaining} minutes.`;
                    } else {
                        remainingTimeMessage = ' délai inconnu';
                    }
                }
                
                const popupContent = `
                    <div style="position: relative; font-family: 'League Spartan', sans-serif; font-size: 14px; color: #333; border-radius: 15px; box-shadow: 0px 0px 20px 4px ${backgroundColor}9c; overflow: hidden; background-color: ${backgroundColor}9c; color: ${textColor}; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">
                        
                <div style="position: relative; padding: 10px; color: ${textColor}; text-align: center; overflow: hidden; display: flex; justify-content: space-between; align-items: center; box-shadow: 0px 4px 20px 5px rgba(0, 0, 0, 0.3); border-radius: 11px; margin: 7px; ">
                    <!-- Texte principal -->
                    <div style="z-index: 2; text-align: left; width: 100%;">
                        <p style="margin: 0; font-size: 24px; ">Ligne ${lineName[line] || "hors service commercial"}</p>
                        <strong style="margin: 0; font-size: 14px;">➜ ${lastStopName}</strong>
                <div>
                    <div style="position: relative; display: flex; align-items: center; ">
                        <div style="
                            position: relative;
                            flex: 1;
                            overflow: hidden;
                            border-radius: 10px;
                        ">
                            <!-- Contenu défilant horizontalement -->
                            <div class="options" style="
                                display: flex;
                                gap: 10px;
                                padding: 0px;
                                overflow-x: auto; 
                                white-space: nowrap;
                                scrollbar-width: thin; 
                                scrollbar-color: #888 #f1f1f1;
                                color: #ffffff;
                            " class="custom-scrollbar">
                                <!-- Numéro de parc -->
                                <span style="
                                    background: #00000077;
                                    color: #ffffff;
                                    padding: 6px 12px;
                                    border-radius: 10px;
                                    font-weight: normal;
                                    font-size: 14px;
                                    white-space: nowrap;
                                    -webkit-backdrop-filter: blur(8px); 
                                ">
                                    Véhicule ${vehicle.vehicle.label}
                                </span>
                                
                                <!-- Badges des options du véhicule -->
                                ${vehicleOptionsBadges}
                            </div>
                        </div>
                    </div>
                </div>
            </div>


                    <!-- Texte en arrière-plan -->
                    <div style="
                        position: absolute;
                        right: 10px;
                        top: 0;
                        bottom: 0;
                        z-index: 1;
                        opacity: 0.1;
                        font-size: 100px;
                        color: ${textColor};
                        display: flex;
                        align-items: center;
                        justify-content: flex-end;
                        white-space: nowrap;
                    ">
                        Ligne ${lineName[line] || "🚌🚍🚌🚍🚌🚍🚌"}
                    </div>
                </div>

                <div style="margin-right: 10px; margin-top: 10px; text-align: right;">
                ${vehicleBrandHtml}
                </div>



                <div style="padding-top: 10px; padding-left: 10px; padding-right: 10px; color: ${textColor};">
                <p style="margin: 0; font-size: 18px; text-align: right;">${stopsHeaderText}</p>
                    <ul>
                    <div id="nextStopsContent" class="next-stops-content">
                          ${nextStopsHTML}
                    </div>   
                </div>
                </div>
                `;
                
                if (markers[id]) {
        animateMarker(markers[id], [latitude, longitude]);
        
        if (!markers[id].id) {
            markers[id].id = id;
        }
        
        if (markers[id].line !== line) {
            const oldLine = markers[id].line;
            markers[id].line = line;
            
            const color = lineColors[line] || '#000000';
            if (markers[id]._icon) {
                const markerIcon = markers[id]._icon.querySelector('.marker-icon');
                if (markerIcon) {
                    markerIcon.style.transition = 'background-color 0.5s ease';
                    markerIcon.style.backgroundColor = color;
                }
                
                const arrowElement = markers[id]._icon.querySelector('.marker-arrow-path');
                if (arrowElement) {
                    arrowElement.style.transition = 'stroke 0.5s ease';
                    arrowElement.setAttribute('stroke', color);
                }
            }
            
            if (markers[id].isPopupOpen()) {
                const menubtm = document.getElementById('menubtm');
                const filtre = document.getElementById('filtre');
                if (menubtm) {
                    lastActiveColor = color;
                    
                    menubtm.style.backgroundColor = `${color}9c`;
                    filtre.style.backgroundColor = `${color}9c`;

                    
                    const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                    let textColor = '#FFFFFF';
                    if (rgb) {
                        const r = parseInt(rgb[1], 16);
                        const g = parseInt(rgb[2], 16);
                        const b = parseInt(rgb[3], 16);
                        const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                        textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                    }
                    
                    const styleId = `popup-style-${Math.random().toString(36).substr(2, 9)}`;
                    const styleSheet = document.createElement('style');
                    styleSheet.id = styleId;
                    styleSheet.classList.add('menu-color-style');
                    
                    styleSheet.textContent = `
                        #menubtm * {
                            color: ${textColor};
                            transition: color 0.5s ease;
                        }

                        #filtre * {
                            color: ${textColor};
                            transition: color 0.5s ease;
                        }
                    `;
                    
                    document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                    document.head.appendChild(styleSheet);
                    markers[id].styleId = styleId;
                }
            }
        }
        
        if (markers[id]._icon) {
            const arrowElement = markers[id]._icon.querySelector('.marker-arrow');
            
            if (arrowElement) {
                const targetRotation = bearing - 90;
                arrowElement.style.transition = 'transform 0.5s ease';
                arrowElement.style.transform = `rotate(${targetRotation}deg)`;
                arrowElement._currentRotation = targetRotation;
            }
        }

        updateLinesDisplay();

        const existingPopup = markers[id].getPopup();
        const currentContent = existingPopup ? existingPopup.getContent() : '';

        if (existingPopup && currentContent === popupContent) {
            return;
        }

        markers[id].setPopupContent(popupContent);

        if (markers[id].isPopupOpen()) {
            const popup = markers[id]._popup;
            if (popup && popup._contentNode) {
                const popupElement = popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('hide'); 
                    popupElement.classList.add('show'); 
                    markers[id].openPopup();
                }
            }
        }

        if (selectedLine && markers[id].line !== selectedLine) {
            if (map.hasLayer(markers[id])) {
                map.removeLayer(markers[id]);
            }
        } else {
            if (!map.hasLayer(markers[id])) {
                map.addLayer(markers[id]);
            }
        }
    } else {
        const marker = createColoredMarker(latitude, longitude, line, bearing);
        updateLinesDisplay();
        markers[id] = marker;
        markers[id].line = line;
        markers[id].id = id;

        if (!selectedLine || selectedLine === line) {
            marker.addTo(map);
        }
        
        marker.bindPopup(popupContent);

        marker.on('popupopen', function (e) {
            if (e.popup && e.popup._contentNode) {
                const popupElement = e.popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('hide'); 
                    popupElement.classList.add('show');  
                }
            }
        });

        marker.on('popupclose', function (e) {
            if (e.popup && e.popup._contentNode) {
                const popupElement = e.popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('show');
                    popupElement.classList.add('hide');

                    setTimeout(() => {
                        if (e.popup) {
                            e.popup.remove(); 
                        }
                    }, 200); 
                }
            }
        });
    }}
});

                Object.keys(markers).forEach(id => {
            if (!activeVehicleIds.has(id)) {
                map.removeLayer(markers[id]); 
                delete markers[id]; 
            }
        });

				
        let isMenuVisible = true;

const favoriteLines = new Set(JSON.parse(localStorage.getItem('favoriteLines') || '[]'));

const ANIMATION_CONFIG = {
    DURATION: 400,
    POP_DURATION: 100,
    SPRING_TIMING: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    SCALE_UP: 1.03,
    ITEM_MARGIN: 10
};


let isAnimating = false;

function getAbsolutePositions(menu) {
    const sections = Array.from(menu.querySelectorAll('.linesection'));
    const positions = new Map();
    let accumulatedHeight = 0;
    
    sections.forEach(section => {
        const rect = section.getBoundingClientRect();
        positions.set(section, {
            top: accumulatedHeight,
            height: rect.height,
            index: sections.indexOf(section)
        });
        accumulatedHeight += rect.height + ANIMATION_CONFIG.ITEM_MARGIN;
    });
    
    return { sections, positions };
}

function getTargetIndex(sections, movingSection, isFavorite, favoriteLines) {
    const movingLine = movingSection.dataset.line;
    
    if (isFavorite) {
        const firstNonFavoriteIndex = sections.findIndex(section => 
            !favoriteLines.has(section.dataset.line)
        );
        
        if (firstNonFavoriteIndex === sections.indexOf(movingSection)) {
            return -1;
        }
        
        return firstNonFavoriteIndex === -1 ? sections.length : firstNonFavoriteIndex;
    } else {
        let targetIndex = 0; 
        
        for (let i = 0; i < sections.length; i++) {
            const sectionLine = sections[i].dataset.line;
            
            if (favoriteLines.has(sectionLine)) {
                const movingNum = parseInt(movingLine);
                const sectionNum = parseInt(sectionLine);
                
                if (!isNaN(movingNum) && !isNaN(sectionNum)) {
                    if (movingNum < sectionNum) {
                        return i;
                    }
                } else if (movingLine.localeCompare(sectionLine) < 0) {
                    return i;
                }
            } else {
                return i; 
            }
        }
        
        return sections.length;
    }
}

function prepareSectionsForAnimation(sections) {
    sections.forEach(section => {
        section.style.transition = 'none';
        section.style.position = 'relative';
        section.style.zIndex = '1';
        section.style.transform = 'translateY(0)';
    });
    
    // Force reflow
    sections[0].offsetHeight;
}

async function animateFavoriteTransition(button, lineSection, line, isFavorite) {
    if (isAnimating) return;
    isAnimating = true;
    
    const menu = document.getElementById('menu');
    if (!menu || !lineSection) return;
    
    try {
        menu.style.pointerEvents = 'none';
        button.style.pointerEvents = 'none';
        
        const { sections, positions } = getAbsolutePositions(menu);
        const currentIndex = sections.indexOf(lineSection);
        
        if (isFavorite) {
            favoriteLines.delete(line);
        } else {
            favoriteLines.add(line);
        }
        
        const targetIndex = getTargetIndex(sections, lineSection, isFavorite, favoriteLines);
        
        if (targetIndex === -1 || currentIndex === -1 || targetIndex === currentIndex) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            try {
                localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
            } catch (error) {
                console.error('Error saving favorite', error);
            }
            await cleanup(menu, button);
            return;
        }
        
        if (isFavorite) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            button.innerHTML = '☆';
        } else {
            await animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
        }
        
        try {
            localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
        } catch (error) {
            console.error('Error saving favorite', error);
        }
        
    } catch (error) {
        console.error('Animation err', error);
    } finally {
        await cleanup(menu, button);
    }
}

async function animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    for (let i = 0; i < targetIndex; i++) {
        if (i !== currentIndex) {
            const section = sections[i];
            const sectionPos = positions.get(section);
            targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = 0;
            
            if (currentIndex < targetIndex) {
                if (index > currentIndex && index <= targetIndex) {
                    displacement = -(currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
                }
            } else {
                if (index >= targetIndex && index < currentIndex) {
                    displacement = currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
                }
            }
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    lineSection.style.transform = `scale(1.05)`;
    await new Promise(r => setTimeout(r, 100));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1.05)`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1)`;
    
    button.innerHTML = '★';
    button.style.transform = 'scale(1.2)';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

async function animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    if (targetIndex === -1) {
        targetIndex = sections.length;
        sections.forEach((section, idx) => {
            if (idx !== currentIndex) {
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        });
    } else {
        for (let i = 0; i < targetIndex; i++) {
            if (i !== currentIndex) {
                const section = sections[i];
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = calculateDisplacement(index, currentIndex, targetIndex, 
                currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    await animateMovingSection(lineSection, deltaY);
    
    button.style.transform = 'scale(0.8)';
    button.innerHTML = '☆';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

function calculateDisplacement(index, currentIndex, targetIndex, sectionHeight) {
    if (targetIndex === -1) {
        return index > currentIndex ? -sectionHeight : 0;
    }
    
    if (currentIndex < targetIndex) {
        return (index > currentIndex && index <= targetIndex) ? -sectionHeight : 0;
    } else {
        return (index >= targetIndex && index < currentIndex) ? sectionHeight : 0;
    }
}

async function animateMovingSection(section, deltaY) {
    section.style.transform = `scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.POP_DURATION));
    
    section.style.transform = `translateY(${deltaY}px) scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    
    section.style.transform = `translateY(${deltaY}px) scale(1)`;
}


function updateFavoriteState(button, line, isFavorite) {
    if (isFavorite) {
        favoriteLines.delete(line);
        button.innerHTML = '☆';
    } else {
        favoriteLines.add(line);
        button.innerHTML = '★';
    }
    
    try {
        localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
    } catch (error) {
        console.error('Error saving favorite', error);
    }
}



async function cleanup(menu, button) {
    await new Promise(r => setTimeout(r, 50));
    
    const sections = menu.querySelectorAll('.linesection');
    sections.forEach(section => {
        section.style.transform = '';
        section.style.transition = '';
        section.style.zIndex = '';
        section.style.position = '';
    });
    
    menu.style.pointerEvents = 'auto';
    button.style.pointerEvents = 'auto';
    
    updateMenu();
    isAnimating = false;
}

const animationStyle = document.createElement('style');
animationStyle.textContent = `
    .linesection {
        transition: transform 0.2s  cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
    }
    
    .linesection.removing {
        animation: remove-favorite 0.3s ease-out forwards;
    }
    
    @keyframes remove-favorite {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .favorite-button {
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
    
    .favorite-button:hover {
        transform: scale(1.1);
    }
    
    .favorite-button:active {
        transform: scale(0.9);
    }
`;
document.head.appendChild(animationStyle);


function updateMenu() {
    const menu = document.getElementById('menu');
    menu.innerHTML = '';

    const logoContainer = document.createElement('div');
    logoContainer.style.textAlign = 'center';
    logoContainer.style.marginBottom = '7px';

    const logo = document.createElement('img');
    logo.src = 'src/whitelogo.png'; 
    logo.alt = 'Logo de My Bus Finder';
    logo.style.maxWidth = '200px';
    logo.style.display = 'block';
    logo.style.margin = '0 auto';
    logo.style.cursor = 'pointer';
    logo.onclick = () => {
        showUpdatePopup('https://mybusfinder.fr/updatecm/updatecm.html');
        musique();
    };

    logoContainer.appendChild(logo);
    menu.appendChild(logoContainer);

    const now = new Date();
    const currentHour = now.getHours();
    const currentMinutes = now.getMinutes();
    const totalMinutes = currentHour * 60 + currentMinutes;

    let transportState = "normal";
    if ((totalMinutes >= 420 && totalMinutes <= 510) || (totalMinutes >= 960 && totalMinutes <= 1050)) {
        transportState = "presque saturé"; 
    } else if ((totalMinutes > 510 && totalMinutes <= 570) || (totalMinutes > 1020 && totalMinutes <= 1110)) {
        transportState = "saturé";
    }

    const transportStateContainer = document.createElement('div');
    transportStateContainer.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 8px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        cursor: pointer;
    `;

    const transportImage = document.createElement('img');
    transportImage.alt = 'Affluence transports';
    transportImage.style.width = '50px';
    transportImage.style.height = '36px';
    transportImage.style.marginRight = '10px';

    if (transportState === "normal") {
        transportImage.src = 'src/1of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.success('Ouf ! Aucune affluence notable. Bon voyage !');
        };
    } else if (transportState === "presque saturé") {
        transportImage.src = 'src/2of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.warning('Affluence modérée. Les transports se remplissent.');
        };
    } else if (transportState === "saturé") {
        transportImage.src = 'src/3of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.error('Forte affluence. Privilégiez les lignes secondaires.');
        };
    }

    const transportStateTextContainer = document.createElement('div');
    transportStateTextContainer.style.textAlign = 'left';

    transportStateContainer.onmouseover = () => {
        transportStateContainer.style.transform = 'scale(0.98,0.98)';
        transportStateContainer.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
    };
    transportStateContainer.onmouseout = () => {
        transportStateContainer.style.transform = 'scale(1,1)';
        transportStateContainer.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
    };

    const transportStateLabel = document.createElement('div');
    transportStateLabel.textContent = "Affluence transports";
    transportStateLabel.style.fontSize = '14px';
    transportStateLabel.style.marginTop = '7px';
    transportStateLabel.style.color = '#fff';

    const transportStateText = document.createElement('div');
    transportStateText.textContent = transportState.charAt(0).toUpperCase() + transportState.slice(1);
    transportStateText.style.fontSize = '22px';
    transportStateText.style.fontWeight = 'normal';
    transportStateText.style.color = '#fff';

    transportStateTextContainer.appendChild(transportStateLabel);
    transportStateTextContainer.appendChild(transportStateText);

    transportStateContainer.appendChild(transportImage);
    transportStateContainer.appendChild(transportStateTextContainer);
    menu.appendChild(transportStateContainer);

    const locationButton = document.createElement('div');
    locationButton.className = 'alerts-button';
    locationButton.onclick = () => {
        locateUser();
        const menubottom1 = document.getElementById('menubtm');
        const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            menu.addEventListener('transitionend', function onTransitionEnd(event) {
                if (event.target === menu) { 
                    menu.style.display = 'none';
                }
            });
        isMenuVisible = false;
        menubottom1.style.display = 'flex';
        setTimeout(() => {
            menubottom1.classList.remove('slide-upb');
            menubottom1.classList.add('slide-downb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.remove('slide-upc');
        filtre.classList.add('slide-downc');
        }
        }, 10);
    };

    const locationIcon = document.createElement('div');
    locationIcon.className = 'alerts-icon';
    locationIcon.innerHTML = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;

    const locationContent = document.createElement('div');
    locationContent.className = 'alerts-content';

    const locationTitle = document.createElement('div');
    locationTitle.className = 'alerts-title';
    locationTitle.textContent = 'Ma position';

    const locationDescription = document.createElement('div');
    locationDescription.className = 'alerts-description';
    locationDescription.textContent = 'Me localiser sur la carte';

    locationContent.appendChild(locationTitle);
    locationContent.appendChild(locationDescription);

    locationButton.appendChild(locationIcon);
    locationButton.appendChild(locationContent);
    menu.appendChild(locationButton);






    const satelliteButton = document.createElement('div');
satelliteButton.className = 'alerts-button';

let isStandardView = localStorage.getItem('isStandardView') === 'true';

window.addEventListener('DOMContentLoaded', () => {
    applyMapView();
    
    updateButtonText();
});

satelliteButton.onclick = () => {
    toggleMapView();
};

function toggleMapView() {
    isStandardView = !isStandardView;
    
    localStorage.setItem('isStandardView', isStandardView);

    const menubottom1 = document.getElementById('menubtm');
        const menu = document.getElementById('menu');
        menu.classList.add('hidden');
        menu.addEventListener('transitionend', function onTransitionEnd(event) {
            if (event.target === menu) { 
                menu.style.display = 'none';
            }
        });
        isMenuVisible = false;
        menubottom1.style.display = 'flex';
        setTimeout(() => {
            menubottom1.classList.remove('slide-upb');
            menubottom1.classList.add('slide-downb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.remove('slide-upc');
        filtre.classList.add('slide-downc');
        }
        }, 10);

    
    applyMapView();
    
    updateButtonText();
}

function applyMapView() {
    const currentDate = new Date();
    const latitude = map.getCenter().lat;  
    const longitude = map.getCenter().lng;  

    const sunTimes = SunCalc.getTimes(currentDate, latitude, longitude);
    const sunrise = sunTimes.sunrise;
    const sunset = sunTimes.sunset;

    const isNightMode = currentDate >= sunset || currentDate <= sunrise;

    map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer) {
            map.removeLayer(layer);
        }
    });

    if (!isStandardView) {
    const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(map);
    
    if (isNightMode) {
        const mapPane = map.getPanes().tilePane;
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        const mapPane = map.getPanes().tilePane;
        mapPane.style.filter = 'none';
    }
} else {
    const mapPane = map.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(map);
}
}


function updateButtonText() {
    if (isStandardView) {
        satelliteTitle.textContent = 'Actuellement en vue satellite';
        satelliteDescription.textContent = 'Appuyez ici pour passer à la vue standard';
    } else {
        satelliteTitle.textContent = 'Actuellement en vue standard';
        satelliteDescription.textContent = 'Appuyez ici pour passer à la vue satellite';
    }
}

function getNextStopInfo(vehicleId) {
    const vehicle = markers[vehicleId];
    if (!vehicle) return null;
    
    const currentStopId = vehicle.stopId ? vehicle.stopId.replace("0:", "") : null;
    
    for (const [tripId, tripData] of Object.entries(tripUpdates)) {
        if (!tripData.nextStops || !tripData.nextStops.length) continue;
        
        const currentStopIndex = tripData.nextStops.findIndex(stop => 
            stop.stopId.replace("0:", "") === currentStopId
        );
        
        if (currentStopIndex !== -1 && tripData.nextStops[currentStopIndex + 1]) {
            const nextStop = tripData.nextStops[currentStopIndex + 1];
            return {
                name: stopNameMap[nextStop.stopId] || nextStop.stopId,
                delay: nextStop.delay,
                departureTime: nextStop.departureTime
            };
        }
    }
    return null;
}

const satelliteIcon = document.createElement('div');
satelliteIcon.className = 'alerts-icon';
satelliteIcon.innerHTML = `
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3.6 9l1.5 1.5M9 3.6L10.5 5M21 3l-9 9M18.4 15l1.5 1.5M15 18.4l1.5 1.5M3 21l9-9"/>
        <circle cx="12" cy="12" r="3"/>
        <path d="M14.5 9.5L19 5"/>
        <path d="M5 19l4.5-4.5"/>
    </svg>
`;

const satelliteContent = document.createElement('div');
satelliteContent.className = 'alerts-content';

const satelliteTitle = document.createElement('div');
satelliteTitle.className = 'alerts-title';

const satelliteDescription = document.createElement('div');
satelliteDescription.className = 'alerts-description';

updateButtonText();

satelliteContent.appendChild(satelliteTitle);
satelliteContent.appendChild(satelliteDescription);

satelliteButton.appendChild(satelliteIcon);
satelliteButton.appendChild(satelliteContent);
menu.appendChild(satelliteButton);



const alertsButton = document.createElement('div');
alertsButton.className = 'alerts-button';
alertsButton.onclick = () => showUpdatePopup("histovec.html");

const alertsIcon = document.createElement('div');
alertsIcon.className = 'alerts-icon';
alertsIcon.innerHTML = `
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="6" width="18" height="10" rx="2" />
        <circle cx="7" cy="16" r="2" />
        <circle cx="17" cy="16" r="2" />
        <path d="M3 10h18" />
        <path d="M7 6v4" />
        <path d="M17 6v4" />
    </svg>
`;

const alertsContent = document.createElement('div');
alertsContent.className = 'alerts-content';

const alertsTitle = document.createElement('div');
alertsTitle.className = 'alerts-title';
alertsTitle.textContent = 'Histovec';

const alertsDescription = document.createElement('div');
alertsDescription.className = 'alerts-description';
alertsDescription.textContent = 'Historique d\'affectations des véhicules';

alertsContent.appendChild(alertsTitle);
alertsContent.appendChild(alertsDescription);

alertsButton.appendChild(alertsIcon);
alertsButton.appendChild(alertsContent);
menu.appendChild(alertsButton);

    const busesByLineAndDestination = {};

    Object.keys(markers).forEach(id => {
    const vehicle = markers[id];
    const line = vehicle.line;
    
    let destination = "Inconnue";
    const popupContent = vehicle.getPopup().getContent();
    
    const patterns = [
        /<strong[^>]*>➜\s*(.*?)<\/strong>/,
        />➜\s*(.*?)</,
        /Ligne \d+<\/p>\s*<strong[^>]*>➜\s*(.*?)<\/strong>/
    ];

    for (const pattern of patterns) {
        const match = popupContent.match(pattern);
        if (match && match[1]) {
            destination = match[1].trim();
            if (destination.toLowerCase() !== 'Destination inconnue') {
                break;
            }
        }
    }

    if (!busesByLineAndDestination[line]) {
        busesByLineAndDestination[line] = {};
    }

    if (!busesByLineAndDestination[line][destination]) {
        busesByLineAndDestination[line][destination] = [];
    }

    busesByLineAndDestination[line][destination].push({
        parkNumber: vehicle.id,
        vehicle
    });
});

    const sortedLines = Object.keys(busesByLineAndDestination)
        .sort((a, b) => {
            const aIsFavorite = favoriteLines.has(a);
            const bIsFavorite = favoriteLines.has(b);
            
            if (aIsFavorite && !bIsFavorite) return -1;
            if (!aIsFavorite && bIsFavorite) return 1;
            
            return isNaN(a) ? (isNaN(b) ? a.localeCompare(b) : 1) : (isNaN(b) ? -1 : parseInt(a) - parseInt(b));
        });


function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return { r, g, b };
}


function calculateLuminance(r, g, b) {
    return (r * 0.299 + g * 0.587 + b * 0.114);
}


function getTextColor(backgroundColor) {
    try {
        let hexColor = backgroundColor;
        
        if (!hexColor.startsWith('#')) {
            hexColor = '#' + hexColor;
        }
        
        const { r, g, b } = hexToRgb(hexColor);
        
        const luminance = calculateLuminance(r, g, b);
        
        const threshold = 150;
                
        return luminance > threshold ? '#000000' : '#ffffff';
    } catch (e) {
        return '#ffffff';
    }
}


    sortedLines.forEach(line => {
        const lineNameText = lineName[line] || "Inconnue";
        const lineColor = lineColors[line] || '#000000';
        const textColor = getTextColor(lineColor);


        const lineSection = document.createElement('div');
        lineSection.dataset.line = line;
        lineSection.style.backgroundColor = lineColor;
        lineSection.classList.add('linesection');
        lineSection.style.marginBottom = '10px';
        lineSection.style.padding = '10px';
        lineSection.style.borderRadius = '8px';
        lineSection.style.position = 'relative';

        lineSection.onmouseover = () => {
        lineSection.style.transform = 'scale(0.98,0.98)';
        lineSection.style.opacity = '0.9';
        lineSection.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
        };  
        lineSection.onmouseout = () => {
            lineSection.style.transform = 'scale(1,1)';
            lineSection.style.opacity = '0.9';
            lineSection.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
        };

        const favoriteButton = document.createElement('button');
        favoriteButton.style.position = 'absolute';
        favoriteButton.style.right = '5px';
        favoriteButton.style.top = '5px';
        favoriteButton.style.background = 'none';
        favoriteButton.style.border = 'none';
        favoriteButton.style.color = textColor;
        favoriteButton.style.fontSize = '20px';
        favoriteButton.style.cursor = 'pointer';
        favoriteButton.innerHTML = favoriteLines.has(line) ? '★' : '☆';
        favoriteButton.onclick = async (e) => {
            e.stopPropagation();
            const lineSection = e.target.closest('.linesection');
            const isFavorite = favoriteLines.has(line);
            await animateFavoriteTransition(e.target, lineSection, line, isFavorite);
        };

        const lineTitle = document.createElement('div');
        lineTitle.textContent = `Ligne ${lineNameText}`;
        lineTitle.style.fontSize = '23px';
        lineTitle.style.fontWeight = 'normal';
        lineTitle.style.color = textColor;
        lineTitle.style.paddingRight = '30px';
        lineTitle.style.paddingLeft = '10px';


        lineSection.appendChild(lineTitle);
        lineSection.appendChild(favoriteButton);

        Object.keys(busesByLineAndDestination[line])
    .sort()
    .forEach(destination => {
        const destinationSection = document.createElement('div');
        destinationSection.style.marginTop = '5px';
        destinationSection.style.paddingLeft = '10px';

        const destinationTitle = document.createElement('div');
        destinationTitle.textContent = `➜ ${destination}`;
        destinationTitle.style.fontSize = '16px';
        destinationTitle.style.fontWeight = 'normal';
        destinationTitle.style.color = textColor;
        destinationSection.appendChild(destinationTitle);

        busesByLineAndDestination[line][destination].forEach(bus => {
            const busItem = document.createElement('div');
            const marker = bus.vehicle;
            const popupContent = marker.getPopup().getContent();
            
            let nextStopInfo = '';
            let terminusInfo = '';
            
            const stopNameContainers = popupContent.match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/g);
            const timeDisplays = popupContent.match(/<div class="time-display"[^>]*data-time-left="([^"]*)"[^>]*data-departure-time="([^"]*)"[^>]*>([\s\S]*?)<\/div>/g);
            
            if (stopNameContainers && stopNameContainers.length > 0 && timeDisplays && timeDisplays.length > 0) {
                const firstStopNameMatch = stopNameContainers[0].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                const firstTimeMatch = timeDisplays[0].match(/data-time-left="([^"]*)"/);
                
                if (firstStopNameMatch && firstStopNameMatch[1] && firstTimeMatch && firstTimeMatch[1]) {
                    const stopName = firstStopNameMatch[1].trim();
                    const timeInfo = firstTimeMatch[1].trim();
                    if (stopName && timeInfo) {
                        nextStopInfo = `| ${stopName}`;
                    }
                }
                
                if (stopNameContainers.length > 1 && timeDisplays.length > 1) {
                    const lastIndex = stopNameContainers.length - 1;
                    const lastStopNameMatch = stopNameContainers[lastIndex].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                    const lastTimeMatch = timeDisplays[lastIndex].match(/data-time-left="([^"]*)"/);
                    
                    if (lastStopNameMatch && lastStopNameMatch[1] && lastTimeMatch && lastTimeMatch[1]) {
                        const terminusName = lastStopNameMatch[1].trim();
                        const terminusTime = lastTimeMatch[1].trim();
                        if (terminusName && terminusTime) {
                            terminusInfo = `Arrivée à ${destination} ${terminusTime !== 'imminent' ? 'dans ' + terminusTime : 'imminent'}.`;
                        }
                    }
                }
            }
            
            if (!nextStopInfo || !terminusInfo) {
                const stopsHeaderMatch = popupContent.match(/<p style="margin: 0; font-size: 18px; text-align: right;">(.*?)<\/p>/);
                if (stopsHeaderMatch && stopsHeaderMatch[1]) {
                    const headerText = stopsHeaderMatch[1].trim();
                    if (headerText.includes('imminent')) {
                        nextStopInfo = '| Départ imminent';
                    } else if (headerText.includes('min')) {
                        const minMatch = headerText.match(/dans (\d+) min/);
                        if (minMatch && minMatch[1]) {
                            nextStopInfo = `| Départ dans ${minMatch[1]} min.`;
                        }
                    }
                }
                
                if (!terminusInfo) {
                    terminusInfo = `à destination de ${destination}.`;
                }
            }
                    const mainText = document.createElement('div');
                    mainText.textContent = `Bus ${bus.parkNumber} ${nextStopInfo}`;
                    mainText.style.fontSize = '1.2em';  
                    mainText.style.fontWeight = '500';  
                    mainText.style.color = textColor;
                    
                    const arrivalText = document.createElement('div');
                    arrivalText.textContent = terminusInfo;
                    arrivalText.style.fontSize = '0.9em'; 
                    arrivalText.style.opacity = '0.8';  
                    arrivalText.style.textAlign = 'right';
                    arrivalText.style.color = textColor;

                    busItem.textContent = '';
                    busItem.appendChild(mainText);
                    busItem.appendChild(arrivalText);
                    
                    busItem.style.cursor = 'pointer';
                    busItem.classList.add('menu-item');
                    busItem.style.fontFamily = 'League Spartan';
                    busItem.style.color = textColor;
                    busItem.style.padding = '5px 10px';
                    busItem.style.marginBottom = '5px';
                    busItem.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                    busItem.style.border = '1px solid rgba(0, 0, 0, 0.2)'; 
                    busItem.style.borderRadius = '8px';
                    busItem.style.overflow = 'hidden';
                    busItem.style.maxWidth = '300px';
                    lineSection.onclick = () => {
                        const lineId = line;
                        selectedLine = lineId;
                        filterByLine(lineId);
                        menu.classList.add('hidden');
                        menu.addEventListener('transitionend', function onTransitionEnd(event) {
                            if (event.target === menu) { 
                                menu.style.display = 'none';
                            }
                        });
                        isMenuVisible = false;
                        const filtre = document.getElementById('filtre');
                        menubottom1.style.display = 'flex';
                        setTimeout(() => {
                            menubottom1.classList.remove('slide-upb');
                            menubottom1.classList.add('slide-downb');
                            if (selectedLine) {
                                filtre.classList.remove('slide-upc');
                                filtre.classList.add('slide-downc');
                            }
                        }, 10);
                    };

                    busItem.onclick = (event) => {
                        map.setView(bus.vehicle.getLatLng(), 15);
                        bus.vehicle.openPopup();
                        menu.classList.add('hidden');
                        menu.addEventListener('transitionend', function onTransitionEnd(event) {
                            if (event.target === menu) { 
                                menu.style.display = 'none';
                            }
                        });
                        isMenuVisible = false;
                        if (selectedLine) {
                            resetMapView();
                        }
                        event.stopPropagation();
                    };

                    destinationSection.appendChild(busItem);
                });

                lineSection.appendChild(destinationSection);
            });

        menu.appendChild(lineSection);
    });
}

const menubottom1 = document.getElementById('menubtm');


        function showMenu() {
            const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menu.classList.remove('hidden');
            menu.style.display = 'block'; 
            isMenuVisible = true; 
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });

        }

        const menubutton = document.getElementById('menubutton');
        menubutton.onclick = showMenu; 


        const closeMap = document.getElementById('map');
        closeMap.onclick = () => {
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            menu.addEventListener('transitionend', function onTransitionEnd(event) {
                if (event.target === menu) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
        if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.remove('slide-upc');
        filtre.classList.add('slide-downc');
        }
    }, 10);
    
        };

        updateMenu();

    } catch (error) {
        console.error('Err récup des données ! ', error);
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : no vehicle found on realtime data');

    }
}




let lastTripUpdateTimestamp = 0;
let worker;
let fetchInProgress = false;
const FETCH_INTERVAL = 8000; 

function initWorker() {
    worker = new Worker('worker.js');
    
    worker.onerror = (error) => {
        console.error('Erreur worker', error);
        setTimeout(() => {
            worker.terminate();
            initWorker();
        }, 1000);
    };
}

async function fetchTripUpdates() {
    if (fetchInProgress) return Promise.resolve(null);
    
    fetchInProgress = true;
    const fetchStartTime = performance.now();
    
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // timeout après 5s
        
        const response = await fetch('proxy-cors/proxy_tripupdate.php', {
            signal: controller.signal,
            cache: 'no-store' 
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);
        
        const fetchTime = performance.now() - fetchStartTime;
        console.debug(`Téléchargement gtfs en ${fetchTime.toFixed(2)}ms`);
        
        return new Promise((resolve, reject) => {
            const workerTimeoutId = setTimeout(() => {
                reject(new Error('Worker timeout'));
            }, 3000);
            
            worker.onmessage = (e) => {
                clearTimeout(workerTimeoutId);
                const processTime = performance.now() - fetchStartTime;
                
                tripUpdates = e.data.tripUpdates;
                
                
                resolve(e.data.tripUpdates);
                fetchInProgress = false;
            };
            
            worker.postMessage(data);
        });
    } catch (error) {
        console.error('Erreur récupération trip updates:', error);
        fetchInProgress = false;
        throw error;
    }
}

let lastUpdateTime = 0;
function scheduleFetchUpdates(timestamp) {
    if (!lastUpdateTime || timestamp - lastUpdateTime >= FETCH_INTERVAL) {
        lastUpdateTime = timestamp;
        
        Promise.all([
            fetchTripUpdates().catch(() => null),
            fetchVehiclePositions().catch(() => null)
        ]).catch(error => {
            console.warn('Erreur lors des mises à jour', error);
        });
    }
    
    requestAnimationFrame(scheduleFetchUpdates);
}


async function main() {
    try {
        initWorker();
        
        const gtfsData = await initializeGTFS();
        gtfsInitialized = true;
        
        await loadGeoJsonLines();
        
        await Promise.all([
            fetchTripUpdates().catch(console.error),
            fetchVehiclePositions(),
            hideLoadingScreen()
        ]);
        
        requestAnimationFrame(scheduleFetchUpdates);
        
    } catch (error) {
        console.error("Erreur critique dans main():", error);
        toastBottomRight.error("Une erreur critique est survenue. Nous investigons actuellement sur la cause de la panne.");
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', main);
} else {
    main();
}    
</script>
</html>
