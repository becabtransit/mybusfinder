<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="MyBusFinder Réseau Mistral">
	<link rel="canonical" href="https://sudtransports.fr/toulon">
	<link rel="apple-touch-icon" href="src/logo.png">
    <title>MyBusFinder Réseau Mistral</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protobufjs/6.11.2/protobuf.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
    <meta name="google-adsense-account" content="ca-pub-5815761294049475">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
        <style>
        html, body {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
            font-family: 'League Spartan', sans-serif;
            background-color: #f4f4f4; 
            color: #333; 
            transition: background-color 0.5s ease; 
        }

        @font-face {
            font-family: 'League Spartan';
            src: url('src/fonts/leaguespartan.ttf') format('truetype');
        }

        #map {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
			
			
        .update-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 95%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    overflow-y: hidden;
}

.popup-content {
    background: white;
    width: 100%;
    height: 100%;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
}


.timepopup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 95%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper, .leaflet-popup-tip {
  background-color: transparent;
  box-shadow: none !important;
  border-radius: 15px;
  padding: 0px 0px 0px 0px;
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(13px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
  transform-origin: center bottom;
}

.leaflet-popup-content-wrapper.show, .leaflet-popup-tip.show {
  transform: scale(1) translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper.hide, .leaflet-popup-tip.hide {
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.leaflet-popup-content {
  margin: 0px 
}


.leaflet-popup-close-button {
visibility: hidden;
}

.popup-zoom-in {
    transform: scale(1) translateY(0px); 
    opacity: 1;
}

.popup-zoom-out {
    transform: scale(0.9) translateY(20px); 
    opacity: 0;
}

#menubtm {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
}




@keyframes fadeInPopupSvc {
    from {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

@keyframes fadeOutPopupSvc {
    from {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
}

@keyframes fadeInPopup {
    from {
        opacity: 0;
        transform: translate(0%, 30%);
    }
    to {
        opacity: 1;
        transform: translate(0%, 0%);
    }
}

@keyframes fadeOutPopup {
    from {
        opacity: 1;
        transform: translate(0%, -30%);
    }
    to {
        opacity: 0;
        transform: translate(0%, 0%);
    }
}

.custom-scrollbar::-webkit-scrollbar {
    height: 8px; 
}
.custom-scrollbar::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 10px;
    border: 2px solid #f1f1f1;
}

.custom-scrollbar {
    -webkit-overflow-scrolling: touch;
}

			
.popup-content h2 {
    font-size: 24px;
    font-family: 'League Spartan', sans-serif;
    color: #333;
    margin-bottom: 15px;
}

#update-notes {
    font-family: 'League Spartan', sans-serif;
    font-size: 16px;
    color: #555;
    line-height: 1;
}

#update-notes li {
    margin-bottom: 10px;
}



#menu {
    position: absolute;
    top: 0px;
    right: 0px;
    background-color: #0F056B77;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 10px;
    border-radius: 0px 0px 0px 0px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 1);
    z-index: 1000;
    height: 98vh; 
    overflow-y: auto;
    opacity: 0.9;
    transition: all 0.3s ease;
    display: none;
}





        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: scale(0);
            opacity: 0;
            animation: ripple-animation 0.6s linear forwards;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 1;
            }
        }

        ul {
    padding: 0;
    margin: 0;
    list-style-type: none;
    padding-inline-start: 0;
}


        .menu-item {
            cursor: pointer;
            padding: 6px;
            transition: background-color 0.3s ease; 
            border-radius: 5px;
            z-index: 100000;
        }

        .menu-item:hover {
            background-color: #0000001f; 
            animation: jspcommentlappelercettekeyframe 0.1s linear forwards;
        }

        .linesection {
            cursor: pointer;
        }

        @keyframes jspcommentlappelercettekeyframe {
            to {
                transform: scale(0.95);
            }
        }

        .popup-content {
            font-family: 'League Spartan', sans-serif;
            font-size: 12px;
            line-height: 1.1;
        }

        .popup-header {
            padding: 5px;
            border-radius: 10px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }





@keyframes textFadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}

.loading-animation {
    font-family: 'League Spartan', sans-serif;
    font-size: 50px;  
    font-weight: bold;
    background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0); 
    -webkit-background-clip: text;
    color: transparent;
    animation: gradientTextAnimation 3s ease infinite; 
}


.share-btn, .donate-btn {
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes slideInBounce {
    0% {
        right: -100%; 
    }
    100% {
        right: 0; 
    }
}

#menu {
    animation: slideInBounce 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
}

@keyframes bounceIn {
    0% {
        transform: scale(0.9);
        opacity: 0.7;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.popup-content, .popup-content1, .popup1 {
    animation: zoomFadeIn 0.6s cubic-bezier(0.25, 1.5, 0.5, 1) forwards;
}

@keyframes zoomFadeIn {
    0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(13px); 

    }
    100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0); 
    }
}


.marker-icon {
    animation: zoomInOut 2s infinite;
}

@keyframes zoomInOut {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.13); }
}


span[style*="padding: 5px 10px;"] {
    animation: badgePulse 1.5s infinite;
}
@keyframes badgePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

#nextStopsContent div {
    animation: fadeInScroll 0.3s ease-in;
	display: inherit;
}
@keyframes fadeInScroll {
    from { opacity: 0; }
    to { opacity: 1; }
}

.marker-icon:hover {
    animation: hoverBounce 0.3s ease-in-out;
}
@keyframes hoverBounce {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.glass-effect {
    position: relative;
    overflow: hidden;
}

.glass-effect::before {
    content: '';
    position: absolute;
    top: 0;
    left: -140%;
    width: 140%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
}

.glass-effect.animate::before {
    animation: glass-slide 1s ease forwards;
}

@keyframes glass-slide {
    0% {
        left: -100%;
    }
    100% {
        left: 150%;
    }
}
			
@keyframes gradientTextAnimation {
    0% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
    50% {
        background: linear-gradient(45deg, #ffffff, #f0f0f0, #ffffff);
    }
    100% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
}

:root {
  --base_scale: 3vh;
  --floor: 15vh;
  --color: #836ee5;
}

body {
  margin: 0;
  overflow: hidden;
}

#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #000000;
  background-size: cover;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 10000;
}

.shapes-container {
  width: 100%;
  overflow: hidden;
}

shape {
  position: absolute;
  display: block;
  left: 50%;
  bottom: 0;
  margin-left: calc(-1 * (var(--base_scale) / 2));
  margin-bottom: var(--floor);
  transform-origin: center;
}

shape.circle {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
  border-radius: 50%;
}

shape.semi-circle {
  width: var(--base_scale);
  height: calc(var(--base_scale) * 2);
  background: var(--color);
  border-bottom-right-radius: calc(var(--base_scale) * 2);
  border-top-right-radius: calc(var(--base_scale) * 2);
}

shape.square {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
}

shape.bounce-up {
  animation: bounceUp 600ms cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
}

shape.bounce-down {
  animation: bounceDown 600ms cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards;
}

@keyframes bounceUp {
  0% {
    transform: translateY(0) rotate(0deg);
  }
  100% {
    transform: translateY(-30vh) rotate(180deg);
  }
}

@keyframes bounceDown {
  0% {
    transform: translateY(-30vh) rotate(180deg);
  }
  100% {
    transform: translateY(0) rotate(360deg);
  }
}

#stop-suggestions li {
    padding: 10px;
    cursor: pointer;
    border-bottom: 1px solid #ddd;
}

#stop-suggestions li:hover {
    background-color: #f4f4f4;
}


#loading-text {
  margin-top: 20px;
  font-size: 18px;
  color: black;
  animation: fadeIn 1.5s ease forwards;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.filtre {
    display: flex;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%) translateY(-100%);
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    padding: 10px 15px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    background-color: #0F056B77;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.filtre-texte {
    color: #ffffff;
}

.menubottom-ul {
    display: flex;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%);
    padding: 12px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    padding: 0;
    background-color: #0F056B77;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5); 
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.menubottom ul li {
    margin: 0 8px; 
}

        .menubottom ul li a {
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 20px;
            font-family: League Spartan;
            text-decoration: none;
            height: 70px;
            width: 70px;
            position: relative;
            transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
                }

        .menubottom ul li a .icon {
            position: relative;
            font-size: 20px;
            transition: transform 0.2s ease-in-out;
            transition: .5s;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .menubottom ul li a .title {
    margin-bottom: 8px; 
    font-size: 14px;
    text-align: center;
    opacity: 1; 
    transition: none; 
}

.menubottom ul li a:hover .icon {
    transform: scale(1.1); 
    background-color: rgba(255, 255, 255, 0.1);
}

        .menubottom ul li a:active {
    transform: scaleX(90%)scaleY(90%); 
    background-color: rgba(255, 255, 255, 0); 
}


@keyframes barFadeIn {
    0% {
        opacity: 0;
        transform: translateY(60px); 
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}


			
.next-stops-container {
	max-height: 100px;
    padding: 10px;
    background: #f9f9f9;
    border-top: 1px solid #ddd;
    position: relative;
}

.next-stops-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.next-stops-content {
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
    padding-inline-start: 0;
    list-style-type: none; 
    overflow-y: auto;
}

.popup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: fadeInPopup 0.5s forwards;
    background-color: #ffffff; 
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
    max-height: 80%;
    width: 90%;
    max-width: 500px;
    z-index: 1001;
    overflow-y: auto;
    opacity: 0; 
        }

        .popup-content {
            text-align: center;
        }

        .close-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #333;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    transition: background-color 0.3s;
}

.close-btn:hover {
    background-color: #555;
}

        .textpop h4 {
    margin-bottom: 0.3rem;
}

.textpop h1 {
    margin-top: 0;
}



.slide-down {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.logoscr {
  transform: translateY(100px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
}

.popup-slide {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}

.popup-slide-hidden {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(-30%);
    opacity: 0;
}

.popup-slide-right {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(30%);
    opacity: 0;
}

.popup-slide-active {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}



.schedule-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    padding: 5px;
    background: #f8f9fa;
    border-radius: 8px;
}

.schedule-row span {
    font-weight: bold;
    color: #333;
}


.logoscrapp {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
}

.logoscrappp {
  transform: scale(0.8); 
  filter: blur(0); 
}

.logoscrapppp {
  opacity: 0; 
}

@media (max-width: 600px) {
    #logoscr {
      width: 50%;  
      max-width: 200px;  
    }
  }

  @media (min-width: 1200px) {
    #logoscr {
      width: 10%;  
      max-width: 400px;  
    }
  }

.slide-up {
  transform: translateY(-100%); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.slide-downb {
  transform: translateY(0) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upb {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}


.slide-downc {
  transform: translateY(-220%) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upc {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

#popup1::-webkit-scrollbar {
        width: 8px;
    }
    #popup1::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb:hover {
        background: #555;
    }


@keyframes loadingBarAnimation {
    0% {
        width: 0%;
    }
    50% {
        width: 100%;
    }
    100% {
        width: 100%;
    }
}


        .marker-icon:hover {
        transform: scale(0.8);
        transition: transform 0.2s ease;
        }

      

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes zoomOut {
            from {
                transform: scale(1);
                opacity: 1;
            }
            to {
                transform: scale(1.5);
                opacity: 0;
            }
        }

@keyframes fadeColors {
    0% { background-color: rgb(0, 0, 0); }
    25% { background-color: rgb(0, 0, 168); }
    50% { background-color: rgb(0, 158, 158); }
    75% { background-color: rgb(155, 155, 0); }
    100% { background-color: rgb(0, 0, 0); }
}

.logobkg {
  transition: opacity 0.3s ease-out;
}
.loading-screen-fade {
    animation: fadeColors 1s ease-in; 
}

#webview-frame {
    width: 100%;
    height: 100%;
    border-radius: 10px;
}

.vehicle-thumbnail {
    width: 95.5%;
    height: 60px;
    margin-left: auto;
    border-radius: 5px;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 2px;
}

.vehicle-model {
    display: flex;
    align-items: right;
    justify-content: flex-end;
    flex-direction: column;
}

.stops-timeline-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 400px;
    z-index: 1000;
    overflow: hidden;
    max-height: 80vh;
    display: none;
    opacity: 0;
    filter: blur(5px);
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                opacity 0.3s ease-out,
                filter 0.3s ease-out;
}

.stops-timeline-menu.visible {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    filter: blur(0);
}

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

.overlay.visible {
    opacity: 1;
}

.show-in-map-btn {
    margin: 20px;
    padding: 12px;
    background: #363636;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    width: calc(100% - 40px);
    position: sticky;
    bottom: 0;
    transition: transform 0.3s ease, background-color 0.3s ease;
}

.show-in-map-btn:hover {
    background: #2c2c2c;
    transform: scale(0.98);
}

.show-in-map-btn:active {
    transform: scale(0.95);
}

.leaflet-control-locate a {
  cursor: pointer;
}
.leaflet-control-locate a .leaflet-control-locate-location-arrow {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate a .leaflet-control-locate-spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M304 48a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48 368a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm208-208a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM96 256a48 48 0 1 0-96 0 48 48 0 0 0 96 0zm13 99a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm294 0a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM109 61a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"/></svg>');
  animation: leaflet-control-locate-spin 2s linear infinite;
}
.leaflet-control-locate.active a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(32, 116, 182)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate.following a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(252, 132, 40)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}

.leaflet-touch .leaflet-bar .leaflet-locate-text-active {
  width: 100%;
  max-width: 200px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  padding: 0 10px;
}
.leaflet-touch .leaflet-bar .leaflet-locate-text-active .leaflet-locate-icon {
  padding: 0 5px 0 0;
}

.leaflet-control-locate-location circle {
  animation: leaflet-control-locate-throb 4s ease infinite;
}

@keyframes leaflet-control-locate-throb {
  0% {
    stroke-width: 1;
  }
  50% {
    stroke-width: 3;
    transform: scale(0.8, 0.8);
  }
  100% {
    stroke-width: 1;
  }
}
@keyframes leaflet-control-locate-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}


    </style>

</head>
<body>
<!--          _   __                         ________                                                                          -->
<!--         //   ) )                __     /__  ___/                                                                          -->
<!--        ((                  ___ / /       / /   __      ___       __      ___      ___      ___      __    __  ___  ___    -->
<!--          \\     //   / / //   ) /       / /  //  ) ) //   ) ) //   ) ) ((   ) ) //   ) ) //   ) ) //  ) )  / /   ((   ) ) -->
<!--            ) ) //   / / //   / /       / /  //      //   / / //   / /   \ \    //___/ / //   / / //       / /     \ \     -->
<!--     ((___ / / ((___( ( ((___/ /       / /  //      ((___( ( //   / / //   ) ) //       ((___/ / //       / /   //   ) )   -->
<!--                                                          Code ayant pour entière propriété Sud Transports/Bechir Abidi    -->
<!--                                                                Réutilisation non autorisée sauf en cas de dérogation !    -->

<div class="filtre" id="filtre">
    <span class="filtre-texte">Réinitialiser les filtres</span>
</div>

<div class="filtre" id="locate">
    <span class="filtre-texte">Me géolocaliser</span>
</div>


 <div class="menubottom">
        <ul id="menubtm" class="menubottom-ul">
            <li>
                <a href="https://mybusfinder.sudtransports.fr/"><span class="icon"><img src="src/menu.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Menu</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('schedule.html');" id="clock"><span class="icon"><img src="src/horloge.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Horaires</span></a>
            </li>
            <li>
                <a id="menubutton"><span class="icon"><img src="src/bus.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Réseau</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('histovec.html');" id="histovecbutton"><span class="icon"><img src="src/histovec.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title">Histovec</span></a>
            </li>
        </ul>
</div>
	



	<amp-auto-ads type="adsense"
        data-ad-client="ca-pub-5815761294049475">
</amp-auto-ads>


    <div id="map"></div>


    <div id="menu"></div>
    <div id="update-popup" class="update-popup">
        <div class="popup-content">
            <button id="close-popup" class="close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            <iframe id="webview-frame" src="" frameborder="0"></iframe>
        </div>
    </div>
                


	
	
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


	
<div id="loading-screen" class="logobkg">
    <img id="logoscr" class="logoscr" src="src/whitelogo.png" style="display: block; margin: 0 auto; max-width: 50%; height: auto;"/>
</div>
  

 <script src="src/js/toastjs.js"></script>       

<script>
async function getSetvar() {
    try {
        const response5 = await fetch('setvar/settings/theme/maincolor.txt');
        const setvar5 = await response5.text();  
        const colorbkg = setvar5.trim();

        const response = await fetch('setvar/settings/map/defaultzoom.txt');
        const setvar = await response.text();
        const view = setvar.trim();  

        return { colorbkg, view };

    } catch (error) {
        console.error('Erreur chargement setvar ! ', error);
    }
}

getSetvar();

const vehicleModels = {};

const vehicleTypes = {
    'elec': new Set(),
    'hybrid': new Set(),
    'gnv': new Set(),
    'usb': new Set(),
    'clim': new Set()
};

let map;

async function setColors() {
    const data = await getSetvar();
    if (data) {
        document.getElementById("menubtm").style.backgroundColor = `${data.colorbkg}77`;
        document.getElementById("menu").style.backgroundColor = `${data.colorbkg}77`;
    }
}
setColors();

setTimeout(() => {
    const logoscr = document.getElementById('logoscr');
    logoscr.classList.add('logoscrapp');
}, 10); 

async function initMap() {
    const data = await getSetvar();
    let defaultCoords = [43.125463, 5.930077];
    let defaultZoom = 13;
    
    if (data && data.view) {
        try {
            const viewConfig = data.view.match(/\[(.*?)\],\s*(\d+)/);
            if (viewConfig && viewConfig.length >= 3) {
                const coords = viewConfig[1].split(',').map(coord => parseFloat(coord.trim()));
                defaultCoords = [coords[0], coords[1]];
                defaultZoom = parseInt(viewConfig[2]);
            }
        } catch (error) {
            console.error('Erreur parsing des coord gps', error);
        }
    }
    
    const mapInstance = L.map('map', {
        zoomControl: false 
    }).setView(defaultCoords, defaultZoom);
    
    L.popup({
        closeButton: false
    });
    
    mapInstance.on('popupopen', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-out', 'popup-zoom-in');
        setTimeout(() => {
            popupWrapper.classList.add('popup-zoom-in');
        }, 10); 
    });
    
    mapInstance.on('popupclose', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-in');
        popupWrapper.classList.add('popup-zoom-out');
        popupWrapper.addEventListener(
            'transitionend',
            () => {
                popupWrapper.classList.remove('popup-zoom-out');
            },
            { once: true }
        );
    });
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; MyBusFinder X'
    }).addTo(mapInstance);

    mapInstance.on('locationfound', onLocationFound);
    mapInstance.on('locationerror', onLocationError);

    return mapInstance;
}

function onLocationFound(e) {
    const radius = e.accuracy / 2;

    if (window.locationMarker) {
        map.removeLayer(window.locationMarker);
    }
    if (window.locationCircle) {
        map.removeLayer(window.locationCircle);
    }

    window.locationCircle = L.circle(e.latlng, {
        radius: radius,
        color: '#136AEC',
        fillColor: '#136AEC',
        fillOpacity: 0.15,
        weight: 2
    }).addTo(map);

    map.setView(e.latlng, 16);
}

function onLocationError(e) {
    toastBottomRight.warning("Vous avez refusé la localisation.");
}

function locateUser() {
    if (!map) return;
    
    if ("geolocation" in navigator) {
        const locationOptions = {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
        };

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;

                map.fireEvent('locationfound', {
                    latlng: L.latLng(lat, lng),
                    accuracy: accuracy,
                    timestamp: position.timestamp
                });
            },
            (error) => {
                map.fireEvent('locationerror', {
                    code: error.code,
                    message: error.message
                });
            },
            locationOptions
        );
    } else {
        toastBottomRight.error("La géolocalisation n'est pas supportée par votre navigateur");
    }
}

(async function() {
    map = await initMap();
})();


        const markers = {};
        let lineColors = {};
        let lineName = {};
        let stopIds = [];
        let stopNameMap = {}
        let selectedLine = null;
        let geoJsonLines = []; 
        let tripUpdates = {};
        let loadingInterval;


        function showLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    loadingScreen.style.display = 'flex';


    loadingInterval = setInterval(() => {}, 1000);
}
		


        var audio = new Audio("src/sounds/musique.mp3"); 

function showUpdatePopup(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = link; 
    popup.style.display = 'flex'; 


    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');

            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        resetMapView();
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });


}

window.addEventListener('message', function(event) {
    if (event.data && event.data.action === 'showUpdatePopup') {
        if (window.parent && typeof window.parent.showUpdatePopup === 'function') {
            window.parent.showUpdatePopup(event.data.url);
        }
    }
}, false);

function focusOnVehicle(vehicleId) {
    try {        
        closeUpdatePopup();
        
        const marker = Object.values(markers).find(m => m.id === vehicleId);
        
        if (!marker) {
            toastBottomRight.error('La position du véhicule est indisponible');
            return;
        }
        
        
        try {
            map.setView(marker.getLatLng(), 17);
            marker.openPopup();
            
            const markerIcon = marker._icon.querySelector('.marker-icon');
            if (!markerIcon) {
                toastBottomRight.error('La position du véhicule est indisponible');

                return;
            }
            
            markerIcon.style.transform = 'scale(1.3)';
            setTimeout(() => {
                markerIcon.style.transform = 'scale(1)';
            }, 500);
            
        } catch (mapError) {
            toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : manipulating marker error');
        }
    } catch (error) {
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : focusOnVehicle function error');
    }
}

window.addEventListener('message', function(event) {
    try {
        console.log('Received message event:', event.data);
        
        if (event.data && event.data.type === 'vehicleSelected') {
            const vehicleId = event.data.vehicleId;
            focusOnVehicle(vehicleId);
        }
    } catch (error) {
        console.error('Error ', error);
    }
});

function closeUpdatePopup() {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = ""; 
    popup.style.display = 'none'; 
    
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    
    menu.style.display = 'none'; 
    isMenuVisible = false; 
    menubottom1.style.display = 'flex';
    
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);
    
    if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
    }
}


function musique() {
    if (audio.paused) {
        audio.play();
    }
}


document.getElementById('close-popup').addEventListener('click', closeUpdatePopup);




function hideLoadingScreen() {
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.classList.add('loading-screen-fade');


        setTimeout(() => {
            const logoscr = document.getElementById('logoscr');
            logoscr.classList.add('logoscrappp');
            loadingScreen.classList.add('logoscrapppp');


            setTimeout(() => {
                loadingScreen.style.display = 'none';
                setTimeout(() => {
                const locate = document.getElementById('locate');
                locate.classList.remove('slide-upc');
                locate.classList.add('slide-downc');
                        locate.onclick = () => {
                        locateUser();
                        locate.classList.add('slide-upc');
                        locate.classList.remove('slide-downc');
                }; 
                setTimeout(() => {
                    locate.classList.add('slide-upc');
                    locate.classList.remove('slide-downc');
                }, 10000); 
                }, 1200); 
            }, 300);
        }, 900);
    }, 100);
}


document.addEventListener('DOMContentLoaded', initializeApp);
const doc = document;
showLoadingScreen();


let data;


const DB_NAME = 'MyBusFinder';
const DB_VERSION = 3;
const STORE_NAME = 'gtfsStore';

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function isFirstVisitOfDay() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('lastUpdate');

            request.onsuccess = () => {
                const lastVisit = request.result;
                if (!lastVisit) {
                    resolve(true);
                    return;
                }

                const lastVisitDate = new Date(lastVisit);
                const currentDate = new Date();
                
                resolve(
                    lastVisitDate.getDate() !== currentDate.getDate() ||
                    lastVisitDate.getMonth() !== currentDate.getMonth() ||
                    lastVisitDate.getFullYear() !== currentDate.getFullYear()
                );
            };

            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        toastBottomRight.error('Erreur lors de la vérification des données');
        return true;
    }
}

async function saveToCache(data) {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            store.put(data, 'gtfsData');
            store.put(new Date().toISOString(), 'lastUpdate');

            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('Erreur lors de la sauvegarde dans le cache', error);
        throw error;
    }
}

async function getFromCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('gtfsData');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de la récupération cache', error);
        return null;
    }
}

async function extractGTFSFiles() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`Échec du téléchargement: ${response.status} ${response.statusText}`);
        }
        
        const zipData = await response.arrayBuffer();
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        
        const filePromises = [];
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        
        return extractedFiles;
    } catch (error) {
        throw error;
    }
}

async function loadLineColors(routesFileContent) {
    try {
        if (!routesFileContent) {
            return;
        }
        
        const data = await getSetvar();
        if (!data) {
            console.error('Échec récupération variables de config');
            return;
        }
        
        const lines = routesFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const routeIdIndex = headers.indexOf('route_id');
        const routeLongNameIndex = headers.indexOf('route_short_name');
        const routeColorIndex = headers.indexOf('route_color');
        
        if (routeIdIndex === -1 || routeLongNameIndex === -1 || routeColorIndex === -1) {
            console.error('Impossible de trouver tous les entêttes requis dans fichier routes.txt');
            return;
        }
        
        const startIndex = data.slicelinecolor ? parseInt(data.slicelinecolor) : 1;
        
        lines.slice(startIndex).forEach(line => {
            if (!line.trim()) return;
            
            const columns = line.split(',');
            
            if (columns.length <= Math.max(routeIdIndex, routeLongNameIndex, routeColorIndex)) {
                return;
            }
            
            const routeId = columns[routeIdIndex];
            const routeLongName = columns[routeLongNameIndex];
            let routeColor = columns[routeColorIndex];
            if (routeColor && !routeColor.startsWith('#') && routeColor.trim() !== '') {
                routeColor = `#${routeColor}`;
            }
            
            let cleanedLineName = routeLongName ? routeLongName.replace(/\"/g, '').trim() : '';
            if (routeId) {
                lineColors[routeId] = routeColor;
                lineName[routeId] = cleanedLineName;
            }
        });
        
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadStopIds(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        
        if (stopIdIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    if (stopId) {
                        stopIds.push(stopId);
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadLineTerminusData(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        const stopNameIndex = headers.indexOf('stop_name');
        
        if (stopIdIndex !== -1 && stopNameIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    let stopName = columns[stopNameIndex];
                    
                    stopName = stopName.replace(/\"/g, '');
                    
                    if (stopId && stopName) {
                        stopNameMap[stopId] = stopName;
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function initializeGTFS() {
    try {
        Object.keys(lineColors).forEach(key => delete lineColors[key]);
        Object.keys(lineName).forEach(key => delete lineName[key]);
        stopIds.length = 0;
        Object.keys(stopNameMap).forEach(key => delete stopNameMap[key]);
        
        let extractedFiles;
        
        const isFirstVisit = await isFirstVisitOfDay();
        
        if (isFirstVisit) {
            toastBottomRight.info('Téléchargement des données quotidiennes..');
            extractedFiles = await extractGTFSFiles();
            await saveToCache(extractedFiles);
        } else {
            extractedFiles = await getFromCache();
            if (!extractedFiles) {
                toastBottomRight.info('Téléchargement des données quotidiennes..');
                extractedFiles = await extractGTFSFiles();
                await saveToCache(extractedFiles);
            }
        }
        
        if (extractedFiles['routes.txt']) {
            await loadLineColors(extractedFiles['routes.txt']);
        }
        
        if (extractedFiles['stops.txt']) {
            await loadStopIds(extractedFiles['stops.txt']);
            await loadLineTerminusData(extractedFiles['stops.txt']);
        } else {
            console.error('Fichier stops.txt non trouvé');
        }
        
        return {
            lineColors,
            lineName,
            stopIds,
            stopNameMap
        };
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation data théorique gtfs', error);
        throw error;
    }
}

async function clearGTFSCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
                toastBottomRight.success('Cache effacé avec succès !');
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de l\'effacement du cache', error);
        toastBottomRight.error('Erreur lors de l\'effacement du cache');
        throw error;
    }
}

async function decodeProtobuf(buffer) {
            const root = await protobuf.load('gtfs-realtime.proto');
            const FeedMessage = root.lookupType('transit_realtime.FeedMessage');
            const message = FeedMessage.decode(new Uint8Array(buffer));
            return FeedMessage.toObject(message, { longs: String });
        }

        window.addEventListener('message', function(event) {
    if (event.data.type === 'vehicleSelected') {
        const vehicleId = event.data.vehicleId;
        const tripId = event.data.tripId;
        const stopId = event.data.stopId;
        const routeId = event.data.routeId;
        
        const marker = findMarkerByVehicleId(vehicleId);
        if (marker) {
            map.setView(marker.getLatLng(), 17);
            
            marker.openPopup();
            
            const menu = document.getElementById('menu');
            menu.style.display = 'none';
            isMenuVisible = false;
            
            if (selectedLine) {
                resetMapView();
            }
        }
    }
});

function findMarkerByVehicleId(vehicleId) {
    for (const [id, marker] of Object.entries(markers)) {
        if (marker.id === vehicleId) {
            return marker;
        }
    }
    return null;
}

function createColoredMarker(lat, lon, route_id) {
    const color = lineColors[route_id] || '#000000';
    const markerHtmlStyles = `
        background-color: ${color};
        width: 12px;
        height: 12px;
        display: block;
        left: -6px;
        top: -6px;
        position: relative;
        border-radius: 50%;
        border: 2px solid white;
        transition: transform 0.2s ease; 
    `;

    const icon = L.divIcon({
        className: "my-custom-pin",
        iconAnchor: [0, 0],
        popupAnchor: [0, 5],
        html: `<span style="${markerHtmlStyles}" class="marker-icon" />`
    });

    const marker = L.marker([lat, lon], { icon });
    
    marker.on('mouseover', function() {
        this._icon.firstChild.style.transform = 'scale(1.2)';
    });
    
    marker.on('mouseout', function() {
        this._icon.firstChild.style.transform = 'scale(1)';
    });

    return marker;
}


function animateMarker(marker, newPosition) {
    const startLatLng = marker.getLatLng();
    const endLatLng = L.latLng(newPosition[0], newPosition[1]);
    const duration = 1000; 
    const startTime = performance.now();

    if (marker.animationFrame) {
        cancelAnimationFrame(marker.animationFrame);
    }

    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function animate(time) {
        const elapsed = time - startTime;
        const linearProgress = Math.min(elapsed / duration, 1);
        
        const easedProgress = easeInOutQuad(linearProgress);
        
        const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * easedProgress;
        const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * easedProgress;
        
        marker.setLatLng([lat, lng]);

        if (linearProgress < 1) {
            marker.animationFrame = requestAnimationFrame(animate);
        }
    }

    marker.animationFrame = requestAnimationFrame(animate);
}

async function loadGeoJsonLines() {
    const response = await fetch('proxy-cors/proxy_geojson.php');
    const geoJsonData = await response.json();

    L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry.type === 'LineString';
        },
        style: function(feature) {
            return {
                color: lineColors[feature.properties.route_id] || '#000000',
                weight: 2
            };
        },
        onEachFeature: function(feature, layer) {
            geoJsonLines.push(layer); 
        }
    }).addTo(map);
}

function filterByLine(lineId) {
    geoJsonLines.forEach(layer => {
        map.removeLayer(layer);
    });

    const selectedLineLayer = geoJsonLines.find(layer => layer.feature.properties.route_id === lineId);
    if (selectedLineLayer) {
        map.addLayer(selectedLineLayer);
    }

    Object.keys(markers).forEach(id => {
        map.removeLayer(markers[id]);
    });

    Object.keys(markers).forEach(id => {
        if (markers[id].line === lineId) {
            markers[id].addTo(map);
        }
    });
}


function resetMapView() {
    geoJsonLines.forEach(layer => {
        map.addLayer(layer);
    });

    Object.keys(markers).forEach(id => {
        markers[id].addTo(map);
    });

    selectedLine = null;
}




function showPopup() {
    const popup2 = document.getElementById('popup2');

    popup2.style.display = 'block';
    

    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        resetMapView();
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });



}

function closePopup() {
    const popup2 = document.getElementById('popup2');
    popup2.style.display = 'none';
    const menubottom1 = document.getElementById('menubtm');


            menu.style.display = 'none'; 
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);


}



const filtre = document.getElementById('filtre');
        filtre.onclick = () => {
            if (selectedLine) {
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        resetMapView();
        }
};










async function loadVehicleModels() {
    try {
        const response = await fetch('setvar/vehicules/index.php');
        const fileList = await response.json();
        
        for (const file of fileList) {
            if (file.endsWith('.txt')) {
                await loadVehicleModelFile(file);
            }
        }
        
    } catch (error) {
        console.error('Erreur lors du chargement des modèles de véhicules ', error);
        toastBottomRight.error('Erreur lors du chargement des modèles de véhicules ', error);
    }
}

async function loadVehicleModelFile(fileName) {
    try {
        const response = await fetch(`setvar/vehicules/${fileName}`);
        const content = await response.text();
        const lines = content.split('\n').map(line => line.trim()).filter(line => line !== '');
        
        if (lines.length < 8) {
            console.error(`Format invalide pour le fichier ${fileName}`);
            toastBottomRight.error(`Format invalide pour le fichier ${fileName}`);
            return;
        }
        
        const modelName = lines[0];
        const thumbnailPath = lines[1];
        
        const params = {
            isElectric: parseParamValue(lines[2]),       
            isHybrid: parseParamValue(lines[3]),       
            isGnv: parseParamValue(lines[4]),     
            isUsbPlugs: parseParamValue(lines[5]),  
            isAirConditioned: parseParamValue(lines[6]), 
            isHeatingUnit: parseParamValue(lines[7])
        };
        
        const vehicleIds = lines.slice(8);
        
        const modelKey = fileName.replace('.txt', '');
        
        vehicleModels[modelKey] = {
            name: modelName,
            thumbnail: thumbnailPath,
            params: params,
            vehicles: new Set(vehicleIds)
        };
        
        vehicleIds.forEach(id => {
            if (params.isElectric) vehicleTypes['elec'].add(id);
            if (params.isHybrid) vehicleTypes['hybrid'].add(id);
            if (params.isGnv) vehicleTypes['gnv'].add(id);
            if (params.isUsbPlugs) vehicleTypes['usb'].add(id);
            if (params.isAirConditioned || params.isHeatingUnit) vehicleTypes['clim'].add(id);
        });
        
    } catch (error) {
        console.error(`Erreur lors du chargement du fichier ${fileName}:`, error);
        toastBottomRight.error('Une erreur est survenue.');

    }
}

function parseParamValue(paramLine) {
    const parts = paramLine.split('=');
    if (parts.length !== 2) return false;
    
    return parts[1].toLowerCase() === 'true';
}

function getVehicleModel(parkNumber) {
    const parkId = String(parkNumber);    
    for (const [modelKey, model] of Object.entries(vehicleModels)) {
        if (model.vehicles.has(parkId)) {
            return model;
        }
    }
    return null;
}

function getVehicleOptionsBadges(parkNumber) {
    const model = getVehicleModel(parkNumber);
    let badges = '';
    
    if (model) {
        const params = model.params;
        
        if (params.isElectric) {
            badges += `<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/elec.png" alt="Électrique" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isHybrid) {
            badges += `<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/hyb.png" alt="Hybride" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isGnv) {
            badges += `<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/gnv.png" alt="Gaz Naturel" style="height: 20px; vertical-align: middle;">
            </span> `;
        }
        if (params.isUsbPlugs) {
            badges += `<span style="padding: 6px 10px; background: linear-gradient(45deg, #5856d677, #4b42d077); color: white; border-radius: 10px;">⚡ USB</span> `;
        }
        if (params.isAirConditioned) {
            badges += `<span style="padding: 6px 10px; background: linear-gradient(45deg, #ADD8E677, #91c1d477); color: black; border-radius: 10px;">❄️ Climatisé</span> `;
        }
        if (params.isHeatingUnit) {
            badges += `<span style="padding: 6px 10px; background: linear-gradient(45deg, #C21E5677, #9b164777); color: white; border-radius: 10px;">🌡️ Chauffé</span> `;
        }
    } 
    
    return badges;
}

function getVehicleBrandHtml(parkNumber) {
    const model = getVehicleModel(parkNumber);
    
    if (model) {
        if (!model.thumbnail) {
            return `<span>🚌 Un ${model.name}</span>`;
        } else {
        
        return `
            <div class="vehicle-model">
                <img src="${model.thumbnail}" class="vehicle-thumbnail" style="max-height: 30px;" onerror="this.parentNode.innerHTML='<span>🚌 Un ${model.name}</span>'" />
                <span style="margin-top: 6px;">🚌 Un ${model.name}</span>
            </div>
        `;
    }
    } else {
    return `<span>🚌 Un bus</span>`;
    }
}

function getVehicleDisplay(parkNumber) {
    const model = getVehicleModel(parkNumber);
    let html = '';
    
    if (model) {
        html += `
            <div class="vehicle-model">
                <img src="${model.thumbnail}" alt="${model.name}" class="vehicle-thumbnail" />
                <span style="margin-top: 10px;">🚎 ${model.name}</span>
            </div>
        `;
        
        const badges = [];
        const params = model.params;
        
        if (params.isElectric) {
            badges.push(`<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/elec.png" alt="Électrique" style="height: 20px; vertical-align: middle;">
            </span>`);
        }
        if (params.isHybrid) {
            badges.push(`<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/hyb.png" alt="Hybride" style="height: 20px; vertical-align: middle;">
            </span>`);
        }
        if (params.isGnv) {
            badges.push(`<span style="padding: 6px 10px; background: #00000077; border-radius: 10px;">
                <img src="src/gnv.png" alt="Gaz Naturel" style="height: 20px; vertical-align: middle;">
            </span>`);
        }
        if (params.isUsbPlugs) {
            badges.push(`<span style="padding: 6px 10px; background: linear-gradient(45deg, #5856d677, #4b42d077); color: white; border-radius: 10px;">⚡ USB</span>`);
        }
        if (params.isAirConditioned) {
            badges.push(`<span style="padding: 6px 10px; background: linear-gradient(45deg, #ADD8E677, #91c1d477); color: black; border-radius: 10px;">❄️ Climatisé</span>`);
        }
        if (params.isHeatingUnit) {
            badges.push(`<span style="padding: 6px 10px; background: linear-gradient(45deg, #C21E5677, #9b164777); color: white; border-radius: 10px;">🌡️ Chauffé</span>`);
        }
        
        if (badges.length > 0) {
            html += `<div class="vehicle-badges">${badges.join(' ')}</div>`;
        }
    } else {
        html = `<span>🚎 Un bus</span>`;
    }
    
    return html;
}

async function initializeApp() {
    try {
        toastBottomRight.info('Chargement async...');
        
        for (const key in vehicleTypes) {
            vehicleTypes[key] = new Set();
        }
        
        await loadVehicleModels();
        
        await fetchVehiclePositions();
    } catch (error) {
        console.error('BECAB Launcher : erreur lors de l\'initialisation :', error);
        toastBottomRight.error('BECAB Launcher : erreur lors de l\'initialisation :', error);

    }
}

let gtfsInitialized = false;


async function fetchVehiclePositions() {

    if (!gtfsInitialized) {
        console.log("fetchVehiclePositions: GTFS pas encore initialisé, attente...");
        return; 
    }
    try {
        const response = await fetch('proxy-cors/proxy_vehpos.php');
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);

        const activeVehicleIds = new Set();

        data.entity.forEach(entity => {
            const vehicle = entity.vehicle;
            if (vehicle) {
                const id = vehicle.vehicle.id;
                const vehicleOptionsBadges = getVehicleOptionsBadges(id);
                const vehicleBrandHtml = getVehicleBrandHtml(id);
                const line = vehicle.trip && vehicle.trip.routeId ? vehicle.trip.routeId : 'Inconnu';
                const directionId = vehicle.trip ? vehicle.trip.directionId : undefined;
                activeVehicleIds.add(id);

                const statusMap = {
                    0: '❌ Hors service commercial',
                    1: ' En service - Portes ouvertes',
                    2: ' En service'
                };
                const status = statusMap[vehicle.currentStatus] || 'Inconnu';

                const stopIdun = vehicle.stopId || 'Inconnu';
                let stopId = stopIdun.replace("0:", "");
                const latitude = vehicle.position.latitude;
                const longitude = vehicle.position.longitude;

                if (isNaN(latitude) || isNaN(longitude)) {
                    return; 
                }

                const speed = vehicle.position.speed ? (vehicle.position.speed).toFixed(0) + ' km/h' : 'Arrêté';
                const bearing = vehicle.position.bearing || 'Inconnu';
                const tripId = vehicle.trip && vehicle.trip.tripId ? vehicle.trip.tripId : 'Inconnu';

                const lastStopId = tripUpdates[tripId] ? tripUpdates[tripId].lastStopId : 'Inconnu';
                const lastStopNameun = stopNameMap[lastStopId] || 'inconnue';
                let lastStopName = lastStopNameun.replace("0:", "");
                
                const nextStops = tripUpdates[tripId]?.nextStops || [];

                let currentStopIndex = nextStops.findIndex(stop => stop.stopId.replace("0:", "") === stopId.replace("0:", ""));

                let nextStopsHTML = `
                    <div style="position: relative; max-height: 120px; ">  <!-- Conteneur avec fond au bas -->
                        <ul style="padding: 0; margin: 0; list-style-type: none; max-height: 120px; ">
                `;

                if (currentStopIndex !== -1) {
                    let filteredStops = nextStops.slice(currentStopIndex);  // Filtre arrêts à partir arrêt actuel

                    filteredStops.forEach(stop => {
                        nextStopsHTML += `
                            <li style="list-style: none; padding: 0px; display: flex; justify-content: space-between;">
                    <div>${stopNameMap[stop.stopId] || stop.stopId}</div>
                    <div>
                    <div>${stop.departureTime ? `${stop.departureTime}` : "Inconnu"}</div>
                    <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss -rotate-90 mr-[0.5px] text-green-700 dark:text-green-500"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>
                </div>
                </li>
                        `;
                    });
                } 

                nextStopsHTML += `
                        </ul>
                    </div>
                `;

                const popupContentElement = document.querySelector('#popup-content'); 
                if (popupContentElement) {
                    popupContentElement.innerHTML = `
                        <div style="padding: 10px; background: #f9f9f9; border-top: 1px solid #ddd;">
                            <h4 style="margin: 0; font-size: 16px; font-weight: bold;">Heures de passage prévues :</h4>
                            ${nextStopsHTML}
                        </div>
                    `;
                }

                const delayInfo = tripUpdates[tripId] ? tripUpdates[tripId].stopUpdates.find(update => update.stopId === stopId) : null;

                const arrivalDelay = delayInfo ? delayInfo.arrivalDelay : 0; 
                const scheduledArrival = delayInfo ? delayInfo.scheduledArrival : null; 
                                
                function getTextColorForBackground(bgColor) {
                    const color = bgColor.replace('#', '');
                    const r = parseInt(color.substring(0, 2), 16);
                    const g = parseInt(color.substring(2, 4), 16);
                    const b = parseInt(color.substring(4, 6), 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    return brightness > 150 ? '#000000' : '#FFFFFF';
                }

                const backgroundColor = lineColors[line] || '#000000';
                const textColor = getTextColorForBackground(backgroundColor);

                let arrivalTime = 'Inconnu';
                if (scheduledArrival) {
                    const arrivalDate = new Date(scheduledArrival * 1000);
                    arrivalTime = arrivalDate.toLocaleTimeString();
                }

                let delayMessage = 'À l\'heure';
                if (arrivalDelay > 0) {
                    delayMessage = `En retard de ${arrivalDelay} secondes`;
                } else if (arrivalDelay < 0) {
                    delayMessage = `En avance de ${Math.abs(arrivalDelay)} secondes`;
                }

                let remainingTimeMessage = 'terminus arrivée.';
                if (nextStops.length > 1) {
                    const penultimateStop = nextStops[nextStops.length - 2]; // avant der arrêt
                    const scheduledArrivalPenultimate = penultimateStop.departureTime;

                    if (scheduledArrivalPenultimate && scheduledArrivalPenultimate.includes(":")) {
                        const [hours, minutes] = scheduledArrivalPenultimate.split(':').map(num => parseInt(num, 10));

                        const now = new Date();
                        const scheduledArrivalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);

                        const currentTime = new Date();
                        const timeRemaining = Math.max(scheduledArrivalDate - currentTime, 0);
                        const minutesRemaining = Math.floor(timeRemaining / 60000);
                        const secondsRemaining = Math.floor((timeRemaining % 60000) / 1000);

                        remainingTimeMessage = ` ${minutesRemaining} minutes.`;
                    } else {
                        remainingTimeMessage = ' délai inconnu';
                    }
                }
                
                const popupContent = `
                    <div style="position: relative; font-family: 'League Spartan', sans-serif; font-size: 14px; line-height: 1.4; color: #333; border-radius: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); overflow: hidden; background-color: ${backgroundColor}77; color: ${textColor}; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">
                        
                        <!-- En-tête avec numéro de parc en arrière-plan -->
                <div style="position: relative; padding: 10px; color: ${textColor}; text-align: center; overflow: hidden; display: flex; justify-content: space-between; align-items: center; box-shadow: 0px 4px 20px 5px rgba(0, 0, 0, 0.3); border-radius: 11px; margin: 7px; ">
                    <!-- Texte principal -->
                    <div style="z-index: 2; text-align: right; width: 100%;">
                        <p style="margin: 0; font-size: 24px; ">Ligne ${lineName[line] || "interne au réseau"}</p>
                        <strong style="margin: 0; font-size: 14px;">➜ ${lastStopName}</strong>
                        <p style="margin: 0; font-size: 14px; ">🏁 Arrivée au terminus dans ${remainingTimeMessage}</p>
                    </div>

                    <!-- Texte en arrière-plan -->
                    <div style="
                        position: absolute;
                        right: 10px;
                        top: 0;
                        bottom: 0;
                        z-index: 1;
                        opacity: 0.1;
                        font-size: 100px;
                        font-weight: bold;
                        color: ${textColor};
                        display: flex;
                        align-items: center;
                        justify-content: flex-end;
                        white-space: nowrap;
                    ">
                        Ligne ${lineName[line] || "🚌🚍🚌🚍🚌🚍🚌"}
                    </div>
                </div>

                <div style="margin-right: 10px; margin-top: 10px; margin-bottom: 5px; text-align: right;">
                ${vehicleBrandHtml}
                </div>

                <div style="padding: 0 10px 0px 10px;">
                    <div style="position: relative; display: flex; align-items: center; ">
                        <!-- Conteneur pour le texte défilant avec effet fondu -->
                        <div style="
                            position: relative;
                            flex: 1;
                            overflow: hidden;
                            border-radius: 10px;
                        ">
                            <!-- Contenu défilant horizontalement -->
                            <div style="
                                display: flex;
                                gap: 10px;
                                padding: 0px;
                                white-space: nowrap;
                                overflow-x: auto;
                                scrollbar-width: thin; 
                                scrollbar-color: #888 #f1f1f1;
                            " class="custom-scrollbar">
                                <!-- Numéro de parc -->
                                <span style="
                                    background: #00000077;
                                    color: #ffffff;
                                    padding: 6px 12px;
                                    border-radius: 10px;
                                    font-weight: normal;
                                    font-size: 14px;
                                    white-space: nowrap;
                                    -webkit-backdrop-filter: blur(8px); 
                                ">
                                    Véhicule ${vehicle.vehicle.label}
                                </span>
                                
                                <!-- Badges des options du véhicule -->
                                ${vehicleOptionsBadges}
                            </div>
                        </div>
                    </div>
                </div>

                <div style="padding-top: 10px; padding-left: 10px; padding-right: 10px; color: ${textColor};">
                    <p style="margin: 0; font-size: 18px; text-align: right;">Prochains arrêts</p>
                    <ul>
                    <div id="nextStopsContent" class="next-stops-content">
                          ${nextStopsHTML}
                    </div>   
                </div>
                </div>
                `;
if (markers[id]) {
    animateMarker(markers[id], [latitude, longitude]);

    const existingPopup = markers[id].getPopup();
    const currentContent = existingPopup ? existingPopup.getContent() : '';

    if (existingPopup && currentContent === popupContent) {
        return;
    }

    markers[id].setPopupContent(popupContent);

    if (markers[id].isPopupOpen()) {
        const popupElement = markers[id]._popup._contentNode.parentElement;
        popupElement.classList.remove('hide'); 
        popupElement.classList.add('show'); 

        markers[id].openPopup();
    }
} else {
    const marker = createColoredMarker(latitude, longitude, line).addTo(map);
    markers[id] = marker;
    markers[id].line = line;
    markers[id].id = id;

    marker.bindPopup(popupContent);

    marker.on('popupopen', function (e) {
        const popupElement = e.popup._contentNode.parentElement;
        popupElement.classList.remove('hide'); 
        popupElement.classList.add('show');  

    });

    marker.on('popupclose', function (e) {
        const popupElement = e.popup._contentNode.parentElement;

        popupElement.classList.remove('show');
        popupElement.classList.add('hide');


        setTimeout(() => {
            e.popup.remove(); 
        }, 200); 
    });
}

                    }
                });

                Object.keys(markers).forEach(id => {
            if (!activeVehicleIds.has(id)) {
                map.removeLayer(markers[id]); 
                delete markers[id]; 
            }
        });

				
        let isMenuVisible = true;

const favoriteLines = new Set(JSON.parse(localStorage.getItem('favoriteLines') || '[]'));

const ANIMATION_CONFIG = {
    DURATION: 400,
    POP_DURATION: 100,
    SPRING_TIMING: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    SCALE_UP: 1.03,
    ITEM_MARGIN: 10
};


let isAnimating = false;

function getAbsolutePositions(menu) {
    const sections = Array.from(menu.querySelectorAll('.linesection'));
    const positions = new Map();
    let accumulatedHeight = 0;
    
    sections.forEach(section => {
        const rect = section.getBoundingClientRect();
        positions.set(section, {
            top: accumulatedHeight,
            height: rect.height,
            index: sections.indexOf(section)
        });
        accumulatedHeight += rect.height + ANIMATION_CONFIG.ITEM_MARGIN;
    });
    
    return { sections, positions };
}

function getTargetIndex(sections, movingSection, isFavorite, favoriteLines) {
    const movingLine = movingSection.dataset.line;
    
    if (isFavorite) {
        const firstNonFavoriteIndex = sections.findIndex(section => 
            !favoriteLines.has(section.dataset.line)
        );
        
        if (firstNonFavoriteIndex === sections.indexOf(movingSection)) {
            return -1;
        }
        
        return firstNonFavoriteIndex === -1 ? sections.length : firstNonFavoriteIndex;
    } else {
        let targetIndex = 0; 
        
        for (let i = 0; i < sections.length; i++) {
            const sectionLine = sections[i].dataset.line;
            
            if (favoriteLines.has(sectionLine)) {
                const movingNum = parseInt(movingLine);
                const sectionNum = parseInt(sectionLine);
                
                if (!isNaN(movingNum) && !isNaN(sectionNum)) {
                    if (movingNum < sectionNum) {
                        return i;
                    }
                } else if (movingLine.localeCompare(sectionLine) < 0) {
                    return i;
                }
            } else {
                return i; 
            }
        }
        
        return sections.length;
    }
}

function prepareSectionsForAnimation(sections) {
    sections.forEach(section => {
        section.style.transition = 'none';
        section.style.position = 'relative';
        section.style.zIndex = '1';
        section.style.transform = 'translateY(0)';
    });
    
    // Force reflow
    sections[0].offsetHeight;
}

async function animateFavoriteTransition(button, lineSection, line, isFavorite) {
    if (isAnimating) return;
    isAnimating = true;
    
    const menu = document.getElementById('menu');
    if (!menu || !lineSection) return;
    
    try {
        menu.style.pointerEvents = 'none';
        button.style.pointerEvents = 'none';
        
        const { sections, positions } = getAbsolutePositions(menu);
        const currentIndex = sections.indexOf(lineSection);
        
        if (isFavorite) {
            favoriteLines.delete(line);
        } else {
            favoriteLines.add(line);
        }
        
        const targetIndex = getTargetIndex(sections, lineSection, isFavorite, favoriteLines);
        
        if (targetIndex === -1 || currentIndex === -1 || targetIndex === currentIndex) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            try {
                localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
            } catch (error) {
                console.error('Error saving favorite', error);
            }
            await cleanup(menu, button);
            return;
        }
        
        if (isFavorite) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            button.innerHTML = '☆';
        } else {
            await animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
        }
        
        try {
            localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
        } catch (error) {
            console.error('Error saving favorite', error);
        }
        
    } catch (error) {
        console.error('Animation err', error);
    } finally {
        await cleanup(menu, button);
    }
}

async function animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    for (let i = 0; i < targetIndex; i++) {
        if (i !== currentIndex) {
            const section = sections[i];
            const sectionPos = positions.get(section);
            targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = 0;
            
            if (currentIndex < targetIndex) {
                if (index > currentIndex && index <= targetIndex) {
                    displacement = -(currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
                }
            } else {
                if (index >= targetIndex && index < currentIndex) {
                    displacement = currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
                }
            }
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    lineSection.style.transform = `scale(1.05)`;
    await new Promise(r => setTimeout(r, 100));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1.05)`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1)`;
    
    button.innerHTML = '★';
    button.style.transform = 'scale(1.2)';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

async function animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    if (targetIndex === -1) {
        targetIndex = sections.length;
        sections.forEach((section, idx) => {
            if (idx !== currentIndex) {
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        });
    } else {
        for (let i = 0; i < targetIndex; i++) {
            if (i !== currentIndex) {
                const section = sections[i];
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = calculateDisplacement(index, currentIndex, targetIndex, 
                currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    await animateMovingSection(lineSection, deltaY);
    
    button.style.transform = 'scale(0.8)';
    button.innerHTML = '☆';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

function calculateDisplacement(index, currentIndex, targetIndex, sectionHeight) {
    if (targetIndex === -1) {
        return index > currentIndex ? -sectionHeight : 0;
    }
    
    if (currentIndex < targetIndex) {
        return (index > currentIndex && index <= targetIndex) ? -sectionHeight : 0;
    } else {
        return (index >= targetIndex && index < currentIndex) ? sectionHeight : 0;
    }
}

async function animateMovingSection(section, deltaY) {
    section.style.transform = `scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.POP_DURATION));
    
    section.style.transform = `translateY(${deltaY}px) scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    
    section.style.transform = `translateY(${deltaY}px) scale(1)`;
}


function updateFavoriteState(button, line, isFavorite) {
    if (isFavorite) {
        favoriteLines.delete(line);
        button.innerHTML = '☆';
    } else {
        favoriteLines.add(line);
        button.innerHTML = '★';
    }
    
    try {
        localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
    } catch (error) {
        console.error('Error saving favorite', error);
    }
}



async function cleanup(menu, button) {
    await new Promise(r => setTimeout(r, 50));
    
    const sections = menu.querySelectorAll('.linesection');
    sections.forEach(section => {
        section.style.transform = '';
        section.style.transition = '';
        section.style.zIndex = '';
        section.style.position = '';
    });
    
    menu.style.pointerEvents = 'auto';
    button.style.pointerEvents = 'auto';
    
    updateMenu();
    isAnimating = false;
}

const animationStyle = document.createElement('style');
animationStyle.textContent = `
    .linesection {
        transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
    }
    
    .linesection.removing {
        animation: remove-favorite 0.3s ease-out forwards;
    }
    
    @keyframes remove-favorite {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .favorite-button {
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
    
    .favorite-button:hover {
        transform: scale(1.1);
    }
    
    .favorite-button:active {
        transform: scale(0.9);
    }
`;
document.head.appendChild(animationStyle);


function updateMenu() {
    const menu = document.getElementById('menu');
    menu.innerHTML = '';



    const logoContainer = document.createElement('div');
    logoContainer.style.textAlign = 'center';
    logoContainer.style.marginBottom = '7px';

    const logo = document.createElement('img');
    logo.src = 'src/whitelogo.png'; 
    logo.alt = 'Logo de My Bus Finder';
    logo.style.maxWidth = '200px';
    logo.style.display = 'block';
    logo.style.margin = '0 auto';
    logo.style.cursor = 'pointer';
    logo.onclick = () => {
        showUpdatePopup('updatecm.html');
        musique();
    };

    logoContainer.appendChild(logo);
    menu.appendChild(logoContainer);

    const now = new Date();
    const currentHour = now.getHours();
    const currentMinutes = now.getMinutes();
    const totalMinutes = currentHour * 60 + currentMinutes;

    let transportState = "normal";
    if ((totalMinutes >= 420 && totalMinutes <= 510) || (totalMinutes >= 960 && totalMinutes <= 1050)) {
        transportState = "presque saturé"; 
    } else if ((totalMinutes > 510 && totalMinutes <= 570) || (totalMinutes > 1020 && totalMinutes <= 1110)) {
        transportState = "saturé";
    }

    const transportStateContainer = document.createElement('div');
    transportStateContainer.style.display = 'flex';
    transportStateContainer.style.alignItems = 'center';
    transportStateContainer.style.justifyContent = 'center';
    transportStateContainer.style.marginBottom = '10px';

    const transportImage = document.createElement('img');
    transportImage.alt = 'Affluence transports';
    transportImage.style.width = '50px';
    transportImage.style.height = '36px';
    transportImage.style.marginRight = '10px';

    if (transportState === "normal") {
        transportImage.src = 'src/1of3body.png';
        transportStateContainer.addEventListener('click', () => {
            toastBottomRight.info('Ouf ! Aucune affluence notable est à signaler. Profitez bien de votre voyage !');
        });
        transportStateContainer.style.cursor = 'pointer';

    } else if (transportState === "presque saturé") {
        transportImage.src = 'src/2of3body.png';
        transportStateContainer.addEventListener('click', () => {
            toastBottomRight.info('Les gens rentrent chez eux, ça se corse... Mais on peut toujours voyager sereinement.');
        });

        transportStateContainer.style.cursor = 'pointer';

    } else if (transportState === "saturé") {
        transportImage.src = 'src/3of3body.png';
        transportStateContainer.addEventListener('click', () => {
            toastBottomRight.info('En heure de pointe, il est compliqué de se déplacer. Privilégiez les lignes secondaires.');
    });
    
        transportStateContainer.style.cursor = 'pointer';
    }

    const transportStateTextContainer = document.createElement('div');
    transportStateTextContainer.style.textAlign = 'left';

    const transportStateLabel = document.createElement('div');
    transportStateLabel.textContent = "Affluence transports";
    transportStateLabel.style.fontSize = '14px';
    transportStateLabel.style.marginTop = '7px';
    transportStateLabel.style.color = '#fff';

    const transportStateText = document.createElement('div');
    transportStateText.textContent = transportState.charAt(0).toUpperCase() + transportState.slice(1);
    transportStateText.style.fontSize = '22px';
    transportStateText.style.fontWeight = 'bold';
    transportStateText.style.color = '#fff';

    transportStateTextContainer.appendChild(transportStateLabel);
    transportStateTextContainer.appendChild(transportStateText);

    transportStateContainer.appendChild(transportImage);
    transportStateContainer.appendChild(transportStateTextContainer);
    menu.appendChild(transportStateContainer);

    const busesByLineAndDestination = {};

    Object.keys(markers).forEach(id => {
        const vehicle = markers[id];
        const line = vehicle.line;
        const destination = vehicle.getPopup().getContent().match(/Destination\s*<strong.*?>(.*?)<\/strong>/)?.[1] || "Inconnue";

        if (!busesByLineAndDestination[line]) {
            busesByLineAndDestination[line] = {};
        }

        if (!busesByLineAndDestination[line][destination]) {
            busesByLineAndDestination[line][destination] = [];
        }

        busesByLineAndDestination[line][destination].push({
            parkNumber: vehicle.id,
            vehicle
        });
    });

    const sortedLines = Object.keys(busesByLineAndDestination)
        .sort((a, b) => {
            const aIsFavorite = favoriteLines.has(a);
            const bIsFavorite = favoriteLines.has(b);
            
            if (aIsFavorite && !bIsFavorite) return -1;
            if (!aIsFavorite && bIsFavorite) return 1;
            
            return isNaN(a) ? (isNaN(b) ? a.localeCompare(b) : 1) : (isNaN(b) ? -1 : parseInt(a) - parseInt(b));
        });

    sortedLines.forEach(line => {
        const lineNameText = lineName[line] || "Inconnue";
        const lineColor = lineColors[line] || '#000000';

        const lineSection = document.createElement('div');
        lineSection.dataset.line = line;
        lineSection.style.backgroundColor = lineColor;
        lineSection.classList.add('linesection');
        lineSection.style.marginBottom = '10px';
        lineSection.style.padding = '10px';
        lineSection.style.borderRadius = '8px';
        lineSection.style.position = 'relative';
        const favoriteButton = document.createElement('button');
        favoriteButton.style.position = 'absolute';
        favoriteButton.style.right = '5px';
        favoriteButton.style.top = '5px';
        favoriteButton.style.background = 'none';
        favoriteButton.style.border = 'none';
        favoriteButton.style.color = '#fff';
        favoriteButton.style.fontSize = '20px';
        favoriteButton.style.cursor = 'pointer';
        favoriteButton.innerHTML = favoriteLines.has(line) ? '★' : '☆';
        favoriteButton.onclick = async (e) => {
    e.stopPropagation();
    const lineSection = e.target.closest('.linesection');
    const isFavorite = favoriteLines.has(line);
    await animateFavoriteTransition(e.target, lineSection, line, isFavorite);
};
const lineTitle = document.createElement('div');
        lineTitle.textContent = `Ligne ${lineNameText}`;
        lineTitle.style.fontSize = '18px';
        lineTitle.style.fontWeight = 'bold';
        lineTitle.style.color = '#fff';
        lineTitle.style.paddingRight = '30px';

        lineSection.appendChild(lineTitle);
        lineSection.appendChild(favoriteButton);

        Object.keys(busesByLineAndDestination[line])
            .sort()
            .forEach(destination => {
                const destinationSection = document.createElement('div');
                destinationSection.style.marginTop = '5px';
                destinationSection.style.paddingLeft = '10px';

                const destinationTitle = document.createElement('div');
                destinationTitle.textContent = `➜ ${destination}`;
                destinationTitle.style.fontSize = '16px';
                destinationTitle.style.fontWeight = 'bold';
                destinationTitle.style.color = '#fff';
                destinationSection.appendChild(destinationTitle);

                busesByLineAndDestination[line][destination].forEach(bus => {
                    const busItem = document.createElement('div');
                    busItem.textContent = `Bus ${bus.parkNumber}`;
                    busItem.style.cursor = 'pointer';
                    busItem.classList.add('menu-item');
                    busItem.style.fontFamily = 'League Spartan';
                    busItem.style.color = 'white';
                    busItem.style.padding = '5px 10px';
                    busItem.style.marginBottom = '5px';
                    busItem.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
                    busItem.style.borderRadius = '8px';

                    lineSection.onclick = () => {
                        const lineId = line;
                        selectedLine = lineId;
                        filterByLine(lineId);
                        menu.style.display = 'none';
                        isMenuVisible = false;
                        const filtre = document.getElementById('filtre');
                        menubottom1.style.display = 'flex';
                        setTimeout(() => {
                            menubottom1.classList.remove('slide-upb');
                            menubottom1.classList.add('slide-downb');
                            filtre.classList.remove('slide-upc');
                            filtre.classList.add('slide-downc');
                        }, 10);
                    };

                    busItem.onclick = () => {
                        map.setView(bus.vehicle.getLatLng(), 17);
                        bus.vehicle.openPopup();
                        menu.style.display = 'none';
                        isMenuVisible = false;
                        if (selectedLine) {
                            resetMapView();
                        }
                        event.stopPropagation();
                    };

                    destinationSection.appendChild(busItem);
                });

                lineSection.appendChild(destinationSection);
            });

        menu.appendChild(lineSection);
    });
}

const menubottom1 = document.getElementById('menubtm');


        function showMenu() {
            const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            const locate = document.getElementById('locate');
            menu.style.display = 'block'; 
            isMenuVisible = true; 
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            locate.classList.add('slide-upc');
            locate.classList.remove('slide-downc');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        resetMapView();
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });

        }

        const menubutton = document.getElementById('menubutton');
        menubutton.onclick = showMenu; 


        const closeMap = document.getElementById('map');
        closeMap.onclick = () => {
            menu.style.display = 'none'; 
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);
    
        };

        updateMenu();

    } catch (error) {
        console.error('Err récup des données ! ', error);
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : no vehicle found on realtime data');

    }
}




let lastTripUpdateTimestamp = 0;
const worker = new Worker('worker.js');

async function fetchTripUpdates() {
    try {
        const response = await fetch('proxy-cors/proxy_tripupdate.php');
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);

        return new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                tripUpdates = e.data; 
                resolve(e.data);
            };
            
            worker.onerror = (error) => {
                reject(new Error(`Erreur du worker: ${error.message}`));
            };
            
            worker.postMessage(data);
        });
    } catch (error) {
        console.error('Err récup trip updates !', error);
        throw error;
    }
}

async function main() {
    try {                
        const gtfsData = await initializeGTFS();
        gtfsInitialized = true;
        
        await loadGeoJsonLines();
        
        await Promise.all([
            fetchVehiclePositions(),
            hideLoadingScreen(),
            fetchTripUpdates().catch(console.error)
            ]);
        


        function fetchRegularUpdates() {
            fetchVehiclePositions();
            fetchTripUpdates().catch(console.error);
            setTimeout(fetchRegularUpdates, 8000);
        }
        
        setTimeout(fetchRegularUpdates, 8000);
        
    } catch (error) {
        console.error("Erreur dans main():", error);
        showErrorMessage("Erreur de chargement des données. Veuillez rafraîchir la page.");
    }
}

document.addEventListener('DOMContentLoaded', main);
    </script>
</html>
