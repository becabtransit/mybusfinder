<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="MyBusFinder">
	<link rel="canonical" href="https://mybusfinder.fr">
	<link rel="apple-touch-icon" href="src/logo.png">
    <title>MyBusFinder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protobufjs/6.11.2/protobuf.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <meta name="google-adsense-account" content="ca-pub-5815761294049475">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
    html, body {
        height: var(--app-height);
        width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 0;
        font-family: 'League Spartan', sans-serif;
        background-color: #c7c7c7; 
        color: #333; 
        transition: background-color 0.5s ease; 
        margin: 0;
        overflow: hidden;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none; 
        touch-action: manipulation; 
        overscroll-behavior: none;
    }

    @font-face {
        font-family: 'League Spartan';
        src: url('src/fonts/leaguespartan.ttf') format('truetype');
    }

    @font-face {
        font-family: 'SegoeUIBoot';
        src: url('src/fonts/SegoeUIBoot.woff2') format('woff2'),
            url('src/fonts/SegoeUIBoot.woff') format('woff');
        font-weight: normal;
        font-style: normal;
    }

    #map {
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        left: 0;
    }
        
        
    .update-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 10001;
        background-color: rgba(255, 255, 255, 0.5); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        overflow-y: hidden;
    }

    .popup-content {
        background: white;
        width: 100%;
        height: 100%;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        position: relative;
    }

    .time-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 10001;
        background-color: rgba(255, 255, 255, 0.5); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        overflow-y: hidden;
    }

    .time-content {
        background: white;
        width: 100%;
        height: 100%;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        position: relative;
    }


    .timepopup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        opacity: 95%;
        height: 100%;
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 10001;
        background-color: rgba(255, 255, 255, 0.5); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
    }

    .leaflet-popup-content-wrapper, .leaflet-popup-tip {
    background-color: transparent;
    border-radius: 15px;
    box-shadow: none !important;
    padding: 0px 0px 0px 0px;
    transform: scale(0.8) translateY(20px); 
    opacity: 0; 
    filter: blur(13px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform-origin: center bottom;
    }

    .leaflet-popup-content-wrapper.show, .leaflet-popup-tip.show {
    transform: scale(1) translateY(0); 
    opacity: 1; 
    filter: blur(0); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    }

    .leaflet-popup-content-wrapper.hide, .leaflet-popup-tip.hide {
    transform: scale(0.8) translateY(20px); 
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
    }

    .leaflet-popup-content {
    margin: 0px;
    width: 400px;
    }


    .leaflet-popup-close-button {
    visibility: hidden;
    }

    .popup-zoom-in {
        transform: scale(1) translateY(0px); 
        opacity: 1;
    }

    .popup-zoom-out {
        transform: scale(0.9) translateY(20px); 
        opacity: 0;
    }

    #menubtm {
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out, background-color 0.5s ease;
    }




    @keyframes fadeInPopupSvc {
        from {
            opacity: 0;
            transform: translate(-50%, -20%);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%);
        }
    }

    @keyframes fadeOutPopupSvc {
        from {
            opacity: 1;
            transform: translate(-50%, -50%);
        }
        to {
            opacity: 0;
            transform: translate(-50%, -20%);
        }
    }

    @keyframes fadeInPopup {
        from {
            opacity: 0;
            transform: translate(0%, 30%);
        }
        to {
            opacity: 1;
            transform: translate(0%, 0%);
        }
    }

    @keyframes fadeOutPopup {
        from {
            opacity: 1;
            transform: translate(0%, -30%);
        }
        to {
            opacity: 0;
            transform: translate(0%, 0%);
        }
    }

    .custom-scrollbar::-webkit-scrollbar {
        height: 8px; 
    }
    .custom-scrollbar::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #888;
        border-radius: 10px;
        border: 2px solid #f1f1f1;
    }

    .custom-scrollbar {
        -webkit-overflow-scrolling: touch;
    }

                
    .popup-content h2 {
        font-size: 24px;
        font-family: 'League Spartan', sans-serif;
        color: #333;
        margin-bottom: 15px;
    }

    #update-notes {
        font-family: 'League Spartan', sans-serif;
        font-size: 16px;
        color: #555;
        line-height: 1;
    }

    #update-notes li {
        margin-bottom: 10px;
    }



    #menu {
        position: absolute;
        top: 0px;
        right: 0px;
        border-radius: 0px 0px 0px 0px;
        z-index: 1000;
        height: 100%;
        width: 100%; 
        overflow-y: auto;
        transition: all 0.3s ease;
        display: none;
    }

    @media screen and (min-width: 1024px) {
        #menu {
            width: auto;
        }
    }

    .ripple {
        position: relative;
        overflow: hidden;
    }

    .ripple::after {
        content: '';
        position: absolute;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        transform: scale(0);
        opacity: 0;
        animation: ripple-animation 0.6s linear forwards;
    }

    @keyframes ripple-animation {
        to {
            transform: scale(4);
            opacity: 1;
        }
    }

    ul {
        padding: 0;
        margin: 0;
        list-style-type: none;
        padding-inline-start: 0;
    }


    .menu-item {
        cursor: pointer;
        padding: 6px;
        transition: background-color 0.3s ease; 
        border-radius: 5px;
        z-index: 100000;
    }

    .menu-item:hover {
        background-color: #0000001f; 
        animation: jspcommentlappelercettekeyframe 0.1s linear forwards;
    }

    .linesection {
        cursor: pointer;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
    }

    @keyframes jspcommentlappelercettekeyframe {
        to {
            opacity: 0.9;
        }
    }

    .popup-content {
        font-family: 'League Spartan', sans-serif;
        font-size: 12px;
        line-height: 1.1;
    }

    .popup-header {
        padding: 5px;
        border-radius: 10px;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }





    @keyframes textFadeIn {
        0% {
            opacity: 0;
            transform: translateY(20px);
        }
        100% {
            opacity: 1;
            transform: translateY(0); 
        }
    }

    .loading-animation {
        font-family: 'League Spartan', sans-serif;
        font-size: 50px;  
        font-weight: bold;
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0); 
        -webkit-background-clip: text;
        color: transparent;
        animation: gradientTextAnimation 3s ease infinite; 
    }


    .share-btn, .donate-btn {
        animation: pulse 2s infinite;
    }
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    @keyframes slideInBounce {
        0% {
            transform: translateX(50%); 
            opacity: 0;
        }
        100% {
            transform: translateX(0%); 
            opacity: 1;
        }
    }

    @keyframes slideInBounceM {
        0% {
            transform: translateX(-50%); 
            opacity: 0;
        }
        100% {
            transform: translateX(0%); 
            opacity: 1;
        }
    }

    @keyframes slideInBounceInv {
        0% {
            transform: translateX(0%); 
            opacity: 1;
            }
        100% {
            transform: translateX(50%); 
            opacity: 0;
        }
    }



    @keyframes slideInBounceInvM {
        0% {
            transform: translateX(0%); 
            opacity: 1;
            filter: blur(0px);
            }
        100% {
            transform: translateX(-50%); 
            opacity: 0;
            filter: blur(0px);
        }
    }

    @keyframes appearDepuisLAccueil {
        0% {
            transform: translateX(-50%); 
            opacity: 0;
            filter: blur(0px);
            }
        100% {
            transform: translateX(0%); 
            opacity: 1;
            filter: blur(0px);
        }
    }

    @keyframes slideInBounceInvMBlur {
        0% {
            filter: blur(0px);
            scale: 1;
            }
        100% {
            scale: 1.2;
            filter: blur(2px);
        }
    }

    @keyframes slideInBounceInvMBlurRev {
        0% {
            scale: 1.2;
            filter: blur(2px);
            }
        100% {
            filter: blur(0px);
            scale: 1;
        }
    }

    #menu {
    animation: slideInBounce 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }

    #accueil {
        width: 100%;
        height: 100%;
        z-index: 9999;
    }

    #accueil.hide {
        animation: accueilCache 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
    }

    #accueil.affiche {
        animation: accueilAffiche 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
    }

    @keyframes accueilCache {
        0% {
            scale: 1;
            opacity: 1;
            filter: blur(0px);
            }
        100% {
            scale: 0.8;
            opacity: 0;
            filter: blur(10px);
        }
    }

    @keyframes accueilAffiche {
        0% {
            scale: 0.8;
            opacity: 0;
            filter: blur(10px);
            }
        100% {
            scale: 1;
            opacity: 1;
            filter: blur(0px);
        }
    }



    #map.appear {
        animation: slideInBounceM 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
    }

    #map.appeardelaccueil {
        animation: appearDepuisLAccueil 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
    }

    #menu.hidden {
    animation: slideInBounceInv 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }

    #map.hidden {
    animation: slideInBounceInvM 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }

    #map.hiddennotransition {
    animation: slideInBounceInvMBlur 1.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }

    #map.appearnotransition {
    animation: slideInBounceInvMBlurRev 1.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
    }

    @keyframes bounceIn {
        0% {
            transform: scale(0.9);
            opacity: 0.7;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .popup-content, .popup-content1, .time-content, .popup1 {
        animation: zoomFadeIn 0.6s cubic-bezier(0.25, 1.5, 0.5, 1) forwards;
    }

    @keyframes zoomFadeIn {
        0% {
            opacity: 0;
            transform: scale(0.8);
            filter: blur(13px); 

        }
        100% {
            opacity: 1;
            transform: scale(1);
            filter: blur(0); 
        }
    }


    .marker-icon {
        animation: zoomInOut 2s infinite;
    }

    @keyframes zoomInOut {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.13); }
    }


    span[style*="padding: 5px 10px;"] {
        animation: badgePulse 1.5s infinite;
    }
    @keyframes badgePulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    #nextStopsContent div {
        animation: fadeInScroll 0.3s ease-in;
        display: inherit;
    }
    @keyframes fadeInScroll {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .marker-icon:hover {
        animation: hoverBounce 0.3s ease-in-out;
    }
    @keyframes hoverBounce {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    .glass-effect {
        position: relative;
        overflow: hidden;
    }

    .glass-effect::before {
        content: '';
        position: absolute;
        top: 0;
        left: -140%;
        width: 140%;
        height: 100%;
        background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
        transform: skewX(-25deg);
    }

    .glass-effect.animate::before {
        animation: glass-slide 1s ease forwards;
    }

    @keyframes glass-slide {
        0% {
            left: -100%;
        }
        100% {
            left: 150%;
        }
    }
                
    @keyframes gradientTextAnimation {
        0% {
            background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
        }
        50% {
            background: linear-gradient(45deg, #ffffff, #f0f0f0, #ffffff);
        }
        100% {
            background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
        }
    }

    :root {
    --base_scale: 3vh;
    --floor: 15vh;
    --color: #836ee5;
    }


    input, textarea {
    user-select: text;
    }

    #loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        45deg,
        #000000,
        #1a1a1a,
        #242424
    );
    background-size: 200% 200%;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10000;
    animation: gradientAnimation 5s ease infinite;
    }

    @keyframes gradientAnimation {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
    }

    .shapes-container {
    width: 100%;
    overflow: hidden;
    }

    shape {
    position: absolute;
    display: block;
    left: 50%;
    bottom: 0;
    margin-left: calc(-1 * (var(--base_scale) / 2));
    margin-bottom: var(--floor);
    transform-origin: center;
    }

    shape.circle {
    width: var(--base_scale);
    height: var(--base_scale);
    background: var(--color);
    border-radius: 50%;
    }

    shape.semi-circle {
    width: var(--base_scale);
    height: calc(var(--base_scale) * 2);
    background: var(--color);
    border-bottom-right-radius: calc(var(--base_scale) * 2);
    border-top-right-radius: calc(var(--base_scale) * 2);
    }

    shape.square {
    width: var(--base_scale);
    height: var(--base_scale);
    background: var(--color);
    }

    shape.bounce-up {
    animation: bounceUp 600ms cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
    }

    shape.bounce-down {
    animation: bounceDown 600ms cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards;
    }

    @keyframes bounceUp {
    0% {
        transform: translateY(0) rotate(0deg);
    }
    100% {
        transform: translateY(-30vh) rotate(180deg);
    }
    }

    @keyframes bounceDown {
    0% {
        transform: translateY(-30vh) rotate(180deg);
    }
    100% {
        transform: translateY(0) rotate(360deg);
    }
    }

    #stop-suggestions li {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #ddd;
    }

    #stop-suggestions li:hover {
        background-color: #f4f4f4;
    }


    #loading-text {
    margin-top: 20px;
    font-size: 18px;
    color: black;
    animation: fadeIn 1.5s ease forwards;
    }

    @keyframes fadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
    }

    .filtre {
        display: none;
        position: absolute;
        bottom: 10px;
        left: 50%; 
        transform: translateX(-50%) translateY(-100%);
        opacity: 0; 
        filter: blur(5px); 
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
        padding: 10px 15px;
        border: none;
        list-style: none;
        margin: 0;
        z-index: 10000;
        background-color: #0F056B9c;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
        border-radius: 18px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        
    }

    .filtre-texte {
        color: #ffffff;
    }

    .menubottom-ul {
        display: flex;
        position: absolute;
        bottom: 10px;
        left: 50%; 
        transform: translateX(-50%);
        border: none;
        list-style: none;
        margin: 0;
        z-index: 10000;
        padding: 0px 9px;
        background-color: #0F056B9c;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5); 
        border-radius: 18px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        
    }

    .menubottom ul li {
        margin: auto; 
    }

    .menubottom ul li a {
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        font-size: 20px;
        font-family: League Spartan;
        text-decoration: none;
        height: 70px;
        width: 70px;
        position: relative;
        cursor: pointer;
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
            }

    .menubottom ul li a .icon {
        position: relative;
        font-size: 20px;
        transition: transform 0.2s ease-in-out;
        transition: .3s;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .menubottom ul li a .title {
        margin-bottom: 8px; 
        font-size: 14px;
        text-align: center;
        opacity: 1; 
        transition: none; 
    }

    .menubottom ul li a:hover .icon {
        transform: scale(0.8); 
    }

            .menubottom ul li a:active {
        transform: scaleX(70%)scaleY(70%); 
        background-color: rgba(255, 255, 255, 0); 
    }


    @keyframes barFadeIn {
        0% {
            opacity: 0;
            transform: translateY(60px); 
        }
        100% {
            opacity: 1;
            transform: translateY(0); 
        }
    }


                
    .next-stops-container {
        max-height: 100px;
        padding: 10px;
        background: #f9f9f9;
        border-top: 1px solid #ddd;
        position: relative;
    }

    .next-stops-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .next-stops-content {
        transition: max-height 0.3s ease, opacity 0.3s ease;
        opacity: 1;
        padding-inline-start: 0;
        list-style-type: none; 
        overflow-y: auto;
    }

    @media (max-width: 1024px) {
    .next-stops-content {
        scrollbar-width: none; 
    }

    .next-stops-content::-webkit-scrollbar {
        display: none;
    }
    }

    .popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: fadeInPopup 0.5s forwards;
        background-color: #ffffff; 
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
        max-height: 80%;
        width: 90%;
        max-width: 500px;
        z-index: 1001;
        overflow-y: auto;
        opacity: 0; 
    }

    .popup-content {
        text-align: center;
    }

    .close-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #333;
        color: white;
        border: none;
        padding: 10px;
        border-radius: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 16px;
        transition: background-color 0.3s;
    }

    .close-btn:hover {
        background-color: #555;
    }

    .textpop h4 {
        margin-bottom: 0.3rem;
    }

    .textpop h1 {
        margin-top: 0;
    }



    .slide-down {
    transform: translateY(0); 
    opacity: 1; 
    filter: blur(0); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    }

    .logoscr {
    transform: translateY(100px); 
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    }

    .popup-slide {
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
        transform: translateX(0);
        opacity: 1;
    }

    .popup-slide-hidden {
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
        transform: translateX(-30%);
        opacity: 0;
    }

    .popup-slide-right {
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
        transform: translateX(30%);
        opacity: 0;
    }

    .popup-slide-active {
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
        transform: translateX(0);
        opacity: 1;
    }



    .schedule-row {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
        padding: 5px;
        background: #f8f9fa;
        border-radius: 8px;
    }

    .schedule-row span {
        font-weight: bold;
        color: #333;
    }


    .logoscrapp {
    transform: translateY(0); 
    opacity: 1; 
    filter: blur(0); 
    }

    .logoscrappp {
    transform: scale(0.8); 
    filter: blur(0); 
    }

    .logoscrapppp {
    opacity: 0; 
    }

    @media (max-width: 600px) {
        #logoscr {
        width: 50%;  
        max-width: 200px;  
        }
    }

    @media (min-width: 1200px) {
        #logoscr {
        width: 10%;  
        max-width: 400px;  
        }
    }

    .slide-up {
    transform: translateY(-100%); 
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
    }

    .slide-downb {
    transform: translateY(0) translateX(-50%);
    opacity: 1; 
    filter: blur(0); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    }

    .slide-upb {
    transform: translateY(100%) translateX(-50%);
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.2s ease-in, filter 0.2s ease-in;
    }


    .slide-downc {
    transform: translateY(-220%) translateX(-50%);
    opacity: 1; 
    filter: blur(0); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    }

    .slide-upc {
    transform: translateY(100%) translateX(-50%);
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
    }

    #popup1::-webkit-scrollbar {
        width: 8px;
    }
    #popup1::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb:hover {
        background: #555;
    }


    @keyframes loadingBarAnimation {
        0% {
            width: 0%;
        }
        50% {
            width: 100%;
        }
        100% {
            width: 100%;
        }
    }


    .marker-icon:hover {
    transform: scale(0.8);
    transition: transform 0.2s ease;
    }



    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }

    @keyframes zoomOut {
        from {
            transform: scale(1);
            opacity: 1;
        }
        to {
            transform: scale(1.5);
            opacity: 0;
        }
    }

    @keyframes fadeColors {
        0% { background-color: rgb(0, 0, 0); }
        25% { background-color: rgb(0, 0, 168); }
        50% { background-color: rgb(0, 158, 158); }
        75% { background-color: rgb(155, 155, 0); }
        100% { background-color: rgb(0, 0, 0); }
    }

    .logobkg {
    transition: opacity 0.3s ease-out;
    }
    .loading-screen-fade {
        animation: fadeColors 1s ease-in; 
    }

    #webview-frame, #webview-frame1 {
        width: 100%;
        height: 100%;
    }

    .vehicle-model {
        display: flex;
        align-items: right;
        justify-content: flex-end;
        flex-direction: column;
    }

    .light-beam {
        position: absolute;
        width: 100px;
        height: 300px;
        background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 70%);
        transform-origin: top right;
        transform: rotate(-45deg);
        margin-top: -29%;
    }

    .beam1 {
        width: 90px;
        opacity: 0.9;
    }

    .beam2 {
        width: 70px;
        right: 60px;
        opacity: 0.7;
    }

    .beam3 {
        width: 40px;
        right: 120px;
        opacity: 0.5;
    }

    .title {
        color: white;
        font-size: 24px;
        font-weight: 300;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .shine {
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 70%);
        transform: rotate(45deg);
        pointer-events: none;
        opacity: 0.5;
    }

    .stops-timeline-menu {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        width: 90%;
        max-width: 400px;
        z-index: 1000;
        overflow: hidden;
        max-height: 80vh;
        display: none;
        opacity: 0;
        filter: blur(5px);
        transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                    opacity 0.3s ease-out,
                    filter 0.3s ease-out;
    }

    .stops-timeline-menu.visible {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
        filter: blur(0);
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease-out;
    }

    .overlay.visible {
        opacity: 1;
    }

    .show-in-map-btn {
        margin: 20px;
        padding: 12px;
        background: #363636;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        width: calc(100% - 40px);
        position: sticky;
        bottom: 0;
        transition: transform 0.3s ease, background-color 0.3s ease;
    }

    .show-in-map-btn:hover {
        background: #2c2c2c;
        transform: scale(0.98);
    }

    .show-in-map-btn:active {
        transform: scale(0.95);
    }

    .leaflet-control-locate a {
    cursor: pointer;
    }
    .leaflet-control-locate a .leaflet-control-locate-location-arrow {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin: 7px;
    background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
    }
    .leaflet-control-locate a .leaflet-control-locate-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin: 7px;
    background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M304 48a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48 368a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm208-208a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM96 256a48 48 0 1 0-96 0 48 48 0 0 0 96 0zm13 99a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm294 0a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM109 61a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"/></svg>');
    animation: leaflet-control-locate-spin 2s linear infinite;
    }
    .leaflet-control-locate.active a .leaflet-control-locate-location-arrow {
    background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(32, 116, 182)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
    }
    .leaflet-control-locate.following a .leaflet-control-locate-location-arrow {
    background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(252, 132, 40)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
    }

    .leaflet-touch .leaflet-bar .leaflet-locate-text-active {
    width: 100%;
    max-width: 200px;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    padding: 0 10px;
    }
    .leaflet-touch .leaflet-bar .leaflet-locate-text-active .leaflet-locate-icon {
    padding: 0 5px 0 0;
    }

    .leaflet-control-locate-location circle {
    animation: leaflet-control-locate-throb 4s ease infinite;
    }

    @keyframes leaflet-control-locate-throb {
    0% {
        stroke-width: 1;
    }
    50% {
        stroke-width: 3;
        transform: scale(0.8, 0.8);
    }
    100% {
        stroke-width: 1;
    }
    }
    @keyframes leaflet-control-locate-spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
    }

    .alerts-button {
        display: flex;
        align-items: center;
        background-color: #000000;
        color: #ffffff;
        padding: 15px 18px;
        margin-bottom: 8px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        cursor: pointer;
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), 
                    box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1),
                    background-color 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        position: relative;
        overflow: hidden;
        animation: fadeInUp 0.3s ease-out forwards;
    }

    .alerts-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -120%;
        width: 120%;
        height: 100%;
        background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
        transform: skewX(-25deg);
        transition: left 0.8s cubic-bezier(0.25, 1.5, 0.5, 1);
        z-index: 1;
        pointer-events: none;
    }

    .alerts-button:hover::before {
        left: 120%;
    }

    .alerts-button:hover {
        transform: scale(0.98);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        background-color: #222222;
    }

    .alerts-button:active {
        transform: scale(0.95);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        background-color: #333333;
        transition: all 0.1s cubic-bezier(0.25, 1.5, 0.5, 1);
    }

    .alerts-button:active .alerts-icon {
        transform: scale(1.2) rotate(5deg);
        transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
    }

    .alerts-icon {
        margin-right: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 2;
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
    }


    .alerts-button:hover .alerts-icon {
        transform: scale(1.2);
    }

    .alerts-content {
        z-index: 2;
    }

    .alerts-title {
        font-weight: normal;
        font-size: 20px;
    }

    .alerts-description {
        font-size: 14px;
        opacity: 0.8;
    }

    @media (max-width: 1024px) {
    .options {
        scrollbar-width: none; 
    }

    .options::-webkit-scrollbar {
        display: none;
    }
    }

    .bus-stop-marker {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: white;
        border: 1px solid black;
    }

    .line-popup, .stop-popup {
        padding: 5px;
    }

    .line-popup h4, .stop-popup h4 {
        margin: 0 0 5px 0;
        font-weight: bold;
    }


    #map-container { 
        height: 100%; 
        width: 100%; 
    }
    #map { 
        height: 100%; 
        width: 100%; 
    }

    #sun-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 999;
        opacity: 0;
        transition: opacity 0.5s ease-in-out; 
    }
    .sun-line {
        position: absolute;
        stroke-width: 2;
        fill: none;
    }
    .hour-circle {
        position: absolute;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 18px;
        opacity: 0.9;
        color: white;
        text-shadow: 1px 1px 2px black;
        transform: translate(-50%, -50%);
    }
    #toggle-sun-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1001;
        padding: 10px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;
    }

    .first-visit-tooltip {
        position: absolute;
        bottom: 80px;
        left: 50%;
        width: auto;
        transform: translateX(-50%);
        background-color: rgba(15, 5, 107, 0.384);
        color: white;
        padding: 10px 15px;
        border-radius: 15px;
        z-index: 10001;
        display: flex;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .first-visit-tooltip.show {
        opacity: 1;
        visibility: visible;
    }

    .first-visit-tooltip .tooltip-content {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .first-visit-tooltip svg {
        stroke: white;
        animation: bounce 1s infinite;
    }

    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    .logo-bottom {
    display: block;
    margin: 0 auto;
    max-width: 50%;
    height: auto;
    position: absolute;
    bottom: 50px; 
    left: 50%;
    transform: translateX(-50%);
    }

    .logo-bottom.logoscr {
    transform: translateX(-50%) translateY(100px);
    opacity: 0;
    filter: blur(5px);
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    }

    .logo-bottom.logoscrapp {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
    filter: blur(0);
    }

    @media (max-width: 600px) {
    .logo-bottom {
        width: 50%;
        max-width: 200px;
    }
    }

    @media (min-width: 1200px) {
    .logo-bottom {
        width: 10%;
        max-width: 400px;
    }
    }

    @keyframes rainbowShadow {
    0% { filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7)); }  
    16.6% { filter: drop-shadow(0 0 10px rgba(255, 165, 0, 0.7)); }  
    33.3% { filter: drop-shadow(0 0 10px rgba(255, 255, 0, 0.7)); }  
    50% { filter: drop-shadow(0 0 10px rgba(0, 255, 0, 0.7)); }  
    66.6% { filter: drop-shadow(0 0 10px rgba(0, 0, 255, 0.7)); } 
    83.3% { filter: drop-shadow(0 0 10px rgba(128, 0, 128, 0.7)); } 
    100% { filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7)); }  
    }

    .rainbow-shadow {
    animation: rainbowShadow 3s infinite linear;
    }

    .vehicle-thumbnail {
        background: #0000006b; 
        font-weight: normal; 
        white-space: nowrap; 
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border-radius: 10px; 
        display: inline-flex; 
        align-items: center; 
        gap: 6px;
        padding: 0px 8px;
    }

    .vehicle-thumbnaill {
        font-weight: normal; 
        white-space: nowrap; 
        display: inline-flex; 
        align-items: center; 
        gap: 6px;
    }

    #map {
        transition: all 0.4s cubic-bezier(0.32, 0.64, 0.45, 1);
    }

    #webview-frameaccueil {
        width: 100%;
        height: 100%;
    }
</style>

</head>
<body>
<div class="filtre" id="filtre">
    <span data-i18n="filtersreset" class="filtre-texte">Réinitialiser les filtres</span>
</div>

<div id="first-visit-tooltip" class="first-visit-tooltip">
    <div class="tooltip-content">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="up-arrow">
            <path d="M12 5l-7 7h14l-7-7z" fill="white"/>
        </svg>
        <span data-i18n="slideuptosettings">Glissez vers le haut pour les paramètres</span>
    </div>
</div>
 <div class="menubottom">
        <ul id="menubtm" class="menubottom-ul">
            <li>
                <a onclick="afficherMenu()"><span class="icon"><img src="src/menu.png" id="menuicon" style="width: 40px; height: 40px;"></img></span> <span
                    class="title" data-i18n="menu">Menu</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopupPourHoraires()" id="clock"><span class="icon"><img src="src/horloge.png" id="myscheduleicon" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="schedule">Horaires</span></a>
            </li>
            <li>
                <a id="menubutton"><span class="icon"><img src="src/bus.png" id="vehicleicon" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="network">Réseau</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('alerts.html');" id="histovecbutton"><span class="icon"><img id="actuicon" src="src/newspaper.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="news">Actualités</span></a>
            </li>
        </ul>
</div>

	
<div id="accueil">
    <iframe id="webview-frameaccueil" src="../mainmenu.html" frameborder="0"></iframe>
</div>


	<amp-auto-ads type="adsense"
        data-ad-client="ca-pub-5815761294049475">
</amp-auto-ads>

    <div id="map"></div>
    <svg id="sun-overlay" xmlns="http://www.w3.org/2000/svg"></svg>



    <div id="menu"></div>
    <div id="update-popup" class="update-popup">
        <div class="popup-content">
            <button id="close-popup" class="close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            <iframe id="webview-frame" src="" frameborder="0"></iframe>
        </div>
    </div>
                
    <div id="time-popup" class="time-popup">
        <div class="time-content">
            <button id="close-popup1" class="close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            <iframe id="webview-frame1" src="" frameborder="0"></iframe>
        </div>
    </div>

	
	
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


	
<div id="loading-screen" class="logobkg">
    <img id="logoscr" class="logoscr rainbow-shadow" src="src/whitelogo.png" style="display: block; margin: 0 auto; max-width: 50%; height: auto;"/>
    <img id="bottom-logo" class="logoscr logo-bottom" src="src/credits.png" />
</div>
  

 <script src="src/js/toastjs.js"></script>       
 <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5815761294049475"
     crossorigin="anonymous"></script>
 <script src="../js/tarteaucitron/tarteaucitron.min.js"></script>
 <script src="../build.js"></script>

 <script>
  function setAppHeight() {
    const doc = document.documentElement;
    doc.style.setProperty('--app-height', `${window.innerHeight}px`);
  }

  window.addEventListener('resize', setAppHeight);
  window.addEventListener('orientationchange', setAppHeight);
  setAppHeight(); 
  
    document.addEventListener('gesturestart', function (e) {
    e.preventDefault();
    });
    document.addEventListener('gesturechange', function (e) {
    e.preventDefault();
    });
    document.addEventListener('gestureend', function (e) {
    e.preventDefault();
    });
</script>


 <script>
 /* tarteaucitron */
tarteaucitron.init({
          "bodyPosition": "middle",

    	  "hashtag": "#cookies", /* Hashtag qui permet d'ouvrir le panneau de contrôle  */
    	  "cookieName": "tarteaucitron", /* Nom du cookie (uniquement lettres et chiffres) */
    
    	  "orientation": "middle", /* Position de la bannière (top - bottom - popup - banner) */
       
          "groupServices": true, /* Grouper les services par catégorie */
          "showDetailsOnClick": true, /* Cliquer pour ouvrir la description */
          "serviceDefaultState": "wait", /* Statut par défaut (true - wait - false) */
                           
    	  "showAlertSmall": false, /* Afficher la petite bannière en bas à droite */
    	  "cookieslist": false, /* Afficher la liste des cookies */
                           
          "closePopup": true, /* Afficher un X pour fermer la bannière */

          "showIcon": false, /* Afficher un cookie pour ouvrir le panneau */
          //"iconSrc": "src/whitelogo.png", /* Optionnel: URL ou image en base64 */
          "iconPosition": "BottomRight", /* Position de l'icons: (BottomRight - BottomLeft - TopRight - TopLeft) */

    	  "adblocker": true, /* Afficher un message si un Adblocker est détecté */
                           
          "DenyAllCta" : true, /* Afficher le bouton Tout refuser */
          "AcceptAllCta" : true, /* Afficher le bouton Tout accepter */
          "highPrivacy": true, /* Attendre le consentement */
          "alwaysNeedConsent": false, /* Demander le consentement même pour les services "Privacy by design" */
                           
    	  "handleBrowserDNTRequest": false, /* Refuser tout par défaut si Do Not Track est activé sur le navigateur */

    	  "removeCredit": true, /* Retirer le lien de crédit vers tarteaucitron.io */
    	  "moreInfoLink": true, /* Afficher le lien En savoir plus */

          "useExternalCss": false, /* Mode expert : désactiver le chargement des fichiers .css tarteaucitron */
          "useExternalJs": false, /* Mode expert : désactiver le chargement des fichiers .js tarteaucitron */

    	  //"cookieDomain": ".my-multisite-domaine.fr", /* Optionnel: domaine principal pour partager le consentement avec des sous domaines */
                          
          "mandatory": true, /* Afficher un message pour l'utilisation de cookies obligatoires */
    
          
          "googleConsentMode": true, /* Activer le Google Consent Mode v2 pour Google ads & GA4 */

          "partnersList": true /* Afficher le détail du nombre de partenaires sur la bandeau */
        });
    </script>

    <script>
        (tarteaucitron.job = tarteaucitron.job || []).push('gcmadstorage');
    </script>

<script>
    const i18n = {
    translations: {},
    currentLang: 'fr',
    supportedLanguages: ['fr', 'it', 'ar', 'en'],
    defaultLang: 'fr',
    
    getBrowserLanguage() {
        const fullLang = navigator.language || navigator.userLanguage;
        const primaryLang = fullLang.split('-')[0];
        
        if (this.supportedLanguages.includes(primaryLang)) {
        return primaryLang;
        }
        
        return this.defaultLang;
    },
    
    getLanguageFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const lang = urlParams.get('lang');
        return lang || localStorage.getItem('preferredLanguage') || this.defaultLang;
    },
    
    async loadTranslations() {
        this.currentLang = this.getLanguageFromUrl();
        localStorage.setItem('preferredLanguage', this.currentLang);
        
        try {
        const response = await fetch(`../locales/${this.currentLang}.json`);
        this.translations = await response.json();
        document.dispatchEvent(new CustomEvent('translationsLoaded'));
        return this.translations;
        } catch (error) {
        console.error("Erreur lors du chargement des traductions:", error);
        return {};
        }
    },
    
    t(key, params = {}) {
        let text = this.translations[key] || key;
        
        Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
        });
        
        return text;
    },
    
    applyTranslations() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (this.translations[key]) {
            element.innerHTML = this.translations[key];
        }
        });
    },
    
    addLangToUrl() {
        const browserLang = this.getBrowserLanguage();
        
        if (browserLang !== this.defaultLang) {
        const currentUrl = new URL(window.location.href);
        if (!currentUrl.searchParams.has('lang')) {
            currentUrl.searchParams.set('lang', browserLang);
            window.history.replaceState({}, '', currentUrl.toString());
        }
        }
        
        return browserLang;
    },
    
    init() {
        const detectedLang = this.addLangToUrl();
        const urlLang = new URLSearchParams(window.location.search).get('lang');
        
        if (!localStorage.getItem('preferredLanguage')) {
        localStorage.setItem('preferredLanguage', urlLang || detectedLang);
        }
        
        return this.loadTranslations();
    }
    };

    window.t = (key, params) => i18n.t(key, params);

    function waitForTranslations() {
    return new Promise(resolve => {
        if (Object.keys(i18n.translations).length > 0) {
        resolve();
        } else {
        document.addEventListener('translationsLoaded', () => resolve(), { once: true });
        }
    });
    }


    const fluentPopupStyles = `
    .fluent-popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 99999999999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .fluent-popup {
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        padding: 20px;
        max-width: 400px;
        width: 90%;
        font-family: 'League Spartan', sans-serif;
        position: relative;
        transform: translateY(20px);
        transition: transform 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.5);
        color: #202020;
        margin-right: 20px;
        margin-left: 20px;
    }

    .fluent-popup.show {
        transform: translateY(0);
    }

    .fluent-popup-overlay.show {
        opacity: 1;
    }

    .fluent-popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .fluent-popup-title {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
    }

    .fluent-popup-close {
        background: none;
        border: none;
        cursor: pointer;
        color: #555;
        width: 28px;
        height: 28px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }

    .fluent-popup-close:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: #000;
    }

    .fluent-popup-content {
        margin-bottom: 15px;
        line-height: 1.5;
    }

    .fluent-popup-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
    }

    .fluent-button {
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
    }

    .fluent-button-primary {
        background-color: #0078d4;
        color: white;
    }

    .fluent-button-primary:hover {
        background-color: #106ebe;
    }

    .fluent-button-secondary {
        background-color: rgba(0, 0, 0, 0.05);
        color: #000;
    }

    .fluent-button-secondary:hover {
        background-color: rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
        .fluent-popup {
        background-color: rgba(32, 32, 32, 0.95);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.1);
        }

        .fluent-popup-close {
        color: #aaa;
        }

        .fluent-popup-close:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: #fff;
        }

        .fluent-button-secondary {
        background-color: rgba(255, 255, 255, 0.1);
        color: #fff;
        }

        .fluent-button-secondary:hover {
        background-color: rgba(255, 255, 255, 0.15);
        }
    }
    `;

    class FluentPopup {
    constructor() {
        this.initialized = false;
        this.isOpen = false;
        this.overlay = null;
        this.popup = null;
        this.styleElement = null;
    }

    init() {
        if (this.initialized) return;

        this.styleElement = document.createElement('style');
        this.styleElement.textContent = fluentPopupStyles;
        document.head.appendChild(this.styleElement);

        this.overlay = document.createElement('div');
        this.overlay.className = 'fluent-popup-overlay';
        
        
        this.popup = document.createElement('div');
        this.popup.className = 'fluent-popup';
        
        this.overlay.appendChild(this.popup);
        document.body.appendChild(this.overlay);

        this.initialized = true;
    }


    open(options = {}) {
        if (!this.initialized) this.init();
        if (this.isOpen) return;
        document.querySelector(".fluent-popup-overlay").style.display = "flex";

        const {
        title = 'Notification',
        message = '',
        buttons = {
            primary: 'OK',
            primaryAction: () => this.close()
        },
        closeButton = true
        } = options;

        this.popup.innerHTML = `
        <div class="fluent-popup-header">
            <h3 class="fluent-popup-title">${title}</h3>
        </div>
        <div class="fluent-popup-content">
            ${message}
        </div>
        <div class="fluent-popup-actions">
            ${buttons.secondary ? `<button class="fluent-button fluent-button-secondary">${buttons.secondary}</button>` : ''}
            <button class="fluent-button fluent-button-primary">${buttons.primary}</button>
        </div>
        `;


        const primaryBtn = this.popup.querySelector('.fluent-button-primary');
        primaryBtn.addEventListener('click', (e) => {
        if (buttons.primaryAction) buttons.primaryAction(e);
        });

        const secondaryBtn = this.popup.querySelector('.fluent-button-secondary');
        if (secondaryBtn && buttons.secondaryAction) {
        secondaryBtn.addEventListener('click', (e) => buttons.secondaryAction(e));
        }

        requestAnimationFrame(() => {
        this.overlay.classList.add('show');
        this.popup.classList.add('show');
        });

        this.isOpen = true;
    }

    close() {
        if (!this.isOpen) return;
        
        this.overlay.classList.remove('show');
        this.popup.classList.remove('show');
        
        setTimeout(() => {
        this.isOpen = false;
        document.querySelector(".fluent-popup-overlay").style.display = "none";
        }, 300);
    }


    destroy() {
        if (this.overlay && this.overlay.parentNode) {
        this.overlay.parentNode.removeChild(this.overlay);
        }
        
        if (this.styleElement && this.styleElement.parentNode) {
        this.styleElement.parentNode.removeChild(this.styleElement);
        }
        
        this.initialized = false;
        this.isOpen = false;
    }
    }

    const fluentPopupManager = new FluentPopup();

    function showFluentPopup(options = {}) {
    fluentPopupManager.open(options);
    }



    document.addEventListener('DOMContentLoaded', () => {

    if (localStorage.getItem('transparency') !== 'true') {
        if (window.innerWidth > 1024) {
            localStorage.setItem('transparency', true);
            toastBottomRight.info('Pour votre confort à l\'utilisation de l\'app sur PC, My Bus Finder a automatiquement activé le mode transparence rétracté pour le menu Véhicules en service. Vous pourrez désactiver ce paramètre à tout moment. ')
        }
    }

    i18n.init().then(() => {
        i18n.applyTranslations();
        if (langSwitcher && langSwitcher.updateCurrentLanguage) {
        langSwitcher.updateCurrentLanguage(i18n.currentLang);
        }
        waitForTranslations().then(() => {
            const settingsmbf = t("settingsmbf");
            const general = t("general");
            const advanced = t("advanced");
            const about = t("aboutmbf");
            const settings = t("settings");
            const satelmode = t("satelmode");
            const satelmodetext = t("satelmodetext");
            const locateonstart = t("locateonstart");
            const locateonstarttext = t("locateonstarttext");
            const selectlanguage = t("selectlanguage");
            const selectlanguagetext = t("selectlanguagetext");
            const spottingmode = t("spottingmode");
            const spottingmodetext = t("spottingmodetext");
            const theme = t("theme");
            const themeselect = t("themeselect");
            const defaulttheme = t("defaulttheme");
            const darktheme = t("darktheme");
            const hero = t("hero");
            const corail = t("corail");
            const barbie = t("barbie");
            const palmbus = t("palmbus");     
            const transparency = t("transparency");
            const transparencytext = t("transparencytext");
            const darkmap = t("darkmap");
            const darkmaptext = t("darkmaptext");   
            const betasetting = t("betasetting");
            const betasettingdarkmap = t("betasettingdarkmap");
            const understood = t("understood");
            const cancel = t("cancel");
                   

            FluentSettingsMenu.init({
                title: settingsmbf,
                accentColor: "#0078d7"
            });

            FluentSettingsMenu.createSection("general", general);
            FluentSettingsMenu.createSection("advanced", advanced);
            FluentSettingsMenu.createSection("about", about);

            FluentSettingsMenu.addToggle("general", "mapview", {
                icon: "🗺️",
                label: satelmode,
                description: satelmodetext,
                value: localStorage.getItem('isStandardView') === 'true',
                onChange: function (value) {
                toggleMapView(value);
                }
            });

            FluentSettingsMenu.addSelect("general", "mapview", {
                icon: "🖌️",
                label: theme,
                description: themeselect,
                value: localStorage.getItem('theme') === 'default' ? 'default' : localStorage.getItem('theme'),
                options: [
                { value: 'default', label: defaulttheme },
                { value: 'dark', label: darktheme },
                { value: 'hero', label: hero },
                { value: 'corail', label: corail },
                { value: 'barbie', label: barbie },
                { value: 'palmbus', label: palmbus }
                ],
                onChange: function (value) {
                changeColorBkg(value);
                }
            });

            FluentSettingsMenu.addToggle("general", "locate", {
                icon: "📍",
                label: locateonstart,
                description: locateonstarttext,
                value: localStorage.getItem('locateonstart') === 'true',
                onChange: function (value) {
                localStorage.setItem('locateonstart', value);
                }
            });

            FluentSettingsMenu.addToggle("general", "transparency", {
                icon: "🪟",
                label: transparency,
                description: transparencytext,
                value: localStorage.getItem('transparency') === 'true',
                onChange: function (value) {
                localStorage.setItem('transparency', value);
                    if (value) {
                        const map = document.getElementById('map');
                        map.classList.remove('appearnotransition');
                        map.classList.remove('hidden');
                        map.classList.remove('appear');
                        map.classList.add('hiddennotransition');
                    } else {
                        const map = document.getElementById('map');
                        map.classList.remove('appear');
                        map.classList.remove('hiddennotransition');
                        map.classList.remove('appearnotransition');
                        map.classList.add('hidden');                        
                    }
                }
            });

            FluentSettingsMenu.addLanguageSwitcher("general", {
                icon: "🌐",
                label: selectlanguage,
                description: selectlanguagetext,
                languages: [
                { code: 'fr', name: 'Français 🇫🇷' },
                { code: 'en', name: 'English 🇬🇧' },
                { code: 'it', name: 'Italiano 🇮🇹' },
                { code: 'ar', name: 'Arabe 🇸🇦' },
                ],
                currentLang: i18n.currentLang,
                onChange: (lang) => {
                localStorage.setItem('preferredLanguage', lang);
                location.reload(); // recharge pour refléter les traductions
                }
            });

            FluentSettingsMenu.addToggle("advanced", "spottingmode", {
                icon: "📸",
                label: spottingmode,
                description: spottingmodetext,
                value: false,
                onChange: function (value) {
                toggleSunOrientation(value);
                }
            });

            FluentSettingsMenu.addToggle("advanced", "darkmap", {
                icon: "🎴",
                label: darkmap,
                description: darkmaptext,
                value: localStorage.getItem('darkmap') === 'true',
                onChange: function (value) {
                    if (value) {
                        showFluentPopup({
                            title: betasetting,
                            message: betasettingdarkmap,
                            buttons: {
                                primary: understood,
                                primaryAction: () => {
                                    localStorage.setItem('darkmap', 'true');
                                    const mapPane = map.getPanes().tilePane;
                                    mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
                                    fluentPopupManager.close();
                                },
                                secondary: cancel,
                                secondaryAction: () => {
                                    const toggle = document.querySelector('[data-setting="darkmap"]');
                                    if (toggle) {
                                        toggle.querySelector('input[type="checkbox"]').checked = false;
                                    }
                                    localStorage.setItem('darkmap', 'false');
                                    fluentPopupManager.close();
                                }
                            }
                        });
                    } else {
                        localStorage.setItem('darkmap', value);
                        const mapPane = map.getPanes().tilePane;
                        mapPane.style.filter = 'none';
                    }
                }
            });

            FluentSettingsMenu.addSubmenu("about", "aboutsub", {
                icon: "",
                label: "My Bus Finder - by BecabTransit",
                description: "build " + `${window.BUILD_VERSION}`,
                onclick: function () {
                showUpdatePopupmusic("https://www.mybusfinder.fr/updatecm/updatecm.html");
                }
            });

            FluentSettingsMenu.addSubmenu("about", "erazecache", {
                icon: "",
                label: "For developers - erase cache",
                description: "Do not use if you don't know what you are doing",
                onclick: function () {
                clearGTFSCache();
                }
            });
        });

    });
    });

    window.i18n = i18n;
    </script>


<script>


document.addEventListener('DOMContentLoaded', function() {
    const menuItems = document.querySelectorAll('.menubottom-ul li a');

    if (localStorage.getItem('transparency') === 'true') {
        const map = document.getElementById('map');
        map.classList.remove('hiddennotransition');
        map.classList.add('appearnotransition');
        map.classList.remove('hidden');
        map.classList.remove('appear');
    } else {
        const map = document.getElementById('map');
        map.classList.remove('hidden');
        map.classList.add('appear');
        map.classList.remove('hiddennotransition');
        map.classList.remove('appearnotransition');
    }

    
    menuItems.forEach(item => {
        item.addEventListener('touchstart', function() {
            safeVibrate(50);
        });
        
        item.addEventListener('touchend', function() {
            safeVibrate(50);
        });
    });
});


if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        
        let refreshing = false;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            toastBottomRight.info('Préparation en cours.')

          if (!refreshing) {
            refreshing = true;
            window.location.reload();
          }
        });
        
        registration.update();
      })
      .catch(error => {
        console.error('Erreur lors de l\'enregistrement du service Worker:', error);
      });
  });
}

document.addEventListener('DOMContentLoaded', function() {
    const tooltip = document.getElementById('first-visit-tooltip');
    
    let navigationCount = parseInt(localStorage.getItem('navigationCount') || '0');
    
    function showTooltip() {
        tooltip.classList.add('show');
        
        const tooltipTimeout = setTimeout(() => {
            tooltip.classList.remove('show');
        }, 10000);
        
        const hideTooltip = () => {
            tooltip.classList.remove('show');
            document.removeEventListener('click', clickHandler);
        };
        
        const clickHandler = (event) => {
            if (!tooltip.contains(event.target)) {
                clearTimeout(tooltipTimeout);
                hideTooltip();
            }
        };
        
        document.addEventListener('click', clickHandler);
    }
    
    function checkNavigationAndShowTooltip() {
        navigationCount++;
        localStorage.setItem('navigationCount', navigationCount.toString());
        
        if (navigationCount === 2) {
            setTimeout(showTooltip, 3000);
        }
    }
    
    const originalHideLoadingScreen = window.hideLoadingScreen;
    window.hideLoadingScreen = function() {
        if (originalHideLoadingScreen) {
            originalHideLoadingScreen.apply(this, arguments);
        }
        checkNavigationAndShowTooltip();
    };
});

async function getSetvar() {
    try {
        const response5 = await fetch('setvar/settings/theme/maincolor.txt');
        const setvar5 = await response5.text();  
        const colorbkg = setvar5.trim();

        const response = await fetch('setvar/settings/map/defaultzoom.txt');
        const setvar = await response.text();
        const view = setvar.trim();  

        const response1 = await fetch('setvar/settings/networkname.txt');
        const setvar1 = await response1.text();
        const nomdureseau = setvar1.trim();  

        return { colorbkg, view, nomdureseau };

    } catch (error) {
        console.error('Erreur chargement setvar ! ', error);
    }
}

getSetvar();


const vehicleModels = {};

const vehicleTypes = {
    'elec': new Set(),
    'hybrid': new Set(),
    'gnv': new Set(),
    'usb': new Set(),
    'clim': new Set()
};

let map;

async function changeColorBkg(selectedTheme = null) {
    const data = await getSetvar();
    const defaultColor = data && data.colorbkg ? data.colorbkg : "#005A9E";

    const themes = {
        default: defaultColor,
        dark: "#121212",
        hero: "#2A2A6E",
        corail: "#444444",
        barbie: "#9A0D5B",
        palmbus: "#B38F00"
    };

    const savedTheme = localStorage.getItem("theme") || "default";
    const theme = selectedTheme || savedTheme;

    const baseColor = themes[theme] || themes["default"];
    const colorWithAlpha = `${baseColor}9c`;

    localStorage.setItem("theme", theme);
    localStorage.setItem("colorbkg", baseColor);

    document.getElementById("menubtm").style.backgroundColor = colorWithAlpha;
    document.getElementById("filtre").style.backgroundColor = colorWithAlpha;
    document.documentElement.style.backgroundColor = colorWithAlpha;

    window.colorbkg = baseColor;
    window.colorbkg9c = colorWithAlpha;

    const mapPane = map.getPanes().tilePane;
    if (localStorage.getItem('darkmap') === 'true') {
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        mapPane.style.filter = 'none';
    }
}


(async () => {
    await changeColorBkg();
})();


setTimeout(() => {
    const logoscr = document.getElementById('logoscr');
    logoscr.classList.add('logoscrapp');
    document.getElementById("bottom-logo").classList.add("logoscrapp");
}, 10); 

async function initMap() {
    const data = await getSetvar();
    let defaultCoords = [43.125463, 5.930077];
    let defaultZoom = 13;
    
    if (data && data.view) {
        try {
            const viewConfig = data.view.match(/\[(.*?)\],\s*(\d+)/);
            if (viewConfig && viewConfig.length >= 3) {
                const coords = viewConfig[1].split(',').map(coord => parseFloat(coord.trim()));
                defaultCoords = [coords[0], coords[1]];
                defaultZoom = parseInt(viewConfig[2]);
            }
        } catch (error) {
            console.error('Erreur parsing des coord gps', error);
        }
    }
    
    const mapInstance = L.map('map', {
        zoomControl: false 
    }).setView(defaultCoords, defaultZoom);
    
    L.popup({
        closeButton: false
    });

    mapInstance.on('moveend', function() {
        if (isSunOrientationVisible) {
            updateSunOrientation();
        }
    });
    
    mapInstance.on('popupopen', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-out', 'popup-zoom-in');
        setTimeout(() => {
            popupWrapper.classList.add('popup-zoom-in');
        }, 10); 
    });
    
    mapInstance.on('popupclose', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-in');
        popupWrapper.classList.add('popup-zoom-out');
        popupWrapper.addEventListener(
            'transitionend',
            () => {
                popupWrapper.classList.remove('popup-zoom-out');
            },
            { once: true }
        );
    });

    


    const isStandardView = localStorage.getItem('isStandardView') === 'true';
    
    if (!isStandardView) {
    const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
    
    const tileLayer = L.tileLayer(tileLayerUrl, {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(mapInstance);


} else {
    const mapPane = mapInstance.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(mapInstance);

}




mapInstance.attributionControl.setPrefix('');

    mapInstance.on('locationfound', onLocationFound);
    mapInstance.on('locationerror', onLocationError);

    return mapInstance;
}

function onLocationFound(e) {
    const radius = e.accuracy / 2;

    if (window.locationMarker) {
        map.removeLayer(window.locationMarker);
    }
    if (window.locationCircle) {
        map.removeLayer(window.locationCircle);
    }

    window.locationCircle = L.circle(e.latlng, {
        radius: radius,
        color: '#136AEC',
        fillColor: '#136AEC',
        fillOpacity: 0.15,
        weight: 2
    }).addTo(map);

    map.setView(e.latlng, 16);
}

function onLocationError(e) {
    toastBottomRight.warning("Vous avez refusé la localisation.");
}

function locateUser() {
    if (!map) return;
    
    if ("geolocation" in navigator) {
        const locationOptions = {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
        };

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;

                map.fireEvent('locationfound', {
                    latlng: L.latLng(lat, lng),
                    accuracy: accuracy,
                    timestamp: position.timestamp
                });
            },
            (error) => {
                map.fireEvent('locationerror', {
                    code: error.code,
                    message: error.message
                });
            },
            locationOptions
        );
    } else {
        toastBottomRight.error("La géolocalisation n'est pas supportée par votre navigateur");
    }
}

(async function() {
    map = await initMap();
})();

const sunOverlay = document.getElementById('sun-overlay');
    let isSunOrientationVisible = false; 

    function updateSunOrientation(date = new Date()) {
        sunOverlay.innerHTML = '';

        const center = map.getCenter();
        const centerLat = center.lat;
        const centerLon = center.lng;

        const sunTimes = SunCalc.getTimes(date, centerLat, centerLon);
        const sunrise = sunTimes.sunrise;
        const sunset = sunTimes.sunset;

        const mapSize = map.getSize();
        const centerPoint = {
            x: mapSize.x / 2,
            y: mapSize.y / 2
        };

        const currentTime = new Date(sunrise);
        const radius = Math.min(mapSize.x, mapSize.y) * 0.4; 

        while (currentTime <= sunset) {
            const sunPosition = SunCalc.getPosition(currentTime, centerLat, centerLon);
            
            const azimuthDegrees = sunPosition.azimuth * (180 / Math.PI);
            const angleRad = (azimuthDegrees + 90) * (Math.PI / 180); 

            const endX = centerPoint.x + radius * Math.cos(angleRad);
            const endY = centerPoint.y + radius * Math.sin(angleRad);

            const hourColor = getColorForTime();

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', centerPoint.x);
            line.setAttribute('y1', centerPoint.y);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', hourColor);
            line.setAttribute('stroke-width', '2');
            line.classList.add('sun-line');
            sunOverlay.appendChild(line);

            const hourCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            hourCircle.setAttribute('cx', endX);
            hourCircle.setAttribute('cy', endY);
            hourCircle.setAttribute('r', '25');
            hourCircle.setAttribute('fill', hourColor);

            const hourText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            hourText.setAttribute('x', endX);
            hourText.setAttribute('y', endY);
            hourText.setAttribute('text-anchor', 'middle');
            hourText.setAttribute('dy', '.3em');
            hourText.setAttribute('fill', 'white');
            hourText.setAttribute('font-size', '18');
            hourText.textContent = currentTime.getHours();

            sunOverlay.appendChild(hourCircle);
            sunOverlay.appendChild(hourText);

            currentTime.setHours(currentTime.getHours() + 1);
        }

        const now = new Date();
        if (now >= sunrise && now <= sunset) {
            const nowSunPosition = SunCalc.getPosition(now, centerLat, centerLon);
            const nowAzimuthDegrees = nowSunPosition.azimuth * (180 / Math.PI);
            const nowAngleRad = (nowAzimuthDegrees + 90) * (Math.PI / 180); 

            const nowEndX = centerPoint.x + radius * Math.cos(nowAngleRad);
            const nowEndY = centerPoint.y + radius * Math.sin(nowAngleRad);

            const nowLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            nowLine.setAttribute('x1', centerPoint.x);
            nowLine.setAttribute('y1', centerPoint.y);
            nowLine.setAttribute('x2', nowEndX);
            nowLine.setAttribute('y2', nowEndY);
            nowLine.setAttribute('stroke', 'black');
            nowLine.setAttribute('stroke-width', '4');
            sunOverlay.appendChild(nowLine);
        }
    }

    function getColorForTime() {
        return 'black'; 
    }

function toggleSunOrientation(forceState) {
    if (forceState !== undefined) {
        isSunOrientationVisible = forceState;
    } else {
        isSunOrientationVisible = !isSunOrientationVisible;
    }
    
    if (isSunOrientationVisible) {
        sunOverlay.style.opacity = 1; 
        updateSunOrientation();
        window.nearbyVehiclesControl.show();
        window.nearbyVehiclesControl.collapse();
    } else {
        sunOverlay.style.opacity = 0; 
        setTimeout(() => sunOverlay.innerHTML = '', 500); 
        window.nearbyVehiclesControl.hide();
    }
}





        const markers = {};
        let lineColors = {};
        let lineName = {};
        let stopIds = [];
        let stopNameMap = {}
        let selectedLine = null;
        let geoJsonLines = []; 
        let tripUpdates = {};
        let loadingInterval;


function showLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    loadingScreen.style.display = 'flex';
    loadingInterval = setInterval(() => {}, 100);
}
		


var audio = new Audio("src/sounds/musique.mp3"); 


let globalStopSpinner = null;
let HorairesCharges = false;

function showUpdatePopupPourHoraires() {
    window.open('schedule.html', '_blank');
}


function showUpdatePopup(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    const currentLang = i18n.currentLang;
    const hasParams = link.includes('?');
    const langParam = `lang=${currentLang}`;
    
    const loadingContainer = document.createElement('div');
    loadingContainer.id = 'iframe-loading-container';
    loadingContainer.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(255, 255, 255, 0);
        z-index: 10;
    `;
    
    const spinnerElement = document.createElement('span');
    spinnerElement.id = 'iframe-win-spinner';
    spinnerElement.style.cssText = `
        font-family: 'SegoeUIBoot';
        font-size: 2rem;
        color: ${window.colorbkg};
    `;
    

    
    loadingContainer.appendChild(spinnerElement);
    loadingContainer.style.display = 'none';

    const popupContent = document.querySelector('.popup-content');
    popupContent.style.position = 'relative';
    popupContent.appendChild(loadingContainer);
    
    if (globalStopSpinner) {
        globalStopSpinner();
    }
    globalStopSpinner = startWindowsSpinnerAnimation("iframe-win-spinner");
    
    if (hasParams) {
        iframe.src = `${link}&${langParam}`;
    } else {
        iframe.src = `${link}?${langParam}`;
    }
    

    
    setupMessageListener(loadingContainer);
    
    popup.style.display = 'flex'; 
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const menubotom = document.getElementById('menubottom');

    menubottom1.classList.remove('slide-downb');
    menubottom1.classList.add('slide-upb');
    if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        filtre.addEventListener('animationend', () => {
            filtre.style.display = 'none';
        });
        resetMapView();            
    }

    menubottom1.addEventListener('transitionend', () => {
        if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
        }
    }, { once: true });
}

function setupMessageListener(loadingContainer) {
    window.addEventListener('message', function(event) {

        try {
            const data = event.data;
            
            if (data && typeof data === 'object') {
                if (data.action === 'showSpinner') {
                    loadingContainer.style.display = 'flex';
                    if (data.message) {
                        const loadingText = loadingContainer.querySelector('div');
                        if (loadingText) loadingText.textContent = data.message;
                    }
                } 
                else if (data.action === 'hideSpinner') {
                    loadingContainer.style.display = 'none';
                }
            }
        } catch (e) {
            console.error("Erreur lors du traitement du message:", e);
        }
    });
}

function startWindowsSpinnerAnimation(elementId, interval = 30) {
    const frames = [
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','',''
  ];


  const el = document.getElementById(elementId);
  if (!el) {
    return () => {};
  }

  let i = 0;
  const timer = setInterval(() => {
    el.textContent = frames[i];
    i = (i + 1) % frames.length;
  }, interval);
  return () => clearInterval(timer);
}

function showUpdatePopupmusic(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    const currentLang = i18n.currentLang;
    const hasParams = link.includes('?');
    const langParam = `lang=${currentLang}`;
    showLanguageSwitcher();

    
    if (hasParams) {
        iframe.src = `${link}&${langParam}`;
    } else {
        iframe.src = `${link}?${langParam}`;
    }
    
    popup.style.display = 'flex'; 
    musique();
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const menubotom = document.getElementById('menubottom');

    menubottom1.classList.remove('slide-downb');
    menubottom1.classList.add('slide-upb');
    if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        filtre.addEventListener('animationend', () => {
            filtre.style.display = 'none';
        });
        resetMapView();            
    }

    menubottom1.addEventListener('transitionend', () => {
        if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
        }
    }, { once: true });
}

window.addEventListener('message', function(event) {
    if (event.data && event.data.action === 'showUpdatePopup') {
        if (window.parent && typeof window.parent.showUpdatePopup === 'function') {
            window.parent.showUpdatePopup(event.data.url);
        }
    }
}, false);



function focusOnVehicle(vehicleId) {
    try {        
        closeUpdatePopup();
        
        const marker = Object.values(markers).find(m => m.id === vehicleId);
        
        if (!marker) {
            toastBottomRight.error('La position du véhicule est indisponible');
            return;
        }
        
        
        try {
            map.setView(marker.getLatLng(), 17);
            marker.openPopup();
            
            const markerIcon = marker._icon.querySelector('.marker-icon');
            if (!markerIcon) {
                toastBottomRight.error('La position du véhicule est indisponible');

                return;
            }
            
            markerIcon.style.transform = 'scale(1.3)';
            setTimeout(() => {
                markerIcon.style.transform = 'scale(1)';
            }, 500);
            
        } catch (mapError) {
            toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : manipulating marker error');
        }
    } catch (error) {
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : focusOnVehicle function error');
    }
}

window.addEventListener('message', function(event) {
    try {        
        if (event.data && event.data.type === 'vehicleSelected') {
            const vehicleId = event.data.vehicleId;
            focusOnVehicle(vehicleId);
        }
    } catch (error) {
        console.error('Error ', error);
    }
});

function closeUpdatePopup() {
    const popup = document.getElementById('update-popup');
    const popup1 = document.getElementById('time-popup');
    const iframe = document.getElementById('webview-frame');
    const mapp = document.getElementById('map');
    mapp.style.opacity = '1';
    hideLanguageSwitcher();

    
    if (iframe.dataset.originalSrc) {
        const timestamp = new Date().getTime();
        iframe.src = iframe.dataset.originalSrc + (iframe.dataset.originalSrc.includes('?') ? '&' : '?') + 'cache=' + timestamp;
    } else {
        if (iframe.src && iframe.src !== "") {
            iframe.dataset.originalSrc = iframe.src;
            const timestamp = new Date().getTime();
            iframe.src = iframe.src + (iframe.src.includes('?') ? '&' : '?') + 'cache=' + timestamp;
        } else {
            iframe.src = "";
        }
    }
    
    popup.style.display = 'none'; 
    popup1.style.display = 'none'; 

    
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');

    const map = document.getElementById('map');
    menu.classList.add('hidden');
    if (localStorage.getItem('transparency') === 'true') {
        const map = document.getElementById('map');
        map.classList.remove('hiddennotransition');
        map.classList.add('appearnotransition');
        map.classList.remove('hidden');
        map.classList.remove('appear');
    } else {
        const map = document.getElementById('map');
        map.classList.remove('hidden');
        map.classList.add('appear');
        map.classList.remove('hiddennotransition');
        map.classList.remove('appearnotransition');
    }
    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false; 
    menubottom1.style.display = 'flex';
    
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);
    
    if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
    }
}


function musique() {
    if (audio.paused) {
        audio.play();
    }
}


document.getElementById('close-popup').addEventListener('click', closeUpdatePopup);
document.getElementById('close-popup1').addEventListener('click', closeUpdatePopup);





function hideLoadingScreen() {
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');


        setTimeout(() => {
            const logoscr = document.getElementById('logoscr');
            logoscr.classList.add('logoscrappp');
            loadingScreen.classList.add('logoscrapppp');


            setTimeout(() => {
                loadingScreen.style.display = 'none';
                if(!localStorage.getItem('premierLancement')) {
                    showUpdatePopup('https://mybusfinder.fr/updatecm/updatecm.html');
                    showLanguageSwitcher();
                    localStorage.setItem('premierLancement', 'true');
                } 
            }, 300);
        }, 900);
    }, 100);
}


document.addEventListener('DOMContentLoaded', initializeApp);
const doc = document;
showLoadingScreen();


let data;

let DB_NAME;
let STORE_NAME;
const DB_VERSION = 4;

async function initConstants() {
    try {
        const { nomdureseau } = await getSetvar();
        DB_NAME = `MyBusFinder${nomdureseau}`;
        STORE_NAME = `gtfsStore${nomdureseau}`;
        return { DB_NAME, STORE_NAME };
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des constantes', error);
        DB_NAME = 'MyBusFinderDefault';
        STORE_NAME = 'gtfsStoreDefault';
        return { DB_NAME, STORE_NAME };
    }
}

async function initDB() {
    if (!DB_NAME || !STORE_NAME) {
        await initConstants();
    }
    
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function calculateSHA256(data) {
    let buffer;
    if (data instanceof ArrayBuffer) {
        buffer = data;
    } else if (typeof data === 'string') {
        const encoder = new TextEncoder();
        buffer = encoder.encode(data).buffer;
    } else if (data instanceof Blob) {
        buffer = await data.arrayBuffer();
    } else {
        const jsonString = JSON.stringify(data);
        const encoder = new TextEncoder();
        buffer = encoder.encode(jsonString).buffer;
    }

    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return hashHex;
}

async function getFileHash() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php', {
            method: 'GET',
            headers: {
                'X-Content-Only-Header': 'true'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Échec de la vérif ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const partialData = buffer.slice(0, Math.min(buffer.byteLength, 1024 * 50));
        
        const fileHash = await calculateSHA256(partialData);
        
        return { fileHash, needsFullDownload: true };
    } catch (error) {
        console.error('Erreur lors de la vérif du hash', error);
        return { needsFullDownload: true };
    }
}

async function checkGTFSUpdate() {
    try {
        const db = await initDB();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        
        const storedMetadata = await new Promise((resolve, reject) => {
            const request = store.get('gtfsMetadata');
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        if (!storedMetadata || !storedMetadata.fileHash) {
            return { needsUpdate: true };
        }
        
        const { fileHash, needsFullDownload } = await getFileHash();
        
        if (fileHash !== storedMetadata.fileHash) {
            return { needsUpdate: true, fileHash };
        }
        
        return { needsUpdate: false, metadata: storedMetadata };
    } catch (error) {
        console.error('Erreur vérif maj GTFS', error);
        return { needsUpdate: true };
    }
}

async function saveToCache(data, metadata) {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            store.put(data, 'gtfsData');
            
            if (!metadata) {
                metadata = {};
            }
            metadata.lastUpdate = new Date().toISOString();
            store.put(metadata, 'gtfsMetadata');

            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('Erreur sauvegarde dans le cache', error);
        throw error;
    }
}

async function getFromCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('gtfsData');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de la récup cache', error);
        return null;
    }
}

async function extractGTFSFiles() {
    try {
        toastBottomRight.info('Mise à jour de la base de données dynamiques. Cette opération va prendre quelques secondes 🙂');


        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`Échec téléchargement ${response.status} ${response.statusText}`);
            toastBottomRight.warning('Oups ! Une erreur s\'est produite... avez vous actualisé la page ?');

        }
        
        const zipData = await response.arrayBuffer();
        
        const fileHash = await calculateSHA256(zipData.slice(0, Math.min(zipData.byteLength, 1024 * 50)));
        
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        
        const filePromises = [];
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        
        const metadata = {
            fileHash,
            lastUpdate: new Date().toISOString()
        };
        
        return { extractedFiles, metadata };
    } catch (error) {
        throw error;
    }
}

function parseCSVLine(csvLine) {
    const result = [];
    let currentValue = '';
    let insideQuotes = false;

    for (let i = 0; i < csvLine.length; i++) {
        const char = csvLine[i];
        
        if (char === '"') {
            insideQuotes = !insideQuotes;
        } else if (char === ',' && !insideQuotes) {
            result.push(currentValue);
            currentValue = '';
        } else {
            currentValue += char;
        }
    }
    
    result.push(currentValue);
    
    return result.map(value => {
        if (value.startsWith('"') && value.endsWith('"')) {
            return value.slice(1, -1);
        }
        return value;
    });
}

async function loadLineColors(routesFileContent) {
    try {
        if (!routesFileContent) {
            console.warn('Aucun contenu de fichier routes fourni');
            return;
        }
        
        if (typeof routes === 'undefined') window.routes = {};
        if (typeof lineColors === 'undefined') window.lineColors = {};
        if (typeof lineName === 'undefined') window.lineName = {};
        
        const data = await getSetvar();
        if (!data) {
            console.error('Échec récupération variables de config');
            return;
        }
       
        const lines = routesFileContent.split(/\r\n|\n/);
       
        const headers = parseCSVLine(lines[0]);
        const routeIdIndex = headers.indexOf('route_id');
        const shortNameIndex = headers.indexOf('route_short_name');
        const longNameIndex = headers.indexOf('route_long_name');
        const routeTypeIndex = headers.indexOf('route_type');
        const routeColorIndex = headers.indexOf('route_color');
        const routeTextColorIndex = headers.indexOf('route_text_color');
        const agencyIdIndex = headers.indexOf('agency_id');
       
        if (routeIdIndex === -1) {
            return;
        }
        
        if (routeColorIndex === -1) {
            console.warn('route_color non trouvée, les couleurs par défaut seront utilisées');
        }
        
        const startIndex = data.slicelinecolor ? parseInt(data.slicelinecolor) : 1;
       
        lines.slice(startIndex).forEach(line => {
            if (!line.trim()) return;
           
            const values = parseCSVLine(line);
            if (values.length <= routeIdIndex) {
                console.warn('Ligne ignorer dans routes txt, données incomplètes', line);
                return;
            }
           
            const routeId = values[routeIdIndex];
            if (routeId) {
                routes[routeId] = {
                    short_name: shortNameIndex !== -1 && values[shortNameIndex] ? values[shortNameIndex] : '',
                    long_name: longNameIndex !== -1 && values[longNameIndex] ? values[longNameIndex] : '',
                    route_type: routeTypeIndex !== -1 ? parseInt(values[routeTypeIndex] || '0', 10) : 0,
                    route_color: routeColorIndex !== -1 && values[routeColorIndex] ? `#${values[routeColorIndex]}` : '#FFFFFF',
                    route_text_color: routeTextColorIndex !== -1 && values[routeTextColorIndex] ? `#${values[routeTextColorIndex]}` : '#000000',
                    agency_id: agencyIdIndex !== -1 ? values[agencyIdIndex] : null
                };
                
                let routeColor = routeColorIndex !== -1 ? values[routeColorIndex] : '';
                if (routeColor && !routeColor.startsWith('#') && routeColor.trim() !== '') {
                    routeColor = `#${routeColor}`;
                } else if (!routeColor) {
                    routeColor = '#FFFFFF'; 
                }
                
                const routeDisplayName = shortNameIndex !== -1 && values[shortNameIndex] ? 
                    values[shortNameIndex] : 
                    (longNameIndex !== -1 && values[longNameIndex] ? values[longNameIndex] : '');
                
                let cleanedLineName = routeDisplayName ? routeDisplayName.replace(/\"/g, '').trim() : '';
                
                lineColors[routeId] = routeColor;
                lineName[routeId] = cleanedLineName;
            }
        });
       
        
    } catch (error) {
        console.error('Errreur lors du chargement des itineraires et couleurs', error);
    }
}

async function loadStopIds(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        
        if (stopIdIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    let stopId = columns[stopIdIndex];
                    
                    stopId = stopId.replace(/\"/g, '');
                    
                    if (stopId) {
                        stopIds.push(stopId);
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadLineTerminusData(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        const stopNameIndex = headers.indexOf('stop_name');
        
        if (stopIdIndex !== -1 && stopNameIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    let stopId = columns[stopIdIndex];
                    let stopName = columns[stopNameIndex];
                    
                    stopId = stopId.replace(/\"/g, '');
                    stopName = stopName.replace(/\"/g, '');
                    
                    if (stopId && stopName) {
                        stopNameMap[stopId] = stopName;
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function initializeGTFS() {
    try {
        Object.keys(lineColors).forEach(key => delete lineColors[key]);
        Object.keys(lineName).forEach(key => delete lineName[key]);
        stopIds.length = 0;
        Object.keys(stopNameMap).forEach(key => delete stopNameMap[key]);
        
        let extractedFiles;
        
        const { needsUpdate, fileHash, metadata } = await checkGTFSUpdate();
        
        if (needsUpdate) {
            const result = await extractGTFSFiles();
            extractedFiles = result.extractedFiles;
            
            await saveToCache(extractedFiles, result.metadata);
            
        } else {
            extractedFiles = await getFromCache();
            if (!extractedFiles) {
                const result = await extractGTFSFiles();
                extractedFiles = result.extractedFiles;
                await saveToCache(extractedFiles, result.metadata);
                toastBottomRight.success('Données téléchargées avec succès !');
            } 
        }
        
        if (extractedFiles['routes.txt']) {
            await loadLineColors(extractedFiles['routes.txt']);
        }
        
        if (extractedFiles['stops.txt']) {
            await loadStopIds(extractedFiles['stops.txt']);
            await loadLineTerminusData(extractedFiles['stops.txt']);
        } else {
            console.error('Fichier stops.txt non trouvé');
        }
        
        return {
            lineColors,
            lineName,
            stopIds,
            stopNameMap
        };
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation data théorique gtfs', error);
        throw error;
    }
}

async function clearGTFSCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
                toastBottomRight.success('MBF3 : Cache erased successfully !!');
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de l\'effacement du cache', error);
        toastBottomRight.error('Erreur lors de l\'effacement du cache');
        throw error;
    }
}

async function decodeProtobuf(buffer) {
            const root = await protobuf.load('gtfs-realtime.proto');
            const FeedMessage = root.lookupType('transit_realtime.FeedMessage');
            const message = FeedMessage.decode(new Uint8Array(buffer));
            return FeedMessage.toObject(message, { longs: String });
        }

        window.addEventListener('message', function(event) {
    if (event.data.type === 'vehicleSelected') {
        const vehicleId = event.data.vehicleId;
        const tripId = event.data.tripId;
        const stopId = event.data.stopId;
        const routeId = event.data.routeId;
        
        const marker = findMarkerByVehicleId(vehicleId);
        if (marker) {
            map.setView(marker.getLatLng(), 17);
            
            marker.openPopup();
            
            const menu = document.getElementById('menu');
            const map = document.getElementById('map');
                menu.classList.add('hidden');
            if (localStorage.getItem('transparency') === 'true') {
                const map = document.getElementById('map');
                map.classList.remove('hiddennotransition');
                map.classList.add('appearnotransition');
                map.classList.remove('hidden');
                map.classList.remove('appear');
            } else {
                const map = document.getElementById('map');
                map.classList.remove('hidden');
                map.classList.add('appear');
                map.classList.remove('hiddennotransition');
                map.classList.remove('appearnotransition');
            }
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false;
            
            if (selectedLine) {
                resetMapView();
            }
        }
    }
});

function findMarkerByVehicleId(vehicleId) {
    for (const [id, marker] of Object.entries(markers)) {
        if (marker.id === vehicleId) {
            return marker;
        }
    }
    return null;
}

let lastActiveMarkerId = null;

let lastActiveColor = null;
window.isMenuShowed = false;


function createColoredMarker(lat, lon, route_id, bearing = 0) {
    const generateUniqueId = () => `popup-style-${Math.random().toString(36).substr(2, 9)}`;
    
    const color = lineColors[route_id] || '#000000';
    const markerHtmlStyles = `
        background-color: ${color};
        width: 12px;
        height: 12px;
        display: block;
        left: -6px;
        top: -6px;
        position: relative;
        border-radius: 50%;
        border: 2px solid white;
        transition: transform 0.2s ease, background-color 0.3s ease;
    `;

    const arrowSvg = `
        <svg class="marker-arrow" style="
            position: absolute;
            width: 16px;
            height: 16px;
            left: 4px;
            top: -2px;
            transform-origin: 2px; 
            transform: rotate(${bearing - 90}deg);
            transition: transform 0.5s ease;"
            viewBox="0 0 24 24">
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="white"
                stroke-width="6"
                stroke-linecap="round"
                stroke-linejoin="round"
            />
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="${color}"
                stroke-width="3"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="marker-arrow-path"
            />
        </svg>
    `;

    const icon = L.divIcon({
        className: "my-custom-pin",
        iconAnchor: [0, 0],
        popupAnchor: [0, 5],
        html: `
            <div style="position: relative;">
                <span style="${markerHtmlStyles}" class="marker-icon" />
                ${arrowSvg}
            </div>
        `
    });

    const marker = L.marker([lat, lon], { icon });
    const styleId = generateUniqueId();
    
    marker.on('popupopen', function(e) {
        const menubtm = document.getElementById('menubtm');
        const filtre = document.getElementById('filtre');
            safeVibrate([50]);

        if (menubtm) {
            const markerId = marker.id;
            const color = lineColors[route_id] || '#000000';
            

            if (lastActiveMarkerId !== null && lastActiveMarkerId !== markerId && lastActiveColor !== null) {
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                    function getOptimalTextColor(bgColor, options = {}) {
                    const {
                        contrastRatio = 4.5,
                        darkColor = '#1a1a1a',
                        lightColor = '#f8f9fa',
                        useGradient = false 
                    } = options;

                    let r, g, b, a = 1;

                    if (!bgColor) return darkColor;

                    bgColor = bgColor.trim();

                    if (bgColor.startsWith('rgb')) {
                        const values = bgColor.match(/\d+(\.\d+)?/g);
                        if (values) {
                            r = parseInt(values[0]);
                            g = parseInt(values[1]);
                            b = parseInt(values[2]);
                            a = values[3] ? parseFloat(values[3]) : 1;
                        } else {
                            return darkColor;
                        }
                    } else {
                        if (/^#([a-f\d])([a-f\d])([a-f\d])$/i.test(bgColor)) {
                            bgColor = bgColor.replace(/^#([a-f\d])([a-f\d])([a-f\d])$/i,
                                (_, r, g, b) => '#' + r + r + g + g + b + b);
                        }

                        if (bgColor.length === 7) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                        } else if (bgColor.length === 9) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else if (bgColor.length === 8 && bgColor.startsWith('#')) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else {
                            return darkColor;
                        }
                    }

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    const srgb = [r, g, b].map(c => {
                        const val = c / 255;
                        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                    });
                    const luminance = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];

                    const getLuminance = (color) => {
                        const hex = color.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16) / 255;
                        const g = parseInt(hex.substr(2, 2), 16) / 255;
                        const b = parseInt(hex.substr(4, 2), 16) / 255;
                        const srgb = [r, g, b].map(c => 
                            c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                        );
                        return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
                    };

                    const darkLuminance = getLuminance(darkColor);
                    const lightLuminance = getLuminance(lightColor);

                    const contrastWithDark = luminance > darkLuminance 
                        ? (luminance + 0.05) / (darkLuminance + 0.05)
                        : (darkLuminance + 0.05) / (luminance + 0.05);
                    
                    const contrastWithLight = luminance > lightLuminance 
                        ? (luminance + 0.05) / (lightLuminance + 0.05)
                        : (lightLuminance + 0.05) / (luminance + 0.05);

                    if (contrastWithDark >= contrastRatio && contrastWithLight >= contrastRatio) {
                        return luminance > 0.18 ? darkColor : lightColor;
                    } else if (contrastWithDark >= contrastRatio) {
                        return darkColor;
                    } else if (contrastWithLight >= contrastRatio) {
                        return lightColor;
                    } else {

                        if (luminance < 0.18) {
                            return lightColor; 
                        }
                        return contrastWithDark > contrastWithLight ? darkColor : lightColor;
                    }
                    
                    }

                    const textColor = getOptimalTextColor(color);

                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                    #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            } else {
                const currentColor = window.getComputedStyle(menubtm).backgroundColor;
                
                    function getOptimalTextColor(bgColor, options = {}) {
                    const {
                        contrastRatio = 4.5,
                        darkColor = '#1a1a1a',
                        lightColor = '#f8f9fa',
                        useGradient = false 
                    } = options;

                    let r, g, b, a = 1;

                    if (!bgColor) return darkColor;

                    bgColor = bgColor.trim();

                    if (bgColor.startsWith('rgb')) {
                        const values = bgColor.match(/\d+(\.\d+)?/g);
                        if (values) {
                            r = parseInt(values[0]);
                            g = parseInt(values[1]);
                            b = parseInt(values[2]);
                            a = values[3] ? parseFloat(values[3]) : 1;
                        } else {
                            return darkColor;
                        }
                    } else {
                        if (/^#([a-f\d])([a-f\d])([a-f\d])$/i.test(bgColor)) {
                            bgColor = bgColor.replace(/^#([a-f\d])([a-f\d])([a-f\d])$/i,
                                (_, r, g, b) => '#' + r + r + g + g + b + b);
                        }

                        if (bgColor.length === 7) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                        } else if (bgColor.length === 9) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else if (bgColor.length === 8 && bgColor.startsWith('#')) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else {
                            return darkColor;
                        }
                    }

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    const srgb = [r, g, b].map(c => {
                        const val = c / 255;
                        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                    });
                    const luminance = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];

                    const getLuminance = (color) => {
                        const hex = color.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16) / 255;
                        const g = parseInt(hex.substr(2, 2), 16) / 255;
                        const b = parseInt(hex.substr(4, 2), 16) / 255;
                        const srgb = [r, g, b].map(c => 
                            c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                        );
                        return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
                    };

                    const darkLuminance = getLuminance(darkColor);
                    const lightLuminance = getLuminance(lightColor);

                    const contrastWithDark = luminance > darkLuminance 
                        ? (luminance + 0.05) / (darkLuminance + 0.05)
                        : (darkLuminance + 0.05) / (luminance + 0.05);
                    
                    const contrastWithLight = luminance > lightLuminance 
                        ? (luminance + 0.05) / (lightLuminance + 0.05)
                        : (lightLuminance + 0.05) / (luminance + 0.05);

                    if (contrastWithDark >= contrastRatio && contrastWithLight >= contrastRatio) {
                        return luminance > 0.18 ? darkColor : lightColor;
                    } else if (contrastWithDark >= contrastRatio) {
                        return darkColor;
                    } else if (contrastWithLight >= contrastRatio) {
                        return lightColor;
                    } else {

                        if (luminance < 0.18) {
                            return lightColor; 
                        }
                        return contrastWithDark > contrastWithLight ? darkColor : lightColor;
                    }
                    }

                    const textColor = getOptimalTextColor(color);

                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                        #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            }
            
            lastActiveMarkerId = markerId;
            lastActiveColor = color;
        }
    });

    marker.on('popupclose', async function(e) {
    const menubtm = document.getElementById('menubtm');
    const filtre = document.getElementById('filtre');
    safeVibrate([50]);
    
    if (menubtm && filtre) {
        try {
            setTimeout(async () => {
                if (lastActiveMarkerId === marker.id) {
                    const data = await getSetvar();
                    
                    if (data) {
                        const menubtmCurrentTransition = window.getComputedStyle(menubtm).transition;
                        const filtreCurrentTransition = window.getComputedStyle(filtre).transition;
                        
                        if (!menubtmCurrentTransition.includes('background-color')) {
                            menubtm.style.transition = menubtmCurrentTransition 
                                ? `${menubtmCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        if (!filtreCurrentTransition.includes('background-color')) {
                            filtre.style.transition = filtreCurrentTransition 
                                ? `${filtreCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        menubtm.style.backgroundColor = `${window.colorbkg9c}`;
                        filtre.style.backgroundColor = `${window.colorbkg9c}`;
                        
                        document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                        const styleSheet = document.createElement('style');
                        styleSheet.id = styleId;
                        styleSheet.classList.add('menu-color-style');
                        
                    function getOptimalTextColor(bgColor, options = {}) {
                    const {
                        contrastRatio = 4.5,
                        darkColor = '#1a1a1a',
                        lightColor = '#f8f9fa',
                        useGradient = false 
                    } = options;

                    let r, g, b, a = 1;

                    if (!bgColor) return darkColor;

                    bgColor = bgColor.trim();

                    if (bgColor.startsWith('rgb')) {
                        const values = bgColor.match(/\d+(\.\d+)?/g);
                        if (values) {
                            r = parseInt(values[0]);
                            g = parseInt(values[1]);
                            b = parseInt(values[2]);
                            a = values[3] ? parseFloat(values[3]) : 1;
                        } else {
                            return darkColor;
                        }
                    } else {
                        if (/^#([a-f\d])([a-f\d])([a-f\d])$/i.test(bgColor)) {
                            bgColor = bgColor.replace(/^#([a-f\d])([a-f\d])([a-f\d])$/i,
                                (_, r, g, b) => '#' + r + r + g + g + b + b);
                        }

                        if (bgColor.length === 7) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                        } else if (bgColor.length === 9) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else if (bgColor.length === 8 && bgColor.startsWith('#')) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else {
                            return darkColor;
                        }
                    }

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    const srgb = [r, g, b].map(c => {
                        const val = c / 255;
                        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                    });
                    const luminance = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];

                    const getLuminance = (color) => {
                        const hex = color.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16) / 255;
                        const g = parseInt(hex.substr(2, 2), 16) / 255;
                        const b = parseInt(hex.substr(4, 2), 16) / 255;
                        const srgb = [r, g, b].map(c => 
                            c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                        );
                        return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
                    };

                    const darkLuminance = getLuminance(darkColor);
                    const lightLuminance = getLuminance(lightColor);

                    const contrastWithDark = luminance > darkLuminance 
                        ? (luminance + 0.05) / (darkLuminance + 0.05)
                        : (darkLuminance + 0.05) / (luminance + 0.05);
                    
                    const contrastWithLight = luminance > lightLuminance 
                        ? (luminance + 0.05) / (lightLuminance + 0.05)
                        : (lightLuminance + 0.05) / (luminance + 0.05);

                    if (contrastWithDark >= contrastRatio && contrastWithLight >= contrastRatio) {
                        return luminance > 0.18 ? darkColor : lightColor;
                    } else if (contrastWithDark >= contrastRatio) {
                        return darkColor;
                    } else if (contrastWithLight >= contrastRatio) {
                        return lightColor;
                    } else {

                        if (luminance < 0.18) {
                            return lightColor; 
                        }
                        return contrastWithDark > contrastWithLight ? darkColor : lightColor;
                    }

                }

                    const textColor = getOptimalTextColor(color);

                        
                        styleSheet.textContent = `
                            #menubtm * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }

                            #filtre * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }
                        `;
                        
                        document.head.appendChild(styleSheet);
                        
                        lastActiveMarkerId = null;
                        lastActiveColor = null;
                        
                        if (marker.styleId) {
                            const oldStyle = document.getElementById(marker.styleId);
                            if (oldStyle) {
                                setTimeout(() => {
                                    oldStyle.remove();
                                }, 500);
                            }
                        }
                    }
                }
            }, 50); 
        } catch (error) {
            return false;
        }
    }
});
    return marker;
}

function animateMarker(marker, newPosition) {
    const startLatLng = marker.getLatLng();
    const endLatLng = L.latLng(newPosition[0], newPosition[1]);
    const duration = 1000; 
    const startTime = performance.now();

    if (marker.animationFrame) {
        cancelAnimationFrame(marker.animationFrame);
    }

    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function animate(time) {
        const elapsed = time - startTime;
        const linearProgress = Math.min(elapsed / duration, 1);
        
        const easedProgress = easeInOutQuad(linearProgress);
        
        const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * easedProgress;
        const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * easedProgress;
        
        marker.setLatLng([lat, lng]);

        if (linearProgress < 1) {
            marker.animationFrame = requestAnimationFrame(animate);
        }
    }

    marker.animationFrame = requestAnimationFrame(animate);
}

let busStopLayers = [];
let selectedLines = [];




async function loadGeoJsonLines() {
    const response = await fetch('proxy-cors/proxy_geojson.php');
    const geoJsonData = await response.json();

    const busLines = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry.type === 'LineString';
        },
        style: function(feature) {
            return {
                color: lineColors[feature.properties.route_id] || '#3388ff',
                weight: 6,
                opacity: 0.7,  
                lineJoin: 'round',
                lineCap: 'round',
                className: 'bus-line', 
                dashArray: feature.properties.route_type === '3' ? '5, 5' : null
            };
        },
        onEachFeature: function(feature, layer) {
            
            if (feature.properties && feature.properties.route_id) {
                geoJsonLines.push(layer);
            }
        }
    }).addTo(map);

    const busStops = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry && feature.geometry.type === 'Point';
        },
        pointToLayer: function(feature, latlng) {
            return L.circleMarker(latlng, {
                radius: 3,
                fillColor: '#ffffff',
                color: '#000000',
                weight: 0.5,
                opacity: 0.7,
                fillOpacity: 0.6
            });
        }
    }).addTo(map);
    
    busStops.eachLayer(function(layer) {
        if (layer.feature && layer.feature.properties) {
            layer.busLine = layer.feature.properties.route_id || null;
            busStopLayers.push(layer);
        }
    });
    
}



function filterByLine(lineId) {
  const lineIndex = selectedLines.indexOf(lineId);

  if (lineIndex !== -1) {
    selectedLines.splice(lineIndex, 1);
  } else {
    selectedLines.push(lineId);
  }

  updateLinesDisplay();

  if (selectedLines.length === 0) {
    const filtre = document.getElementById('filtre');
    filtre.classList.add('slide-upc');
    filtre.classList.remove('slide-downc');
    filtre.addEventListener('animationend', () => {
        filtre.style.display = 'none';
    });
    resetMapView();
  } else if (selectedLines.length === 1) {
    zoomToSelectedLine(selectedLines[0]);
  } else if (selectedLines.length > 1) {
    zoomToMultipleLines(selectedLines);
  }
}

function zoomToSelectedLine(lineId) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (layer.feature.properties.route_id === lineId) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [10, 10], 
      maxZoom: 17        
    });
  }
}

function zoomToMultipleLines(lineIds) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (lineIds.includes(layer.feature.properties.route_id)) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [50, 50], 
      maxZoom: 15       
    });
  }
}

function updateLinesDisplay() {
  geoJsonLines.forEach(layer => {
    const routeId = layer.feature.properties.route_id;

    if (selectedLines.length === 0 || selectedLines.includes(routeId)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  busStopLayers.forEach(layer => {
    const busLine = layer.busLine;
    
    if (selectedLines.length === 0 || selectedLines.includes(busLine)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  Object.entries(markers).forEach(([id, marker]) => {
    if (selectedLines.length === 0 || selectedLines.includes(marker.line)) {
      if (!map.hasLayer(marker)) {
        map.addLayer(marker);
      }
    } else {
      if (map.hasLayer(marker)) {
        if (marker.isPopupOpen()) {
          marker.closePopup();
        }
        map.removeLayer(marker);
      }
    }
  });
}

function resetMapView() {
    selectedLines = [];

    selectedLine = null;

    geoJsonLines.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    busStopLayers.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    Object.values(markers).forEach(marker => {
        if (!map.hasLayer(marker)) {
            map.addLayer(marker);
        }
    });
}

function showPopup() {
    const popup2 = document.getElementById('popup2');

    popup2.style.display = 'block';
    

    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
                const filtre = document.getElementById('filtre');
                filtre.classList.add('slide-upc');
                filtre.classList.remove('slide-downc');
                filtre.addEventListener('animationend', () => {
                    filtre.style.display = 'none';
                });
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });



}

function closePopup() {
    const popup2 = document.getElementById('popup2');
    popup2.style.display = 'none';
    const menubottom1 = document.getElementById('menubtm');
            const menu = document.getElementById('menu');
            const map = document.getElementById('map');
            menu.classList.add('hidden');
            if (localStorage.getItem('transparency') === 'true') {
                const map = document.getElementById('map');
                map.classList.remove('hiddennotransition');
                map.classList.add('appearnotransition');
                map.classList.remove('hidden');
                map.classList.remove('appear');
            } else {
                const map = document.getElementById('map');
                map.classList.remove('hidden');
                map.classList.add('appear');
                map.classList.remove('hiddennotransition');
                map.classList.remove('appearnotransition');
            }
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);


}



const filtre = document.getElementById('filtre');
    filtre.onclick = () => {
        if (selectedLine) {
            filtre.classList.add('slide-upc');
            filtre.classList.remove('slide-downc');
            filtre.addEventListener('animationend', () => {
                filtre.style.display = 'none';
            });
    resetMapView();
    }
};










async function loadVehicleModels() {
    try {
        const response = await fetch('setvar/vehicules/index.php');
        const fileList = await response.json();
        
        for (const file of fileList) {
            if (file.endsWith('.txt')) {
                await loadVehicleModelFile(file);
            }
        }
        
    } catch (error) {
        console.error('Erreur lors du chargement des modèles de véhicules ', error);
        toastBottomRight.error('Erreur lors du chargement des modèles de véhicules ', error);
    }
}

async function loadVehicleModelFile(fileName) {
    try {
        const response = await fetch(`setvar/vehicules/${fileName}`);
        const content = await response.text();
        const lines = content.split('\n').map(line => line.trim()).filter(line => line !== '');
        
        if (lines.length < 8) {
            console.error(`Format invalide pour le fichier ${fileName}`);
            toastBottomRight.error(`Format invalide pour le fichier ${fileName}`);
            return;
        }
        
        const modelName = lines[0];
        const thumbnailPath = lines[1];
        
        const params = {
            isElectric: parseParamValue(lines[2]),       
            isHybrid: parseParamValue(lines[3]),       
            isGnv: parseParamValue(lines[4]),     
            isUsbPlugs: parseParamValue(lines[5]),  
            isAirConditioned: parseParamValue(lines[6]), 
            isHeatingUnit: parseParamValue(lines[7])
        };
        
        const vehicleIds = lines.slice(8);
        
        const modelKey = fileName.replace('.txt', '');
        
        vehicleModels[modelKey] = {
            name: modelName,
            thumbnail: thumbnailPath,
            params: params,
            vehicles: new Set(vehicleIds)
        };
        
        vehicleIds.forEach(id => {
            if (params.isElectric) vehicleTypes['elec'].add(id);
            if (params.isHybrid) vehicleTypes['hybrid'].add(id);
            if (params.isGnv) vehicleTypes['gnv'].add(id);
            if (params.isUsbPlugs) vehicleTypes['usb'].add(id);
            if (params.isAirConditioned || params.isHeatingUnit) vehicleTypes['clim'].add(id);
        });
        
    } catch (error) {
        console.error(`Erreur lors du chargement du fichier ${fileName}:`, error);
        toastBottomRight.error('Une erreur est survenue.');

    }
}

function parseParamValue(paramLine) {
    const parts = paramLine.split('=');
    if (parts.length !== 2) return false;
    
    return parts[1].toLowerCase() === 'true';
}

function getVehicleModel(parkNumber) {
    const parkId = String(parkNumber);    
    for (const [modelKey, model] of Object.entries(vehicleModels)) {
        if (model.vehicles.has(parkId)) {
            return model;
        }
    }
    return null;
}

function getVehicleOptionsBadges(parkNumber) {
    const model = getVehicleModel(parkNumber);
    let badges = '';
    
    if (model) {
        const params = model.params;
        
        const badgeStyle = `
            padding: 6px 10px; 
            background: #00000077; 
            font-weight: normal; 
            white-space: nowrap; 
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 10px; 
            display: inline-flex; 
            align-items: center; 
            gap: 6px;
            height: 20px;
        `;
        
        const svgStyle = `
            display: inline-block;
            vertical-align: top;
            position: relative;
            top: -1px;
        `;
        
        const textStyle = `
            display: inline-block;
            line-height: 20px;
            vertical-align: middle;
            position: relative;
            top: 1px;
        `;

        if (params.isElectric) {
            badges += `<span style="${badgeStyle}">
                <img src="src/elec.png" alt="Électrique" style="height: 20px;">
            </span> `;
        }
        if (params.isHybrid) {
            badges += `<span style="${badgeStyle}">
                <img src="src/hyb.png" alt="Hybride" style="height: 20px;">
            </span> `;
        }
        if (params.isGnv) {
            badges += `<span style="${badgeStyle}">
                <img src="src/gnv.png" alt="Gaz Naturel" style="height: 20px;">
            </span> `;
        }
        if (params.isUsbPlugs) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle cx="12" cy="17" r="1" stroke="#ffffff" stroke-width="1.5"></circle> <circle cx="8" cy="9" r="1" stroke="#ffffff" stroke-width="1.5"></circle> <path d="M11.25 16C11.25 16.4142 11.5858 16.75 12 16.75C12.4142 16.75 12.75 16.4142 12.75 16H11.25ZM12 6L12.5303 5.46967C12.2374 5.17678 11.7626 5.17678 11.4697 5.46967L12 6ZM12.4697 7.53033C12.7626 7.82322 13.2374 7.82322 13.5303 7.53033C13.8232 7.23744 13.8232 6.76256 13.5303 6.46967L12.4697 7.53033ZM10.4697 6.46967C10.1768 6.76256 10.1768 7.23744 10.4697 7.53033C10.7626 7.82322 11.2374 7.82322 11.5303 7.53033L10.4697 6.46967ZM11.4697 6.53033L12.4697 7.53033L13.5303 6.46967L12.5303 5.46967L11.4697 6.53033ZM11.4697 5.46967L10.4697 6.46967L11.5303 7.53033L12.5303 6.53033L11.4697 5.46967ZM12.75 16V14.125H11.25V16H12.75ZM12.75 14.125V6H11.25V14.125H12.75Z" fill="#ffffff"></path> <path d="M8 10V11.0296C8 11.9044 8.5685 12.6777 9.40345 12.9386L10.8069 13.3772C11.5167 13.599 12 14.2563 12 15" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M16 11V12.0296C16 12.9044 15.4315 13.6777 14.5966 13.9386L13.1931 14.3772C12.4833 14.599 12 15.2563 12 16" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M15 10C15 9.5286 15 9.29289 15.1464 9.14645C15.2929 9 15.5286 9 16 9C16.4714 9 16.7071 9 16.8536 9.14645C17 9.29289 17 9.5286 17 10C17 10.4714 17 10.7071 16.8536 10.8536C16.7071 11 16.4714 11 16 11C15.5286 11 15.2929 11 15.1464 10.8536C15 10.7071 15 10.4714 15 10Z" stroke="#ffffff" stroke-width="1.5"></path> <path d="M7 3.33782C8.47087 2.48697 10.1786 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 10.1786 2.48697 8.47087 3.33782 7" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>             
                <span style="${textStyle}">${t("usb")}</span>
            </span> `;
        }
        if (params.isAirConditioned) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g id="a"></g> <g id="b"> <path d="M29,8v5c0,1.1-.9,2-2,2h-1.21l-.1-1H6.31l-.1,1h-1.21c-1.1,0-2-.9-2-2v-5c0-1.1,.9-2,2-2H27c1.1,0,2,.9,2,2Z" style="fill:#ffffff;"></path> <path d="M27,5H5c-1.6543,0-3,1.3457-3,3v5c0,1.6543,1.3457,3,3,3h.098l-.0926,.8975c-.0293,.2812,.0625,.562,.252,.7725,.1899,.21,.4595,.3301,.7427,.3301H26c.2832,0,.5527-.1201,.7427-.3301,.1895-.2104,.2812-.4912,.252-.7725l-.0926-.8975h.098c1.6543,0,3-1.3457,3-3v-5c0-1.6543-1.3457-3-3-3ZM7.1084,16l.1035-1H24.7881l.1035,1H7.1084Zm20.8916-3c0,.5513-.4487,1-1,1h-.3044l-.0106-.1025c-.0527-.5098-.4819-.8975-.9946-.8975H6.3096c-.5127,0-.9419,.3877-.9946,.8975l-.0106,.1025h-.3044c-.5513,0-1-.4487-1-1v-5c0-.5513,.4487-1,1-1H27c.5513,0,1,.4487,1,1v5Zm-1-3c0,.5522-.4478,1-1,1h-1c-.5522,0-1-.4478-1-1s.4478-1,1-1h1c.5522,0,1,.4478,1,1Zm-4,0c0,.5522-.4478,1-1,1h-1c-.5522,0-1-.4478-1-1s.4478-1,1-1h1c.5522,0,1,.4478,1,1Zm-1.3291,15.2422c.4097,.3706,.4414,1.0029,.0708,1.4126-.1973,.2183-.4692,.3291-.7422,.3291-.2393,0-.479-.0854-.6704-.2583-2.5371-2.2954-2.3774-6.5806-2.3696-6.7622,.0244-.5513,.4976-.9932,1.0415-.9536,.5508,.0234,.979,.4893,.9565,1.0405-.0015,.0352-.1216,3.5322,1.7134,5.1919Zm6.2363-.8213c-.1694,.3647-.5308,.5791-.9077,.5791-.1411,0-.2842-.0298-.4204-.0928-.1099-.0513-2.6978-1.2852-3.667-4.624-.1538-.5303,.1514-1.0854,.6816-1.2393,.5322-.1538,1.0854,.1514,1.2393,.6816,.707,2.4355,2.5693,3.3589,2.5879,3.3672,.501,.2324,.7188,.8271,.4863,1.3281Zm-13.8667-4.4575c.0078,.1816,.1675,4.4668-2.3696,6.7622-.1914,.1729-.4312,.2583-.6704,.2583-.2729,0-.5444-.1108-.7422-.3291-.3706-.4097-.3389-1.042,.0708-1.4126,1.5327-1.3862,1.7563-4.2168,1.7134-5.1899-.0244-.5518,.4028-1.019,.9546-1.0435,.5381-.0249,1.0186,.4023,1.0435,.9546Zm-4.9526,.3198c-.9692,3.3389-3.5571,4.5728-3.667,4.624-.1362,.063-.2793,.0928-.4204,.0928-.377,0-.7383-.2144-.9077-.5791-.2314-.499-.0161-1.0913,.481-1.3257,.0938-.0454,1.8901-.9468,2.5933-3.3696,.1538-.5303,.7065-.8359,1.2393-.6816,.5303,.1538,.8354,.709,.6816,1.2393Z" style="fill:#ffffff;"></path> </g> </g></svg>
                <span style="${textStyle}">${t("ac")}</span>
            </span> `;
        }
        if (params.isHeatingUnit) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path style="fill:#ffffff;" d="M465.94,475.301h-70.358c-7.484,0-13.553-6.068-13.553-13.553s6.069-13.553,13.553-13.553h70.358 c10.452,0,18.955-8.503,18.955-18.955V182.167c0-10.452-8.503-18.955-18.955-18.955H137.925c-10.452,0-18.955,8.503-18.955,18.955 v247.073c0,10.452,8.503,18.955,18.955,18.955h182.984c7.484,0,13.553,6.068,13.553,13.553s-6.069,13.553-13.553,13.553H137.925 c-25.398,0-46.06-20.663-46.06-46.06V182.167c0-25.398,20.663-46.06,46.06-46.06H465.94c25.398,0,46.06,20.663,46.06,46.06v247.073 C512,454.637,491.337,475.301,465.94,475.301z"></path> <path style="fill:#ffffff;" d="M190.663,411.956L190.663,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C214.333,401.304,203.68,411.956,190.663,411.956 z"></path> <path style="fill:#ffffff;" d="M190.663,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221s37.223,16.697,37.223,37.221v165.167C227.884,408.811,211.187,425.508,190.663,425.508z M190.663,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117 V223.118C200.779,217.541,196.241,213.004,190.663,213.004z"></path> <path style="fill:#ffffff;" d="M301.932,411.956L301.932,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C325.601,401.304,314.95,411.956,301.932,411.956 z"></path> <path style="fill:#ffffff;" d="M301.931,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221c20.526,0,37.223,16.697,37.223,37.221v165.167 C339.154,408.811,322.457,425.508,301.931,425.508z M301.931,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166 c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117V223.118C312.048,217.541,307.509,213.004,301.931,213.004z"></path> <path style="fill:#ffffff;" d="M413.202,411.956L413.202,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C436.87,401.304,426.219,411.956,413.202,411.956 z"></path> <g> <path style="fill:#ffffff;" d="M413.202,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221s37.223,16.697,37.223,37.221v165.167C450.424,408.811,433.726,425.508,413.202,425.508z M413.202,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117 V223.118C423.319,217.541,418.78,213.004,413.202,213.004z"></path> <path style="fill:#ffffff;" d="M105.416,230.486H58.277c-7.484,0-13.553-6.068-13.553-13.553c0-7.485,6.069-13.553,13.553-13.553 h47.139c7.484,0,13.553,6.068,13.553,13.553C118.969,224.418,112.901,230.486,105.416,230.486z"></path> <path style="fill:#ffffff;" d="M105.416,408.027H58.277c-7.484,0-13.553-6.068-13.553-13.553c0-7.485,6.069-13.553,13.553-13.553 h47.139c7.484,0,13.553,6.068,13.553,13.553C118.969,401.959,112.901,408.027,105.416,408.027z"></path> <path style="fill:#ffffff;" d="M47.435,251.51c-7.484,0-13.553-6.068-13.553-13.553V92.943c0-7.485,6.069-13.553,13.553-13.553 s13.553,6.068,13.553,13.553v145.014C60.987,245.442,54.918,251.51,47.435,251.51z"></path> <path style="fill:#ffffff;" d="M47.435,475.301c-7.484,0-13.553-6.068-13.553-13.553V305.703c0-7.485,6.069-13.553,13.553-13.553 s13.553,6.068,13.553,13.553v156.045C60.987,469.234,54.918,475.301,47.435,475.301z"></path> </g> <rect x="13.553" y="50.253" style="fill:#ffffff;" width="67.764" height="73.185"></rect> <path style="fill:#ffffff;" d="M81.317,136.989H13.553C6.069,136.989,0,130.922,0,123.436V50.252 c0-7.485,6.069-13.553,13.553-13.553h67.764c7.484,0,13.553,6.068,13.553,13.553v73.185C94.869,130.922,88.8,136.989,81.317,136.989 z M27.106,109.884h40.658V63.804H27.106V109.884z"></path> </g></svg>
                <span style="${textStyle}">${t("hot")}</span>
            </span> `;
        }
    } 
    
    return badges;
}

function getVehicleBrandHtml(parkNumber) {
    const model = getVehicleModel(parkNumber);
    const defaultImagePath = "src/generic.png";
    
    if (model) {
        return `
            <div class="vehicle-model">

                <img src="${model.thumbnail}" 
                     onerror="this.onerror=null; this.src='${defaultImagePath}';" 
                     alt="Thumbnail ${model.name}" 
                     class="vehicle-thumbnail"  />

                <span style="margin-top: 6px; margin-left: 20px; font-size: 12px; ">${t("determinantun")} ${model.name}</span>
            </div>
        `;
    }

    return `
        <div class="vehicle-model">
            <img src="${defaultImagePath}" 
                 alt="Bus par défaut" 
                 class="vehicle-thumbnail"  />
            <span style="margin-top: 6px; margin-left: 20px; font-size: 12px;">${t("abus")}</span>
        </div>
    `;
}

function getVehicleBrandHtmlLight(parkNumber) {
    const model = getVehicleModel(parkNumber);
    const defaultImagePath = "src/generic.png";
    
    if (model) {
        return `
            <img src="${model.thumbnail}" 
                onerror="this.style.display='none';" 
                alt="Thumbnail ${model.name}" 
                class="vehicle-thumbnaill"  />
        `;
    }

    return `

    `;
}


async function initializeApp() {
    try {
        
        for (const key in vehicleTypes) {
            vehicleTypes[key] = new Set();
        }
        
        await loadVehicleModels();
        
        await fetchVehiclePositions();
    } catch (error) {
        console.error('BECAB Launcher : erreur lors de l\'initialisation :', error);
        toastBottomRight.error('BECAB Launcher : erreur lors de l\'initialisation :', error);

    }
}

let isVibrating = false;
let vibrationTimeout = null;

/**
 * Fonction pour gérer les vibrations de manière sécurisée sans chevauchement
 * @param {Array|Number} pattern - Motif de vibration (un nombre pour une vibration simple, un tableau pour un motif)
 * @param {Boolean} force - Forcer la vibration même si une autre est en cours
 * @returns {Boolean} - Indique si la vibration à été déclenchée
 * Par Becab Systems
 */
function safeVibrate(pattern, force = false) {
    if (!navigator.vibrate) {
        return false;
    }
    
    if (isVibrating && !force) {
        return false;
    }
    
    if (isVibrating && force) {
        navigator.vibrate(0);
        
        if (vibrationTimeout) {
            clearTimeout(vibrationTimeout);
            vibrationTimeout = null;
        }
    }
    
    isVibrating = true;
    
    const vibrationPattern = Array.isArray(pattern) ? pattern : [pattern];
    
    const totalDuration = vibrationPattern.reduce((a, b) => a + b, 0) + 50;
    
    try {
        const success = navigator.vibrate(vibrationPattern);
        
        if (success === false) {
            isVibrating = false;
            return false;
        }
    } catch (error) {
        isVibrating = false;
        return false;
    }
    
    vibrationTimeout = setTimeout(() => {
        isVibrating = false;
        vibrationTimeout = null;
    }, totalDuration);
    
    return true;
}



let gtfsInitialized = false;

const langSwitcher = createLanguageSwitcher();

function createLanguageSwitcher(container) {
  // Config des langues disponibles (pour rajoutes langues, juste rajouter un objet dans le tableau
  // et rajouter la langue dans le fichier de traduction i18n.js)
  const languages = [
    { code: 'fr', name: 'Français 🥖🥐' },
    { code: 'en', name: 'English 🐟🍟' },
    { code: 'it', name: 'Italiano 🍕🍍' },
    { code: 'ar', name: 'عربي 🫖🍖' }
  ];
  
  const switcherContainer = document.createElement('div');
  switcherContainer.style.display = 'none';
  switcherContainer.className = 'language-switcher glass-effect';
  switcherContainer.style.position = 'absolute';
  switcherContainer.style.bottom = '0px';
  switcherContainer.style.left = '0px';
  switcherContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  switcherContainer.style.backdropFilter = 'blur(8px)';
  switcherContainer.style.WebkitBackdropFilter = 'blur(8px)';
  switcherContainer.style.borderRadius = '0 12px 0 0';
  switcherContainer.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.4)';
  switcherContainer.style.padding = '4px';
  switcherContainer.style.zIndex = '10000000000';
  switcherContainer.style.fontFamily = 'League Spartan, sans-serif';
  switcherContainer.style.transition = 'all 0.4s cubic-bezier(0.32, 0.64, 0.45, 1)';
  switcherContainer.style.transform = 'translateY(100px)';
  switcherContainer.style.opacity = '0';
  
  
  const mainButton = document.createElement('div');
  mainButton.className = 'lang-main-button';
  mainButton.style.display = 'flex';
  mainButton.style.alignItems = 'center';
  mainButton.style.justifyContent = 'space-between';
  mainButton.style.cursor = 'pointer';
  mainButton.style.color = '#ffffff';
  mainButton.style.padding = '8px 12px';
  mainButton.style.borderRadius = '8px';
  mainButton.style.transition = 'background-color 0.4s';
  
  const globeIcon = document.createElement('span');
  globeIcon.innerHTML = '🌐';
  globeIcon.style.marginRight = '10px';
  globeIcon.style.fontSize = '18px';
  
  const currentLangText = document.createElement('span');
  currentLangText.id = 'current-lang-text';
  currentLangText.textContent = languages.find(lang => lang.code === i18n.currentLang)?.name || 'Langue';
  
  const arrowIcon = document.createElement('span');
  arrowIcon.innerHTML = '▼';
  arrowIcon.style.fontSize = '12px';
  arrowIcon.style.marginLeft = '10px';
  arrowIcon.style.transition = 'transform 0.4s';
  
  mainButton.appendChild(globeIcon);
  mainButton.appendChild(currentLangText);
  mainButton.appendChild(arrowIcon);
  
  const dropdown = document.createElement('div');
  dropdown.className = 'lang-dropdown';
  dropdown.style.display = 'none';
  dropdown.style.flexDirection = 'column';
  dropdown.style.marginTop = '10px';
  dropdown.style.borderRadius = '8px';
  dropdown.style.overflow = 'hidden';
  dropdown.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
  dropdown.style.backgroundColor = 'rgba(36, 36, 36, 0.95)';
  dropdown.style.animation = 'none';
  
  languages.forEach(lang => {
    const langOption = document.createElement('div');
    langOption.className = 'lang-option';
    langOption.textContent = lang.name;
    langOption.dataset.lang = lang.code;
    langOption.style.padding = '10px 15px';
    langOption.style.cursor = 'pointer';
    langOption.style.transition = 'background-color 0.3s';
    langOption.style.color = '#ffffff';
    


    if (lang.code === i18n.currentLang) {
      langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
      langOption.style.fontWeight = 'bold';
    }
    
    langOption.onmouseover = () => {
      langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.3)';
    };
    
    langOption.onmouseout = () => {
      if (lang.code !== i18n.currentLang) {
        langOption.style.backgroundColor = 'transparent';
      } else {
        langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
      }
    };
    
    langOption.onclick = async (e) => {
      e.stopPropagation();
      const newLang = lang.code;
      
      if (newLang !== i18n.currentLang) {
        langSwitcher.updateCurrentLanguage(newLang);
        const transitionOverlay = document.createElement('div');
        transitionOverlay.style.position = 'fixed';
        transitionOverlay.style.top = '0';
        transitionOverlay.style.left = '0';
        transitionOverlay.style.width = '100%';
        transitionOverlay.style.height = '100%';
        transitionOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        transitionOverlay.style.zIndex = '9999';
        transitionOverlay.style.opacity = '0';
        transitionOverlay.style.transition = 'opacity 0.4s ease';
        document.body.appendChild(transitionOverlay);
        
        setTimeout(() => {
          transitionOverlay.style.opacity = '1';
          
          const urlParams = new URLSearchParams(window.location.search);
          urlParams.set('lang', newLang);
          
          localStorage.setItem('preferredLanguage', newLang);
          
          setTimeout(() => {
            window.location.search = urlParams.toString();
          }, 300);
        }, 50);
      }
      
      toggleDropdown(false);
    };
    
    dropdown.appendChild(langOption);
  });
  
  switcherContainer.appendChild(mainButton);
  switcherContainer.appendChild(dropdown);
  
  let isOpen = false;
  
  function toggleDropdown(forceState) {
    isOpen = forceState !== undefined ? forceState : !isOpen;
    
    if (isOpen) {
      dropdown.style.display = 'flex';
      dropdown.style.animation = 'zoomFadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1) forwards';
      arrowIcon.style.transform = 'rotate(180deg)';
      mainButton.style.backgroundColor = 'rgba(80, 80, 80, 0.3)';
    } else {
      dropdown.style.animation = 'none';
      dropdown.style.display = 'none';
      arrowIcon.style.transform = 'rotate(0deg)';
      mainButton.style.backgroundColor = 'transparent';
    }
  }
  
  mainButton.onclick = () => toggleDropdown();
  
  document.addEventListener('click', (e) => {
    if (!switcherContainer.contains(e.target) && isOpen) {
      toggleDropdown(false);
    }
  });
  
  
  if (container) {
    if (typeof container === 'string') {
      document.querySelector(container).appendChild(switcherContainer);
    } else {
      container.appendChild(switcherContainer);
    }
  } else {
    document.body.appendChild(switcherContainer);
  }
  
  return {
    element: switcherContainer,
    updateCurrentLanguage: (langCode) => {
      currentLangText.textContent = languages.find(lang => lang.code === langCode)?.name || 'Langue';
      
      document.querySelectorAll('.lang-option').forEach(option => {
        if (option.dataset.lang === langCode) {
          option.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
          option.style.fontWeight = 'bold';
        } else {
          option.style.backgroundColor = 'transparent';
          option.style.fontWeight = 'normal';
        }
      });
    }
  };
}



function hideLanguageSwitcher() {
  langSwitcher.element.style.transform = 'translateY(100px)';
  langSwitcher.element.style.opacity = '0';
  
  setTimeout(() => {
    langSwitcher.element.style.display = 'none';
  }, 300); 
}

function showLanguageSwitcher() {
  langSwitcher.element.style.display = 'block';
  
  setTimeout(() => {
    langSwitcher.element.style.transform = 'translateY(0)';
    langSwitcher.element.style.opacity = '1';
  }, 10);
}


function startWindowsSpinnerAnimation(elementId, interval = 30) {
  const frames = [
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','','','','','','','','',
    '','','','','','','','','',''
  ];

  const el = document.getElementById(elementId);
  if (!el) {
    return () => {};
  }

  let i = 0;
  const timer = setInterval(() => {
    el.textContent = frames[i];
    i = (i + 1) % frames.length;
  }, interval);
  return () => clearInterval(timer);
}

let isStandardView = localStorage.getItem('isStandardView') === 'true';

function toggleMapView(forceState) {
    if (forceState !== undefined) {
        isStandardView = forceState;
    } else {
        isStandardView = !isStandardView;
    }
    
    localStorage.setItem('isStandardView', isStandardView);

    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const mapp = document.getElementById('map');
    mapp.style.opacity = '1';
    const map = document.getElementById('map');
    menu.classList.add('hidden');
    if (localStorage.getItem('transparency') === 'true') {
        const map = document.getElementById('map');
        map.classList.remove('hiddennotransition');
        map.classList.add('appearnotransition');
        map.classList.remove('hidden');
        map.classList.remove('appear');
    } else {
        const map = document.getElementById('map');
        map.classList.remove('hidden');
        map.classList.add('appear');
        map.classList.remove('hiddennotransition');
        map.classList.remove('appearnotransition');
    }
    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false;
    menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
        if (selectedLine) {
            const filtre = document.getElementById('filtre');
            filtre.classList.remove('slide-upc');
            filtre.classList.add('slide-downc');
            filtre.style.display = 'flex';
        }
    }, 10);

    applyMapView();
}

function applyMapView() {
    const currentDate = new Date();
    const latitude = map.getCenter().lat;  
    const longitude = map.getCenter().lng;  


    map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer) {
            map.removeLayer(layer);
        }
    });

    if (!isStandardView) {
    const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(map);
    

} else {
    const mapPane = map.getPanes().tilePane;
    mapPane.style.filter = 'none';

    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(map);

}
}

function shareVehicleId(id) {
  const message = t("shareMessage").replace("{{vehicleId}}", id);
  const url = window.location.href; 
  const fullMessage = `${message} ${url}`;

  if (navigator.share) {
    navigator.share({
      title: 'My Bus Finder',
      text: fullMessage,
    }).catch(err => console.error("Sharing failed :(", err));
  } 
}


async function fetchVehiclePositions() {

    if (!gtfsInitialized) {
        console.log("fetchVehiclePositions: GTFS pas encore initialisé, attente...");
        return; 
    }


        if (!window.timeAnimationStyleAdded) {
        const timeAnimationStyle = `
        <style id="time-animation-styles">
            .time-display {
                transition: opacity 0.3s ease-out;
            }
            
            .time-display.fade-out {
                opacity: 0;
            }
            
            @keyframes radiateWaves {
                0% { transform: scale(0.7); opacity: 0.5; }
                50% { transform: scale(1.2); opacity: 1; }
                100% { transform: scale(1); opacity: 0.7; }
            }
            
            .time-indicator .rss-waves {
                transform-origin: 5px 19px; 
            }
            
            .time-indicator.animate .rss-waves {
                animation: radiateWaves 0.6s ease-out;
            }
            
            @keyframes scrollText {
                0% { transform: translateX(0); }
                10% { transform: translateX(0); }
                60% { transform: translateX(calc(-100% + 70px)); }
                90% { transform: translateX(calc(-100% + 70px)); }
                100% { transform: translateX(0); }
            }
            
            .stop-name-container:hover .stop-name-wrapper[style*="animation"] {
                animation-play-state: running !important;
            }
        </style>
        `;
        document.head.insertAdjacentHTML('beforeend', timeAnimationStyle);
        window.timeAnimationStyleAdded = true;
    }
    try {
        const response = await fetch('proxy-cors/proxy_vehpos.php');
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);

        const activeVehicleIds = new Set();

                const tempElement = document.createElement('div');
        tempElement.style.font = getComputedStyle(document.body).font;
        tempElement.style.visibility = 'hidden';
        tempElement.style.position = 'absolute';
        tempElement.style.whiteSpace = 'nowrap';
        document.body.appendChild(tempElement);
        


            data.entity.forEach(entity => {
                const vehicle = entity.vehicle;
                if (vehicle) {


                const id = vehicle.vehicle.label || vehicle.vehicle.id;
                const vehicleOptionsBadges = getVehicleOptionsBadges(id);
                const vehicleBrandHtml = getVehicleBrandHtml(id);
                const line = vehicle.trip && vehicle.trip.routeId ? vehicle.trip.routeId : 'Inconnu';
                const directionId = vehicle.trip ? vehicle.trip.directionId : undefined;
                activeVehicleIds.add(id);

                const statusMap = {
                    0: '❌ Hors service commercial',
                    1: ' En service - Portes ouvertes',
                    2: ' En service'
                };
                const status = statusMap[vehicle.currentStatus] || 'Inconnu';

                const stopIdun = vehicle.stopId || 'Inconnu';
                let stopId = stopIdun.replace("0:", "");
                const latitude = vehicle.position.latitude;
                const longitude = vehicle.position.longitude;

                if (isNaN(latitude) || isNaN(longitude)) {
                    return; 
                }

                const speed = vehicle.position.speed ? (vehicle.position.speed).toFixed(0) + ' km/h' : 'Arrêté';
                const bearing = vehicle.position.bearing || 'Inconnu';
                const tripId = vehicle.trip && vehicle.trip.tripId ? vehicle.trip.tripId : 'Inconnu';

                const lastStopId = tripUpdates[tripId] ? tripUpdates[tripId].lastStopId : 'Inconnu';
                const lastStopNameun = stopNameMap[lastStopId] || 'Destination inconnue';
                let lastStopName = lastStopNameun.replace("0:", "");
                
                const nextStops = tripUpdates[tripId]?.nextStops || [];
                let currentStopIndex = nextStops.findIndex(stop => stop.stopId.replace("0:", "") === stopId.replace("0:", ""));
                const now = Math.floor(Date.now() / 1000);

                let filteredStops = [];
                if (currentStopIndex !== -1) {
                    filteredStops = nextStops.slice(currentStopIndex).filter(stop => {
                        return stop.delay === null || stop.delay >= -60;
                    });
                } else {
                    filteredStops = nextStops.filter(stop => stop.delay === null || stop.delay > 0);
                }

                const stopSpinner = startWindowsSpinnerAnimation("win-spinner");
                setTimeout(() => {
                    stopSpinner();
                }, 8000);

                if (filteredStops.length === 0) {
                    stopsHeaderText = `<span id="win-spinner" style="font-family: 'SegoeUIBoot'; font-size: 0.8rem; margin-right: 5px;"></span>  Chargement en cours.`
                } else {
                    const firstStopDelay = filteredStops[0].delay || 0;
                    const minutes = Math.max(0, Math.ceil(firstStopDelay / 60));

                    if (filteredStops.length === 1) {
                        stopsHeaderText = minutes === 0
                            ? t("imminentdeparture")
                            : `${t("departurein")} ${minutes} ${t("min")}`;
                    } else if (minutes > 3) {
                        stopsHeaderText = `${t("departurein")} ${minutes} ${t("minutes")}`;
                    } else {
                        stopsHeaderText = t("nextstops");
                    }
                }
                
                let stopsListHTML = '';
                if (filteredStops.length > 0) {
                    stopsListHTML = filteredStops.map(stop => {
                        const timeLeft = stop.delay;
                        const timeLeftText = timeLeft !== null 
                            ? timeLeft <= 0 ? t("imminent") : `${Math.ceil(timeLeft / 60)} min`
                            : '';
                        
                        const stopName = stopNameMap[stop.stopId] || stop.stopId;
                        
                        tempElement.textContent = stopName;
                        
                        return `
                        <li style="list-style: none; padding: 0px; display: flex; justify-content: space-between;">
                            <div class="stop-name-container" style="position: relative; overflow: hidden; max-width: 70%; white-space: nowrap;">
                                <div class="stop-name-wrapper" style="position: relative; display: inline-block; padding-right: 10px;">
                                    <div class="stop-name" style="position: relative; display: inline-block;">${stopName}</div>
                                </div>
                            </div>
                            <div class="time-container" style="position: relative; min-height: 1.2em; text-align: right;">
                                <div class="time-display" 
                                    data-time-left="${timeLeftText}" 
                                    data-departure-time="${stop.arrivalTime || stop.departureTime || "Inconnu"}">
                                    ${timeLeftText}
                                </div>
                                <svg class="time-indicator" xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <g class="rss-waves">
                                        <path class="rss-arc-large" d="M4 4a16 16 0 0 1 16 16"></path>
                                        <path class="rss-arc-small" d="M4 11a9 9 0 0 1 9 9"></path>
                                    </g>
                                    <circle class="rss-dot" cx="5" cy="19" r="1"></circle>
                                </svg>
                            </div>
                        </li>`;
                    }).join('');
                }

                const nextStopsHTML = `
                    <div style="position: relative; max-height: 120px;">
                        <ul style="padding: 0; margin: 0; list-style-type: none; max-height: 120px;">
                            ${stopsListHTML}
                        </ul>
                    </div>
                `;

                if (!window.toggleTimeDisplay) {
                    window.isAnimating = false;
                    window.showTimeLeft = true;
                    
                    window.toggleTimeDisplay = function() {
                        if (window.isAnimating) return;
                        
                        window.isAnimating = true;
                        
                        const timeDisplays = document.querySelectorAll('.time-display');
                        const indicators = document.querySelectorAll('.time-indicator');
                        
                        timeDisplays.forEach(display => {
                            display.classList.add('fade-out');
                        });
                        
                        indicators.forEach(indicator => {
                            indicator.classList.add('animate');
                            
                            setTimeout(() => {
                                indicator.classList.remove('animate');
                            }, 600);
                        });
                        
                        setTimeout(() => {
                            window.showTimeLeft = !window.showTimeLeft;
                            
                            timeDisplays.forEach(display => {
                                const timeLeft = display.getAttribute('data-time-left');
                                const departureTime = display.getAttribute('data-departure-time');
                                display.textContent = window.showTimeLeft ? timeLeft : departureTime;
                            });
                            
                            timeDisplays.forEach(display => {
                                display.classList.remove('fade-out');
                            });
                            
                            setTimeout(() => {
                                window.isAnimating = false;
                            }, 350);
                        }, 350);
                    };

                    if (window.timeToggleInterval) {
                        clearInterval(window.timeToggleInterval);
                    }
                    window.timeToggleInterval = setInterval(window.toggleTimeDisplay, 4000);
                }

                const delayInfo = tripUpdates[tripId] ? tripUpdates[tripId].stopUpdates.find(update => update.stopId === stopId) : null;

                const arrivalDelay = delayInfo ? delayInfo.arrivalDelay : 0; 
                const scheduledArrival = delayInfo ? delayInfo.scheduledArrival : null; 

                                
                function getTextColorForBackground(bgColor, options = {}) {
                    const {
                        contrastRatio = 4.5,        
                        darkColor = '#1a1a1a',      
                        lightColor = '#f8f9fa',     
                        debug = false
                    } = options;

                    let r, g, b, a = 1;

                    if (!bgColor) return darkColor;

                    bgColor = bgColor.trim();

                    if (bgColor.startsWith('rgb')) {
                        const values = bgColor.match(/\d+(\.\d+)?/g);
                        if (values) {
                            r = parseInt(values[0]);
                            g = parseInt(values[1]);
                            b = parseInt(values[2]);
                            a = values[3] ? parseFloat(values[3]) : 1;
                        } else {
                            return darkColor;
                        }
                    } else {
                        if (/^#([a-f\d])([a-f\d])([a-f\d])$/i.test(bgColor)) {
                            bgColor = bgColor.replace(/^#([a-f\d])([a-f\d])([a-f\d])$/i,
                                (_, r, g, b) => '#' + r + r + g + g + b + b);
                        }

                        if (bgColor.length === 7) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                        } else if (bgColor.length === 9) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else if (bgColor.length === 8 && bgColor.startsWith('#')) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else {
                            return darkColor;
                        }
                    }

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));



                    const srgb = [r, g, b].map(c => {
                        const val = c / 255;
                        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                    });
                    const luminance = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];


                    const result = luminance < 0.40 ? lightColor : darkColor;
                    


                    return result;
                }


                
                    
                    

                const backgroundColor = lineColors[line] || '#000000';
                const textColor = getTextColorForBackground(backgroundColor);


                let arrivalTime = 'Inconnu';
                if (scheduledArrival) {
                    const arrivalDate = new Date(scheduledArrival * 1000);
                    arrivalTime = arrivalDate.toLocaleTimeString();
                }

                let delayMessage = 'À l\'heure';
                if (arrivalDelay > 0) {
                    delayMessage = `En retard de ${arrivalDelay} secondes`;
                } else if (arrivalDelay < 0) {
                    delayMessage = `En avance de ${Math.abs(arrivalDelay)} secondes`;
                }

                let remainingTimeMessage = t("endstop");
                if (nextStops.length > 1) {
                    const penultimateStop = nextStops[nextStops.length - 2]; // avant der arrêt
                    const scheduledArrivalPenultimate = penultimateStop.departureTime;

                    if (scheduledArrivalPenultimate && scheduledArrivalPenultimate.includes(":")) {
                        const [hours, minutes] = scheduledArrivalPenultimate.split(':').map(num => parseInt(num, 10));

                        const now = new Date();
                        const scheduledArrivalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);

                        const currentTime = new Date();
                        const timeRemaining = Math.max(scheduledArrivalDate - currentTime, 0);
                        const minutesRemaining = Math.floor(timeRemaining / 60000);
                        const secondsRemaining = Math.floor((timeRemaining % 60000) / 1000);

                        remainingTimeMessage = ` ${minutesRemaining} ${t("minutes")}.`;
                    } else {
                        remainingTimeMessage = ' ' + t("unknownarrival");
                    }
                }


                


                window.openFullPopup = function(markerId) {
                    if (markers[markerId]) {
                        markers[markerId].fire('click');
                    }
                };

                if (typeof window.minimalTooltipStates === 'undefined') {
                    window.minimalTooltipStates = {};
                }

                if (!document.getElementById('minimal-tooltip-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'minimal-tooltip-styles';
                    styles.textContent = `
                        .minimal-tooltip-container {
                            background: transparent !important;
                            border: none !important;
                            box-shadow: none !important;
                            padding: 0 !important;
                            margin: 0 !important;
                        }
                        
                        .minimal-tooltip-container::before {
                            display: none !important;
                        }
                        
                        .leaflet-tooltip-top::before,
                        .leaflet-tooltip-bottom::before,
                        .leaflet-tooltip-left::before,
                        .leaflet-tooltip-right::before,
                        .leaflet-tooltip-center::before {
                            display: none !important;
                        }
                        
                        .leaflet-tooltip {
                            background: transparent !important;
                            border: none !important;
                            box-shadow: none !important;
                        }
                        
                        @keyframes popIn {
                            0% {
                                opacity: 0;
                                transform: scale(0.3) translateY(10px);
                            }
                            50% {
                                transform: scale(1.1) translateY(-2px);
                            }
                            100% {
                                opacity: 1;
                                transform: scale(1) translateY(0);
                            }
                        }
                        
                        @keyframes popOut {
                            0% {
                                opacity: 1;
                                transform: scale(1) translateY(0);
                            }
                            100% {
                                opacity: 0;
                                transform: scale(0.3) translateY(10px);
                            }
                        }
                        
                        .minimal-popup-appear {
                            animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        }
                        
                        .minimal-popup-disappear {
                            animation: popOut 0.2s cubic-bezier(0.4, 0, 1, 1);
                        }
                    `;
                    document.head.appendChild(styles);
                }

                const contentCache = new Map();
                const colorCache = new Map();

                // Pool d'objets réutilisables pour les tooltips
                const tooltipPool = [];
                let maxPoolSize = 50;

                function getFromPool() {
                    return tooltipPool.pop() || null;
                }

                function returnToPool(tooltip) {
                    if (tooltipPool.length < maxPoolSize) {
                        tooltipPool.push(tooltip);
                    }
                }

                function generatePopupContent(vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id) {
                    // Inclure nextStopsHTML dans la clé de cache pour détecter les changements
                    const nextStopsHash = nextStopsHTML ? nextStopsHTML.substring(0, 100) : '';
                    const cacheKey = `${id}-${vehicle.vehicle.label}-${line}-${lastStopName}-${stopsHeaderText}-${nextStopsHash}`;
                    
                    if (contentCache.has(cacheKey)) {
                        return contentCache.get(cacheKey);
                    }
                    
                                const popupContent = `
                                    <div style="position: relative; font-family: 'League Spartan', sans-serif; font-size: 14px; color: #333; border-radius: 15px; box-shadow: 0px 0px 20px 4px ${backgroundColor}9c; overflow: hidden; background-color: ${backgroundColor}9c; color: ${textColor}; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">
                                    
                                <button onclick="shareVehicleId('${vehicle.vehicle.id}')" title="${t("share")}" style="
                                    position: absolute;
                                    top: 10px;
                                    right: 10px;
                                    background: none;
                                    border: none;
                                    padding: 4px;
                                    cursor: pointer;
                                    z-index: 3;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                ">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 3C10.3431 3 9 4.34315 9 6C9 7.65685 10.3431 9 12 9C13.6569 9 15 7.65685 15 6" />
                                    <path d="M5.5 15C3.84315 15 2.5 16.3431 2.5 18C2.5 19.6569 3.84315 21 5.5 21C7.15685 21 8.5 19.6569 8.5 18" />
                                    <path d="M18.5 21C16.8431 21 15.5 19.6569 15.5 18C15.5 16.3431 16.8431 15 18.5 15C20.1569 15 21.5 16.3431 21.5 18" />
                                    <path d="M20 13C20 10.6106 18.9525 8.46589 17.2916 7M4 13C4 10.6106 5.04752 8.46589 6.70838 7M10 20.748C10.6392 20.9125 11.3094 21 12 21C12.6906 21 13.3608 20.9125 14 20.748" />
                                </svg>

                                </button>


                                <div style="position: relative; padding: 10px; color: ${textColor}; text-align: center; overflow: hidden; display: flex; justify-content: space-between; align-items: center; box-shadow: 0px 4px 20px 5px rgba(0, 0, 0, 0.3); border-radius: 11px; margin: 7px; ">
                                <div class="light-beam beam1"></div>
                                <div class="light-beam beam2"></div>
                                <div class="light-beam beam3"></div>

                                    <!-- Texte principal -->
                                    <div style="z-index: 2; text-align: left; width: 100%;">
                                        <p style="margin: 0; font-size: 24px; ">${t("line")} ${lineName[line] || t("unknownline")}</p>
                                        <strong style="margin: 0; font-size: 14px;">➜ ${lastStopName}</strong>
                                <div>
                                    <div style="position: relative; display: flex; align-items: center; ">
                                        <div style="
                                            position: relative;
                                            flex: 1;
                                            overflow: hidden;
                                            border-radius: 10px;
                                        ">
                                            <!-- Contenu défilant horizontalement -->
                                            <div class="options" style="
                                                display: flex;
                                                gap: 10px;
                                                padding: 0px;
                                                overflow-x: auto; 
                                                white-space: nowrap;
                                                scrollbar-width: thin; 
                                                scrollbar-color: #888 #f1f1f1;
                                                color: #ffffff;
                                            " class="custom-scrollbar">
                                                <!-- Numéro de parc -->
                                                <span style="
                                                    padding: 6px 10px; 
                                                    background: #00000077; 
                                                    font-weight: normal; 
                                                    white-space: nowrap; 
                                                    backdrop-filter: blur(8px);
                                                    -webkit-backdrop-filter: blur(8px);
                                                    border-radius: 10px; 
                                                    display: inline-flex; 
                                                    align-items: center; 
                                                    gap: 6px;
                                                    height: 20px;
                                                ">

                                                <svg style="display: inline-block;vertical-align: top; position: relative;" width="17" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M10 2.00879C7.52043 2.04466 6.11466 2.22859 5.17157 3.17167C4 4.34324 4 6.22886 4 10.0001V12.0001C4 15.7713 4 17.657 5.17157 18.8285C6.34315 20.0001 8.22876 20.0001 12 20.0001C15.7712 20.0001 17.6569 20.0001 18.8284 18.8285C20 17.657 20 15.7713 20 12.0001V10.0001C20 6.22886 20 4.34324 18.8284 3.17167C17.8853 2.22859 16.4796 2.04466 14 2.00879" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M20 13H16M4 13H12" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M15.5 16H17" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M7 16H8.5" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M6 19.5V21C6 21.5523 6.44772 22 7 22H8.5C9.05228 22 9.5 21.5523 9.5 21V20" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M18 19.5V21C18 21.5523 17.5523 22 17 22H15.5C14.9477 22 14.5 21.5523 14.5 21V20" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M20 9H21C21.5523 9 22 9.44772 22 10V11C22 11.3148 21.8518 11.6111 21.6 11.8L20 13" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M4 9H3C2.44772 9 2 9.44772 2 10V11C2 11.3148 2.14819 11.6111 2.4 11.8L4 13" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M4.5 5H8.25M19.5 5H12" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>
                                                <span style="display: inline-block; line-height: 20px; vertical-align: middle; position: relative; top: 1px;">${(vehicle.vehicle.label || t("unknownparc")).toString().padStart(3, '0')}</span>

                                                    
                                                </span>
                                                
                                                <!-- Badges des options du véhicule -->
                                                ${vehicleOptionsBadges}
                                            </div>
                                        </div>
                                    </div>
                                        <div style=" margin-top: 10px; text-align: right;">
                                            ${vehicleBrandHtml}
                                        </div>
                                    </div>
                                </div>


                                    <!-- Texte en arrière-plan -->
                                    <div style="
                                        position: absolute;
                                        right: 10px;
                                        top: 0;
                                        z-index: 1;
                                        opacity: 0.1;
                                        font-size: 100px;
                                        color: ${textColor};
                                        display: flex;
                                        align-items: center;
                                        justify-content: flex-end;
                                        white-space: nowrap;
                                    ">
                                        ${t("line")} ${lineName[line] || "🚌🚍🚌🚍🚌🚍🚌"}
                                    </div>
                                </div>





                                <div style="padding-top: 10px; padding-left: 10px; padding-right: 10px; color: ${textColor};">
                                <p style="margin: 0; font-size: 18px; text-align: right;">${stopsHeaderText}</p>
                                    <ul>
                                    <div id="nextStopsContent" class="next-stops-content">
                                        ${nextStopsHTML}
                                    </div>   
                                </div>
                                </div>
                                `;

                                const minimalPopupContent = `
                                    <div class="minimal-popup" style="
                                        position: relative;
                                        font-family: 'League Spartan', sans-serif;
                                        font-size: 12px;
                                        color: ${textColor};
                                        background-color: ${backgroundColor}9c;
                                        backdrop-filter: blur(8px);
                                        -webkit-backdrop-filter: blur(8px);
                                        border-radius: 8px;
                                        padding: 8px 12px;
                                        box-shadow: 0px 2px 10px 2px ${backgroundColor}6c;
                                        min-width: 120px;
                                        cursor: pointer;
                                        border: 1px solid ${backgroundColor}cc;
                                    " onclick="openFullPopup('${id}')">
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <div style="font-weight: bold; font-size: 14px;">
                                                ${t("line")} ${lineName[line] || t("unknownline")}
                                            </div>
                                            <div style="font-size: 11px; opacity: 0.9;">
                                                🚌 ${(vehicle.vehicle.label || t("unknownparc")).toString().padStart(3, '0')}
                                            </div>
                                            <div style="font-size: 11px; opacity: 0.8;">
                                                ➜ ${lastStopName}
                                            </div>
                                        </div>
                                    </div>
                                `;
                    
                    // Limiter la taille du cache
                    if (contentCache.size > 100) {
                        const firstKey = contentCache.keys().next().value;
                        contentCache.delete(firstKey);
                    }
                    
                    contentCache.set(cacheKey, popupContent);
                    return popupContent;
                }

                function animateTooltip(tooltip, newLatLng, duration = 500) {
                    if (!tooltip || !tooltip._container) return;
                    
                    const container = tooltip._container;
                    const startPos = map.latLngToContainerPoint(tooltip.getLatLng());
                    const endPos = map.latLngToContainerPoint(newLatLng);
                    
                    const startTime = performance.now();
                    
                    function animate(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        
                        const currentX = startPos.x + (endPos.x - startPos.x) * easeProgress;
                        const currentY = startPos.y + (endPos.y - startPos.y) * easeProgress;
                        
                        const currentLatLng = map.containerPointToLatLng([currentX, currentY]);
                        tooltip.setLatLng(currentLatLng);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        }
                    }
                    
                    requestAnimationFrame(animate);
                }

                function createOrUpdateMinimalTooltip(markerId, shouldShow = true) {
                    const marker = markers[markerId];
                    if (!marker) return;
                    
                    if (shouldShow && !marker.isPopupOpen()) {
                        if (!marker.minimalPopup) {
                            // Essayer de réutiliser un tooltip existant du pool
                            let minimalTooltip = getFromPool();
                            
                            if (!minimalTooltip) {
                                minimalTooltip = L.tooltip({
                                    permanent: true,
                                    direction: 'center',
                                    className: 'minimal-tooltip-container',
                                    offset: [0, 0],
                                    opacity: 1
                                });
                            }
                            
                            const color = lineColors[marker.line] || '#000000';
                            const textColor = getOptimalTextColor(color);
                            
                            const minimalContent = `
                                <div class="minimal-popup minimal-popup-appear" style="
                                    position: relative;
                                    font-family: 'League Spartan', sans-serif;
                                    font-size: 11px;
                                    color: ${textColor};
                                    background: linear-gradient(135deg, ${color}f0, ${color}d0);
                                    backdrop-filter: blur(12px);
                                    -webkit-backdrop-filter: blur(12px);
                                    border-radius: 12px;
                                    padding: 6px 10px;
                                    box-shadow: 0 4px 16px -2px ${color}80, 0 2px 8px -2px ${color}40;
                                    min-width: 80px;
                                    max-width: 140px;
                                    cursor: pointer;
                                    border: 1px solid ${color}60;
                                    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                                    transform: translateY(0);
                                " onclick="event.stopPropagation(); markers['${markerId}'].fire('click');" 
                                onmouseover="this.style.transform='translateY(-2px) scale(1.02)'; this.style.boxShadow='0 6px 20px -2px ${color}90, 0 4px 12px -2px ${color}50';"
                                onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 16px -2px ${color}80, 0 2px 8px -2px ${color}40';">
                                    <div style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
                                        <div style="
                                            background: rgba(255,255,255,0.2);
                                            border-radius: 6px;
                                            padding: 2px 6px;
                                            font-weight: 600;
                                            font-size: 10px;
                                            line-height: 1.2;
                                        ">
                                            ${lineName[marker.line] || t("unknownline")}
                                        </div>
                                        <div style="
                                            background: rgba(0,0,0,0.3);
                                            border-radius: 4px;
                                            padding: 1px 4px;
                                            font-size: 9px;
                                            font-weight: 500;
                                        ">
                                            ${((marker.vehicleData && marker.vehicleData.vehicle.label) || t("unknownparc")).toString().padStart(3, '0')}
                                        </div>
                                    </div>
                                    <div style="
                                        font-size: 9px; 
                                        opacity: 0.85; 
                                        margin-top: 2px;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        white-space: nowrap;
                                        font-weight: 400;
                                    ">
                                        ➜ ${marker.destination || t("unknowndestination")}
                                    </div>
                                </div>
                            `;
                            
                            minimalTooltip
                                .setLatLng(marker.getLatLng())
                                .setContent(minimalContent)
                                .addTo(map);
                            
                            marker.minimalPopup = minimalTooltip;
                            window.minimalTooltipStates[markerId] = 'visible';
                        } else {
                            // Seulement animer si la position a changé
                            const currentLatLng = marker.minimalPopup.getLatLng();
                            const newLatLng = marker.getLatLng();
                            
                            if (Math.abs(currentLatLng.lat - newLatLng.lat) > 0.0001 || Math.abs(currentLatLng.lng - newLatLng.lng) > 0.0001) {
                                animateTooltip(marker.minimalPopup, newLatLng);
                            }
                        }
                    } else if (!shouldShow && marker.minimalPopup) {
                        const tooltipContainer = marker.minimalPopup._container;
                        if (tooltipContainer) {
                            const popupElement = tooltipContainer.querySelector('.minimal-popup');
                            if (popupElement) {
                                popupElement.classList.remove('minimal-popup-appear');
                                popupElement.classList.add('minimal-popup-disappear');
                                
                                setTimeout(() => {
                                    const tooltipToRemove = marker.minimalPopup;
                                    marker.minimalPopup = null;
                                    delete window.minimalTooltipStates[markerId];
                                    
                                    if (tooltipToRemove) {
                                        map.removeLayer(tooltipToRemove);
                                        returnToPool(tooltipToRemove);
                                    }
                                }, 200);
                            }
                        } else {
                            // Fallback si pas de container
                            const tooltipToRemove = marker.minimalPopup;
                            marker.minimalPopup = null;
                            delete window.minimalTooltipStates[markerId];
                            
                            map.removeLayer(tooltipToRemove);
                            returnToPool(tooltipToRemove);
                        }
                    }
                }
                function updatePopupContent(marker, vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id) {
                    const popup = marker.getPopup();
                    if (!popup) return false;
                    
                    const newContent = generatePopupContent(vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id);
                    
                    // Seulement mettre à jour si le contenu a changé
                    if (popup.getContent() !== newContent) {
                        popup.setContent(newContent);
                        return true;
                    }
                    return false;
                }

                function updateMinimalPopups() {
                    const currentZoom = map.getZoom();
                    const showMinimal = currentZoom >= 17 && currentZoom < 20; 
                    
                    Object.keys(markers).forEach(markerId => {
                        const marker = markers[markerId];
                        if (!marker) return;
                        
                        const shouldShow = showMinimal && !marker.isPopupOpen();
                        createOrUpdateMinimalTooltip(markerId, shouldShow);
                    });
                }

                function getOptimalTextColor(bgColor, options = {}) {
                    const {
                        contrastRatio = 4.5,
                        darkColor = '#1a1a1a',
                        lightColor = '#f8f9fa',
                        useGradient = false 
                    } = options;

                    let r, g, b, a = 1;

                    if (!bgColor) return darkColor;

                    bgColor = bgColor.trim();

                    if (bgColor.startsWith('rgb')) {
                        const values = bgColor.match(/\d+(\.\d+)?/g);
                        if (values) {
                            r = parseInt(values[0]);
                            g = parseInt(values[1]);
                            b = parseInt(values[2]);
                            a = values[3] ? parseFloat(values[3]) : 1;
                        } else {
                            return darkColor;
                        }
                    } else {
                        if (/^#([a-f\d])([a-f\d])([a-f\d])$/i.test(bgColor)) {
                            bgColor = bgColor.replace(/^#([a-f\d])([a-f\d])([a-f\d])$/i,
                                (_, r, g, b) => '#' + r + r + g + g + b + b);
                        }

                        if (bgColor.length === 7) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                        } else if (bgColor.length === 9) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else if (bgColor.length === 8 && bgColor.startsWith('#')) {
                            r = parseInt(bgColor.slice(1, 3), 16);
                            g = parseInt(bgColor.slice(3, 5), 16);
                            b = parseInt(bgColor.slice(5, 7), 16);
                            a = parseInt(bgColor.slice(7, 9), 16) / 255;
                        } else {
                            return darkColor;
                        }
                    }

                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));

                    const srgb = [r, g, b].map(c => {
                        const val = c / 255;
                        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
                    });
                    const luminance = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];

                    const getLuminance = (color) => {
                        const hex = color.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16) / 255;
                        const g = parseInt(hex.substr(2, 2), 16) / 255;
                        const b = parseInt(hex.substr(4, 2), 16) / 255;
                        const srgb = [r, g, b].map(c => 
                            c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                        );
                        return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
                    };

                    const darkLuminance = getLuminance(darkColor);
                    const lightLuminance = getLuminance(lightColor);

                    const contrastWithDark = luminance > darkLuminance 
                        ? (luminance + 0.05) / (darkLuminance + 0.05)
                        : (darkLuminance + 0.05) / (luminance + 0.05);
                    
                    const contrastWithLight = luminance > lightLuminance 
                        ? (luminance + 0.05) / (lightLuminance + 0.05)
                        : (lightLuminance + 0.05) / (luminance + 0.05);

                    if (contrastWithDark >= contrastRatio && contrastWithLight >= contrastRatio) {
                        return luminance > 0.18 ? darkColor : lightColor;
                    } else if (contrastWithDark >= contrastRatio) {
                        return darkColor;
                    } else if (contrastWithLight >= contrastRatio) {
                        return lightColor;
                    } else {

                        if (luminance < 0.18) {
                            return lightColor; 
                        }
                        return contrastWithDark > contrastWithLight ? darkColor : lightColor;
                    }
                }

            if (markers[id]) {
            
            if (!markers[id].id) {
                markers[id].id = id;
            }
            
            const hasChanges = (
            markers[id].line !== line ||
            markers[id].destination !== lastStopName ||
            !markers[id].vehicleData ||
            markers[id].vehicleData.vehicle.label !== vehicle.vehicle.label ||
            markers[id]._lastNextStopsHTML !== nextStopsHTML
        
        );
            
            if (hasChanges) {
                markers[id].vehicleData = vehicle;
                markers[id].destination = lastStopName;
                
                if (markers[id].line !== line) {
                    const oldLine = markers[id].line;
                    markers[id].line = line;
                    markers[id]._lastNextStopsHTML = nextStopsHTML;
                    
                    const color = lineColors[line] || '#000000';
                    if (markers[id]._icon) {
                        const markerIcon = markers[id]._icon.querySelector('.marker-icon');
                        if (markerIcon) {
                            markerIcon.style.transition = 'background-color 0.5s ease';
                            markerIcon.style.backgroundColor = color;
                        }
                        
                        const arrowElement = markers[id]._icon.querySelector('.marker-arrow-path');
                        if (arrowElement) {
                            arrowElement.style.transition = 'stroke 0.5s ease';
                            arrowElement.setAttribute('stroke', color);
                        }
                    }
                    
                    if (markers[id].isPopupOpen()) {
                        const menubtm = document.getElementById('menubtm');
                        const filtre = document.getElementById('filtre');
                        if (menubtm) {
                            lastActiveColor = color;
                            
                            menubtm.style.backgroundColor = `${color}9c`;
                            filtre.style.backgroundColor = `${color}9c`;

                            const textColor = getOptimalTextColor(color);
                            
                            const styleId = `popup-style-${Math.random().toString(36).substr(2, 9)}`;
                            const styleSheet = document.createElement('style');
                            styleSheet.id = styleId;
                            styleSheet.classList.add('menu-color-style');
                            
                            styleSheet.textContent = `
                                #menubtm * {
                                    color: ${textColor};
                                    transition: color 0.5s ease;
                                }

                                #filtre * {
                                    color: ${textColor};
                                    transition: color 0.5s ease;
                                }
                            `;
                            
                            document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                            document.head.appendChild(styleSheet);
                            markers[id].styleId = styleId;
                        }
                    }
                }
                
                updateLinesDisplay();

                const popupContent = generatePopupContent(vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id);
                updatePopupContent(markers[id], vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id);
                if (markers[id].isPopupOpen() && contentUpdated) {
                    const popup = markers[id]._popup;
                    if (popup && popup._contentNode) {
                        const popupElement = popup._contentNode.parentElement;
                        if (popupElement) {
                            popupElement.classList.remove('hide'); 
                            popupElement.classList.add('show'); 
                            markers[id].openPopup();
                        }
                    }
                }
            }
            
            if (markers[id]._icon) {
                const arrowElement = markers[id]._icon.querySelector('.marker-arrow');
                
                if (arrowElement) {
                    const targetRotation = bearing - 90;
                    arrowElement.style.transition = 'transform 0.5s ease';
                    arrowElement.style.transform = `rotate(${targetRotation}deg)`;
                    arrowElement._currentRotation = targetRotation;
                }
            }

            if (selectedLine && markers[id].line !== selectedLine) {
                if (map.hasLayer(markers[id])) {
                    map.removeLayer(markers[id]);
                }
            } else {
                if (!map.hasLayer(markers[id])) {
                    map.addLayer(markers[id]);
                }
            }
            animateMarker(markers[id], [latitude, longitude]);
            setTimeout(() => {
                updateMinimalPopups();
            }, 1000);
            } else {
                    const marker = createColoredMarker(latitude, longitude, line, bearing);
                    updateLinesDisplay();
                    markers[id] = marker;
                    markers[id].line = line;
                    markers[id].id = id;
                    markers[id].vehicleData = vehicle;
                    markers[id].destination = lastStopName;

                    if (!selectedLine || selectedLine === line) {
                        marker.addTo(map);
                    }
                    
                    const popupContent = generatePopupContent(vehicle, line, lastStopName, nextStopsHTML, vehicleOptionsBadges, vehicleBrandHtml, stopsHeaderText, backgroundColor, textColor, id);
                    marker.bindPopup(popupContent);
                    markers[id]._lastNextStopsHTML = nextStopsHTML;

                    marker.on('popupopen', function (e) {
                        if (markers[id].minimalPopup) {
                            createOrUpdateMinimalTooltip(id, false);
                        }
                        
                        if (e.popup && e.popup._contentNode) {
                            const popupElement = e.popup._contentNode.parentElement;
                            if (popupElement) {
                                popupElement.classList.remove('hide'); 
                                popupElement.classList.add('show');  
                            }
                        }
                    });

                    marker.on('popupclose', function (e) {
                        if (e.popup && e.popup._contentNode) {
                            const popupElement = e.popup._contentNode.parentElement;
                            if (popupElement) {
                                popupElement.classList.remove('show');
                                popupElement.classList.add('hide');

                                setTimeout(() => {
                                    if (e.popup) {
                                        e.popup.remove(); 
                                    }
                                    setTimeout(() => {
                                        updateMinimalPopups();
                                    }, 100);
                                }, 200); 
                            }
                        }
                    });

                    marker.on('click', function() {
                        if (markers[id].minimalPopup) {
                            createOrUpdateMinimalTooltip(id, false);
                        }
                        marker.openPopup();
                    });
                        animateMarker(markers[id], [latitude, longitude]);
                        setTimeout(() => {
                            updateMinimalPopups();
                        }, 1000);

                    }


                map.on('zoomend', updateMinimalPopups);

                }
        });



Object.keys(markers).forEach(id => {
    if (!activeVehicleIds.has(id)) {
        if (markers[id].minimalPopup) {
            returnToPool(markers[id].minimalPopup);
            markers[id].minimalPopup = null;
        }
        delete window.minimalTooltipStates[id];
        map.removeLayer(markers[id]); 
        delete markers[id]; 
    }
});

setInterval(() => {
    if (contentCache.size > 30) { 
        contentCache.clear();
    }
    if (colorCache.size > 20) {
        colorCache.clear();
    }
}, 180000); 

        
let isMenuVisible = true;

const favoriteLines = new Set(JSON.parse(localStorage.getItem('favoriteLines') || '[]'));

const ANIMATION_CONFIG = {
    DURATION: 400,
    POP_DURATION: 100,
    SPRING_TIMING: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    SCALE_UP: 1.03,
    ITEM_MARGIN: 10
};

function createNearbyVehiclesControl() {
    if (window.nearbyVehiclesControlInstance) {
        return window.nearbyVehiclesControlInstance;
    }

    const NearbyVehiclesControl = L.Control.extend({
        options: {
            position: 'topleft'
        },

        initialize: function(map) {
            L.Control.prototype.initialize.call(this, { map: map });
            this._lastUpdateCenter = null;
        },

        onAdd: function(map) {
            if (this._container) {
                return this._container;
            }

            this._container = L.DomUtil.create('div', 'nearby-vehicles-control');
            this._container.style.cssText = `
                position: absolute;
                width: max-content;
                font-family: 'League Spartan', sans-serif;
                margin-left: 12px;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 15px;
                box-shadow: 0 4px 20px 4px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                overflow: hidden;
                transition: all 0.5s cubic-bezier(0.25, 1.2, 0.5, 1);
                max-height: 60px;
                opacity: 0;
                display: none;
            `;

            const header = L.DomUtil.create('div', 'nearby-vehicles-header');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                cursor: pointer;
            `;

            const title = L.DomUtil.create('h3', '');
            title.textContent = 'Véhicules à proximité';
            title.style.cssText = `
                margin: 0;
                font-size: 20px;
                font-weight: 600;
                color: white;
                text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            `;


            header.appendChild(title);
            this._container.appendChild(header);

            this._listContainer = L.DomUtil.create('div', 'nearby-vehicles-list');
            this._listContainer.style.cssText = `
                max-height: 350px;
                overflow-y: auto;
                padding: 10px 15px;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
            `;
            this._container.appendChild(this._listContainer);

            this._isExpanded = false;
            this._isVisible = false;

            header.addEventListener('click', () => {
                this.toggleExpand();
            });


            map.on('moveend', () => this._updateVehiclesIfNeeded(map));

            return this._container;
        },

        _updateVehiclesIfNeeded: function(map) {
            const currentCenter = map.getCenter();
            const distanceMoved = this._lastUpdateCenter 
                ? currentCenter.distanceTo(this._lastUpdateCenter) 
                : Infinity;

            if (!this._lastUpdateCenter || distanceMoved > 500) {
                this._lastUpdateCenter = currentCenter;
                
                if (this._isExpanded) {
                    this.show();
                }
            }
        },

        show: function() {
            this._container.style.display = 'block';
            
            setTimeout(() => {
                this._container.style.opacity = '1';
            }, 10);

            const userLocation = map.getCenter();

            const closestVehicles = Object.values(markers)
                .filter(marker => marker.options && marker.options.icon)
                .map(marker => ({
                    marker: marker,
                    distance: userLocation.distanceTo(marker.getLatLng())
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);

            this._listContainer.innerHTML = '';

            closestVehicles.forEach((item) => {
                const marker = item.marker;
                const distance = (item.distance / 1000).toFixed(1);
                
                const vehicleId = marker.id;
                const line = marker.line;
                const backgroundColor = lineColors[line] || '#000000';
                const textColor = 'white';

                const vehicleItem = L.DomUtil.create('div', 'nearby-vehicle-item');
                vehicleItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    background-color: rgba(255, 255, 255, 0.1);
                    border-radius: 10px;
                    padding: 10px;
                    cursor: pointer;
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    color: white;
                `;

                vehicleItem.innerHTML = `
                    <div style="flex-grow: 1; z-index: 1; position: relative;">
                        <strong>Ligne ${lineName[line] || 'Inconnue'}</strong>
                        <div style="font-size: 0.8em; opacity: 0.7;">
                            à ${distance} km
                        </div>
                    </div>
                    <div style="
                        background: transparent; 
                        color: white; 
                        padding: 5px 10px; 
                        border-radius: 5px; 
                        z-index: 1; 
                        position: relative;
                        border: 1px solid white;
                    ">
                        ${vehicleId}
                    </div>
                `;

                vehicleItem.addEventListener('click', () => {
                    map.setView(marker.getLatLng(), 15);
                    marker.openPopup();
                    this.collapse();
                });

                this._listContainer.appendChild(vehicleItem);
            });

            if (!this._isExpanded) {
                this.expand();
            }

            this._isVisible = true;
            return this;
        },

        hide: function() {
            this._container.style.opacity = '0';
            
            setTimeout(() => {
                this._container.style.display = 'none';
            }, 300);

            this._isVisible = false;
            this._isExpanded = false;
            return this;
        },

        expand: function() {
            const header = this._container.querySelector('.nearby-vehicles-header');
            const listContainer = this._listContainer;

            this._container.style.maxHeight = '500px';
            listContainer.style.opacity = '1';
            listContainer.style.transform = 'translateY(0)';
            

            this._isExpanded = true;
            return this;
        },

        collapse: function() {
            const header = this._container.querySelector('.nearby-vehicles-header');
            const listContainer = this._listContainer;

            this._container.style.maxHeight = '60px';
            listContainer.style.opacity = '0';
            listContainer.style.transform = 'translateY(-20px)';
            

            this._isExpanded = false;
            return this;
        },

        toggleExpand: function() {
            if (this._isExpanded) {
                this.collapse();
            } else {
                this.expand();
            }
            return this;
        }
    });

    const nearbyVehiclesControl = new NearbyVehiclesControl(map);
    map.addControl(nearbyVehiclesControl);

    window.nearbyVehiclesControlInstance = nearbyVehiclesControl;

    window.nearbyVehiclesControl = {
        show: () => nearbyVehiclesControl.show(),
        hide: () => nearbyVehiclesControl.hide(),
        expand: () => nearbyVehiclesControl.expand(),
        collapse: () => nearbyVehiclesControl.collapse(),
        toggleExpand: () => nearbyVehiclesControl.toggleExpand()
    };

    return nearbyVehiclesControl;
}

createNearbyVehiclesControl();

let isAnimating = false;

function getAbsolutePositions(menu) {
    const sections = Array.from(menu.querySelectorAll('.linesection'));
    const positions = new Map();
    let accumulatedHeight = 0;
    
    sections.forEach(section => {
        const rect = section.getBoundingClientRect();
        positions.set(section, {
            top: accumulatedHeight,
            height: rect.height,
            index: sections.indexOf(section)
        });
        accumulatedHeight += rect.height + ANIMATION_CONFIG.ITEM_MARGIN;
    });
    
    return { sections, positions };
}

function getTargetIndex(sections, movingSection, isFavorite, favoriteLines) {
    const movingLine = movingSection.dataset.line;
    
    if (isFavorite) {
        const firstNonFavoriteIndex = sections.findIndex(section => 
            !favoriteLines.has(section.dataset.line)
        );
        
        if (firstNonFavoriteIndex === sections.indexOf(movingSection)) {
            return -1;
        }
        
        return firstNonFavoriteIndex === -1 ? sections.length : firstNonFavoriteIndex;
    } else {
        let targetIndex = 0; 
        
        for (let i = 0; i < sections.length; i++) {
            const sectionLine = sections[i].dataset.line;
            
            if (favoriteLines.has(sectionLine)) {
                const movingNum = parseInt(movingLine);
                const sectionNum = parseInt(sectionLine);
                
                if (!isNaN(movingNum) && !isNaN(sectionNum)) {
                    if (movingNum < sectionNum) {
                        return i;
                    }
                } else if (movingLine.localeCompare(sectionLine) < 0) {
                    return i;
                }
            } else {
                return i; 
            }
        }
        
        return sections.length;
    }
}

function prepareSectionsForAnimation(sections) {
    sections.forEach(section => {
        section.style.transition = 'none';
        section.style.position = 'relative';
        section.style.zIndex = '1';
        section.style.transform = 'translateY(0)';
    });
    
    // Force reflow
    sections[0].offsetHeight;
}

async function animateFavoriteTransition(button, lineSection, line, isFavorite) {
    if (isAnimating) return;
    isAnimating = true;
    
    const menu = document.getElementById('menu');
    if (!menu || !lineSection) return;
    
    try {
        menu.style.pointerEvents = 'none';
        button.style.pointerEvents = 'none';
        
        const { sections, positions } = getAbsolutePositions(menu);
        const currentIndex = sections.indexOf(lineSection);
        
        if (isFavorite) {
            favoriteLines.delete(line);
        } else {
            favoriteLines.add(line);
        }
        
        const targetIndex = getTargetIndex(sections, lineSection, isFavorite, favoriteLines);
        
        if (targetIndex === -1 || currentIndex === -1 || targetIndex === currentIndex) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            try {
                localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
            } catch (error) {
                console.error('Error saving favorite', error);
            }
            await cleanup(menu, button);
            return;
        }
        
        if (isFavorite) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            button.innerHTML = '☆';
        } else {
            await animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
        }
        
        try {
            localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
        } catch (error) {
            console.error('Error saving favorite', error);
        }
        
    } catch (error) {
        console.error('Animation err', error);
    } finally {
        await cleanup(menu, button);
    }
}

async function animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    for (let i = 0; i < targetIndex; i++) {
        if (i !== currentIndex) {
            const section = sections[i];
            const sectionPos = positions.get(section);
            targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = 0;
            
            if (currentIndex < targetIndex) {
                if (index > currentIndex && index <= targetIndex) {
                    displacement = -(currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
                }
            } else {
                if (index >= targetIndex && index < currentIndex) {
                    displacement = currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
                }
            }
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    lineSection.style.transform = `scale(0.95)`;
    await new Promise(r => setTimeout(r, 100));
    lineSection.style.transform = `translateY(${deltaY}px) scale(0.95)`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1)`;
    
    button.innerHTML = '★';
    button.style.transform = 'scale(1.2)';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

async function animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    if (targetIndex === -1) {
        targetIndex = sections.length;
        sections.forEach((section, idx) => {
            if (idx !== currentIndex) {
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        });
    } else {
        for (let i = 0; i < targetIndex; i++) {
            if (i !== currentIndex) {
                const section = sections[i];
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = calculateDisplacement(index, currentIndex, targetIndex, 
                currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    await animateMovingSection(lineSection, deltaY);
    
    button.style.transform = 'scale(0.8)';
    button.innerHTML = '☆';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

function calculateDisplacement(index, currentIndex, targetIndex, sectionHeight) {
    if (targetIndex === -1) {
        return index > currentIndex ? -sectionHeight : 0;
    }
    
    if (currentIndex < targetIndex) {
        return (index > currentIndex && index <= targetIndex) ? -sectionHeight : 0;
    } else {
        return (index >= targetIndex && index < currentIndex) ? sectionHeight : 0;
    }
}

async function animateMovingSection(section, deltaY) {
    section.style.transform = `scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.POP_DURATION));
    
    section.style.transform = `translateY(${deltaY}px) scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    
    section.style.transform = `translateY(${deltaY}px) scale(1)`;
}


function updateFavoriteState(button, line, isFavorite) {
    if (isFavorite) {
        favoriteLines.delete(line);
        button.innerHTML = '☆';
    } else {
        favoriteLines.add(line);
        button.innerHTML = '★';
    }
    
    try {
        localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
    } catch (error) {
        console.error('Error saving favorite', error);
    }
}



async function cleanup(menu, button) {
    await new Promise(r => setTimeout(r, 50));
    
    const sections = menu.querySelectorAll('.linesection');
    sections.forEach(section => {
        section.style.transform = '';
        section.style.transition = '';
        section.style.zIndex = '';
        section.style.position = '';
    });
    
    menu.style.pointerEvents = 'auto';
    button.style.pointerEvents = 'auto';
    
    updateMenu();
    isAnimating = false;
}

const animationStyle = document.createElement('style');
animationStyle.textContent = `
    .linesection {
        transition: transform 0.2s  cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
    }
    
    .linesection.removing {
        animation: remove-favorite 0.3s ease-out forwards;
    }
    
    @keyframes remove-favorite {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .favorite-button {
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
    
    .favorite-button:hover {
        transform: scale(1.1);
    }
    
    .favorite-button:active {
        transform: scale(0.9);
    }
`;
document.head.appendChild(animationStyle);

function closeMenu() {
    const menu = document.getElementById('menu');
    const menubottom1 = document.getElementById('menubtm');
    const mapp = document.getElementById('map');
    mapp.style.opacity = '1';
    

    const map = document.getElementById('map');
    menu.classList.add('hidden');
    if (localStorage.getItem('transparency') === 'true') {
        const map = document.getElementById('map');
        map.classList.remove('hiddennotransition');
        map.classList.add('appearnotransition');
        map.classList.remove('hidden');
        map.classList.remove('appear');
    } else {
        const map = document.getElementById('map');
        map.classList.remove('hidden');
        map.classList.add('appear');
        map.classList.remove('hiddennotransition');
        map.classList.remove('appearnotransition');
    }

    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false;
    const filtre = document.getElementById('filtre');
    menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
        if (selectedLine) {
            filtre.classList.remove('slide-upc');
            filtre.classList.add('slide-downc');
            filtre.style.display = 'flex';
        }
    }, 10);
}

function updateMenu() {
    const menu = document.getElementById('menu');
    menu.innerHTML = '';
    
    const topBar = document.createElement('div');
    topBar.classList.add('menu-top-bar');
    topBar.style.cssText = `
        position: sticky;
        top: 0;
        left: 0;
        background-color: #1a1a1ab0;
        color: white;
        padding: 9px;
        display: flex;
        align-items: center;
        z-index: 1001;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
    `;
    menu.appendChild(topBar);
    
    const backButton = document.createElement('div');
    backButton.innerHTML = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15 6L9 12L15 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
    backButton.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 8px;
        margin-right: 15px;
        border-radius: 8px;
        transition: background 0.2s ease;
    `;
    backButton.onmouseover = () => backButton.style.background = 'rgba(255, 255, 255, 0.1)';
    backButton.onmouseout = () => backButton.style.background = 'transparent';

    backButton.onclick = closeMenu;
    topBar.appendChild(backButton);

    
    const title = document.createElement('div');
    title.textContent = `${t("network")}`;
    title.style.cssText = `
        font-size: 20px;
        font-weight: 500;
    `;
    topBar.appendChild(title);

    
    const spacer = document.createElement('div');
    spacer.style.height = '15px'; 
    menu.appendChild(spacer);

    let lastScrollTop = 0;
    
    menu.addEventListener('scroll', function() {
        const scrollTop = menu.scrollTop;
        
        if (scrollTop > lastScrollTop && scrollTop > 50) {
            topBar.style.transform = 'translateY(-100%)';
        } else {
            topBar.style.transform = 'translateY(0)';
        }
        
        lastScrollTop = scrollTop;
    });

let isStandardView = localStorage.getItem('isStandardView') === 'true';

function toggleMapView(forceState) {
    if (forceState !== undefined) {
        isStandardView = forceState;
    } else {
        isStandardView = !isStandardView;
    }
    
    localStorage.setItem('isStandardView', isStandardView);

    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const mapp = document.getElementById('map');
    mapp.style.opacity = '1';
    const map = document.getElementById('map');
    menu.classList.add('hidden');

    if (localStorage.getItem('transparency') === 'true') {
        const map = document.getElementById('map');
        map.classList.remove('hiddennotransition');
        map.classList.add('appearnotransition');
        map.classList.remove('hidden');
        map.classList.remove('appear');
    } else {
        const map = document.getElementById('map');
        map.classList.remove('hidden');
        map.classList.add('appear');
        map.classList.remove('hiddennotransition');
        map.classList.remove('appearnotransition');
    }
    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false;
    menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
        if (selectedLine) {
            const filtre = document.getElementById('filtre');
            filtre.classList.remove('slide-upc');
            filtre.classList.add('slide-downc');
            filtre.style.display = 'flex';
        }
    }, 10);

    applyMapView();
}

function applyMapView() {
    const currentDate = new Date();
    const latitude = map.getCenter().lat;  
    const longitude = map.getCenter().lng;  

    map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer) {
            map.removeLayer(layer);
        }
    });

    if (!isStandardView) {
    const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(map);
    
    if (localStorage.getItem('darkmap') === 'true') {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'none';
    }

} else {
    const mapPane = map.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(map);

}
}


let startY;
let endY;
let startX;
let endX;
const menubtm = document.getElementById('menubtm');
let touchStartX = null;
let touchStartTime = null;
let isEdgeTouch = false;
const edgeThreshold = 10;
const minSwipeDistance = 20; 

menubtm.addEventListener('touchstart', (e) => {
    const touchStartY = e.touches[0].clientY;
    const menuRect = menubtm.getBoundingClientRect();
    
    startX = e.touches[0].clientX;
    
    if (touchStartY >= menuRect.bottom - 50) {
        startY = touchStartY;
    } else {
        startY = null;
    }
});

menubtm.addEventListener('touchmove', (e) => {
    if (startY !== null) {
        endY = e.touches[0].clientY;
    }
    
    endX = e.touches[0].clientX;
});


function isTouchNearRightEdge(x) {
    return window.innerWidth - x <= edgeThreshold;
}

document.addEventListener('touchstart', function(e) {
    const touchX = e.touches[0].clientX;
    
    if (isTouchNearRightEdge(touchX)) {
        touchStartX = touchX;
        touchStartTime = Date.now();
        isEdgeTouch = true;
    }
}, { passive: true }); 

document.addEventListener('touchmove', function(e) {
    if (isEdgeTouch) {
        const currentX = e.touches[0].clientX;
    }
}, { passive: true });

document.addEventListener('touchend', function(e) {
    if (isEdgeTouch && touchStartX !== null) {
        const touchEndX = e.changedTouches[0].clientX;
        const swipeDistance = touchStartX - touchEndX;
        const touchDuration = Date.now() - touchStartTime;
            if (swipeDistance > minSwipeDistance && touchDuration < 300) {
                showMenu();
            }
        
        isEdgeTouch = false;
        touchStartX = null;
        touchStartTime = null;
    }
});





function getNextStopInfo(vehicleId) {
    const vehicle = markers[vehicleId];
    if (!vehicle) return null;
    
    const currentStopId = vehicle.stopId ? vehicle.stopId.replace("0:", "") : null;
    
    for (const [tripId, tripData] of Object.entries(tripUpdates)) {
        if (!tripData.nextStops || !tripData.nextStops.length) continue;
        
        const currentStopIndex = tripData.nextStops.findIndex(stop => 
            stop.stopId.replace("0:", "") === currentStopId
        );
        
        if (currentStopIndex !== -1 && tripData.nextStops[currentStopIndex + 1]) {
            const nextStop = tripData.nextStops[currentStopIndex + 1];
            return {
                name: stopNameMap[nextStop.stopId] || nextStop.stopId,
                delay: nextStop.delay,
                departureTime: nextStop.departureTime
            };
        }
    }
    return null;
}


    const busesByLineAndDestination = {};

    Object.keys(markers).forEach(id => {
    const vehicle = markers[id];
    const line = vehicle.line;
    
    let destination = "Inconnue";
    const popupContent = vehicle.getPopup().getContent();
    
    const patterns = [
        /<strong[^>]*>➜\s*(.*?)<\/strong>/,
        />➜\s*(.*?)</,
        /Ligne \d+<\/p>\s*<strong[^>]*>➜\s*(.*?)<\/strong>/
    ];

    for (const pattern of patterns) {
        const match = popupContent.match(pattern);
        if (match && match[1]) {
            destination = match[1].trim();
            if (destination.toLowerCase() !== 'Destination inconnue') {
                break;
            }
        }
    }

    if (!busesByLineAndDestination[line]) {
        busesByLineAndDestination[line] = {};
    }

    if (!busesByLineAndDestination[line][destination]) {
        busesByLineAndDestination[line][destination] = [];
    }

    busesByLineAndDestination[line][destination].push({
        parkNumber: vehicle.id,
        vehicle
    });
});

    const sortedLines = Object.keys(busesByLineAndDestination)
        .sort((a, b) => {
            const aIsFavorite = favoriteLines.has(a);
            const bIsFavorite = favoriteLines.has(b);
            
            if (aIsFavorite && !bIsFavorite) return -1;
            if (!aIsFavorite && bIsFavorite) return 1;
            
    const getSortKey = (line) => {
        
        let typeValue = 1000; 
        
        if (/^[A-Za-z]$/.test(line)) {
            typeValue = 100;
        } 
        else if (/^\d+$/.test(line)) {
            typeValue = 200;
        } 
        else if (/^\d+[A-Za-z]+$/.test(line)) {
            const numPart = parseInt(line.match(/^\d+/)[0], 10);
            typeValue = 200; 
            return typeValue + numPart + 0.5; 
        }
        
        if (typeValue === 200) {
            return typeValue + parseInt(line, 10);
        }
        
        if (typeValue === 100) {
            return typeValue + line.charCodeAt(0);
        }
        
        return typeValue;
    };

    const valueA = getSortKey(a);
    const valueB = getSortKey(b);

    if (valueA !== valueB) {
        return valueA - valueB;
    }

    return a.localeCompare(b);
    });


function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return { r, g, b };
}


function calculateLuminance(r, g, b) {
    return (r * 0.299 + g * 0.587 + b * 0.114);
}


function getTextColor(backgroundColor) {
    try {
        let hexColor = backgroundColor;
        
        if (!hexColor.startsWith('#')) {
            hexColor = '#' + hexColor;
        }
        
        const { r, g, b } = hexToRgb(hexColor);
        
        const luminance = calculateLuminance(r, g, b);
        
        const threshold = 150;
                
        return luminance > threshold ? '#000000' : '#ffffff';
    } catch (e) {
        return '#ffffff';
    }
}


sortedLines.forEach(line => {
    const lineNameText = lineName[line] || t("unknown_line");
    const lineColor = lineColors[line] || '#000000';
    const textColor = getTextColor(lineColor);

    const lineSection = document.createElement('div');
    lineSection.dataset.line = line;
    lineSection.style.backgroundColor = lineColor;
    lineSection.classList.add('linesection');
    lineSection.style.marginBottom = '10px';
    lineSection.style.marginLeft = '10px';
    lineSection.style.marginRight = '10px';
    lineSection.style.padding = '10px';
    lineSection.style.borderRadius = '16px';
    lineSection.style.position = 'relative';
    lineSection.style.overflow = 'hidden';

    const beam1 = document.createElement('div');
    beam1.classList.add('light-beam', 'beam1');
    lineSection.appendChild(beam1);

    const beam2 = document.createElement('div');
    beam2.classList.add('light-beam', 'beam2');
    lineSection.appendChild(beam2);

    const beam3 = document.createElement('div');
    beam3.classList.add('light-beam', 'beam3');
    lineSection.appendChild(beam3);

    lineSection.onmouseover = () => {
        lineSection.style.transform = 'scale(0.99,0.99)';
        lineSection.style.opacity = '0.9';
        lineSection.style.boxShadow = '0 0px 20px 11px rgba(0, 0, 0, 0.1)';
        };  

    lineSection.onmouseout = () => {
        lineSection.style.transform = 'scale(1,1)';
        lineSection.style.opacity = '0.9';
        lineSection.style.boxShadow = '0 0px 20px 3px rgba(0, 0, 0, 0.1)';
    };

    

    const favoriteButton = document.createElement('button');
    favoriteButton.style.position = 'absolute';
    favoriteButton.style.right = '5px';
    favoriteButton.style.top = '5px';
    favoriteButton.style.background = 'none';
    favoriteButton.style.border = 'none';
    favoriteButton.style.color = textColor;
    favoriteButton.style.fontSize = '20px';
    favoriteButton.style.cursor = 'pointer';
    favoriteButton.innerHTML = favoriteLines.has(line) ? '★' : '☆';
    favoriteButton.onclick = async (e) => {
        e.stopPropagation();
        const lineSection = e.target.closest('.linesection');
        const isFavorite = favoriteLines.has(line);
        await animateFavoriteTransition(e.target, lineSection, line, isFavorite);
    };

    const lineTitle = document.createElement('div');
    lineTitle.textContent = `${t("line")} ${lineNameText}`;
    lineTitle.style.fontSize = '20px';
    lineTitle.style.fontWeight = 'normal';
    lineTitle.style.color = textColor;
    lineTitle.style.paddingRight = '30px';
    lineTitle.style.paddingLeft = '10px';

    lineSection.appendChild(lineTitle);
    lineSection.appendChild(favoriteButton);

    Object.keys(busesByLineAndDestination[line])
        .sort()
        .forEach(destination => {
            
            const destinationSection = document.createElement('div');
            destinationSection.style.marginTop = '5px';
            destinationSection.style.paddingLeft = '10px';

            const destinationTitle = document.createElement('div');
            destinationTitle.textContent = `➜ ${destination}`;
            destinationTitle.style.fontSize = '16px';
            destinationTitle.style.fontWeight = 'normal';
            destinationTitle.style.marginBottom = '4px';
            destinationTitle.style.color = textColor;
            destinationSection.appendChild(destinationTitle);

       


            busesByLineAndDestination[line][destination].forEach(bus => {
                const busItem = document.createElement('div');
                const marker = bus.vehicle;
                const popupContent = marker.getPopup().getContent();
                
                let nextStopInfo = '';
                let terminusInfo = '';
                
                const stopNameContainers = popupContent.match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/g);
                const timeDisplays = popupContent.match(/<div class="time-display"[^>]*data-time-left="([^"]*)"[^>]*data-departure-time="([^"]*)"[^>]*>([\s\S]*?)<\/div>/g);
                
                if (stopNameContainers && stopNameContainers.length > 0 && timeDisplays && timeDisplays.length > 0) {
                    const firstStopNameMatch = stopNameContainers[0].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                    const firstTimeMatch = timeDisplays[0].match(/data-time-left="([^"]*)"/);
                    
                    if (firstStopNameMatch && firstStopNameMatch[1] && firstTimeMatch && firstTimeMatch[1]) {
                        const stopName = firstStopNameMatch[1].trim();
                        const timeInfo = firstTimeMatch[1].trim();
                        if (stopName && timeInfo) {
                            nextStopInfo = `${stopName}`;
                        }
                    }
                    
                    if (stopNameContainers.length > 1 && timeDisplays.length > 1) {
                        const lastIndex = stopNameContainers.length - 1;
                        const lastStopNameMatch = stopNameContainers[lastIndex].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                        const lastTimeMatch = timeDisplays[lastIndex].match(/data-time-left="([^"]*)"/);
                        
                        if (lastStopNameMatch && lastStopNameMatch[1] && lastTimeMatch && lastTimeMatch[1]) {
                            const terminusName = lastStopNameMatch[1].trim();
                            const terminusTime = lastTimeMatch[1].trim();
                            if (terminusName && terminusTime) {
                                terminusInfo = `${t("arrivalat")} ${destination} ${terminusTime !== t("imminent") ? t("in") + ' ' + terminusTime : t("imminent")}.`;
                            }
                        }
                    }
                }
                
                if (!nextStopInfo || !terminusInfo) {
                    const stopsHeaderMatch = popupContent.match(/<p style="margin: 0; font-size: 18px; text-align: right;">(.*?)<\/p>/);
                    if (stopsHeaderMatch && stopsHeaderMatch[1]) {
                        const headerText = stopsHeaderMatch[1].trim();
                        if (headerText.includes('imminent')) {
                            nextStopInfo = t("imminentdeparture") + '.';
                        } else if (headerText.includes('min')) {
                            const minMatch = headerText.match(/dans (\d+) min/);
                            if (minMatch && minMatch[1]) {
                                nextStopInfo = `${t("departurein")} ${minMatch[1]} ${t("min")}.`;
                            }
                        }
                    }
                    
                    if (!terminusInfo) {
                        terminusInfo = `${t("indirectionof")} ${destination}.`;
                    }
                }

                const mainText = document.createElement('div');
                const labelMatch = popupContent.match(/<span style="display: inline-block[^>]*>([^<]+)<\/span>/);
                const vehicleLabel = labelMatch ? labelMatch[1].trim() : "Véhicule inconnu";
                const vehicleBrandHtmlLight = getVehicleBrandHtmlLight(vehicleLabel);
                const displayLabel = vehicleLabel.replace(/Véhicule inconnu\./, "inconnu");
                
                // création de disp flexbox pour aligner parc et les info
                mainText.style.display = 'flex';
                mainText.style.alignItems = 'center';
                mainText.style.gap = '10px';
                mainText.style.fontSize = '1.2em';
                mainText.style.fontWeight = '500';
                mainText.style.color = textColor;

                // création boîte pour parc
                const busIdBox = document.createElement('div');
                busIdBox.textContent = displayLabel;
                busIdBox.style.padding = '2px 8px';
                busIdBox.style.backgroundColor = '#00000017';
                busIdBox.style.borderRadius = '6px';
                busIdBox.style.fontWeight = 'bold';
                busIdBox.style.color = textColor;
                busIdBox.style.display = 'inline-block';
                busIdBox.style.textAlign = 'center';
                busIdBox.style.padding = '5px 10px';

                // statut véc
                const infoText = document.createElement('span');
                infoText.textContent = `${nextStopInfo}`;

                // ajout des éléments au dom
                mainText.appendChild(infoText);

                const arrivalText = document.createElement('div');
                arrivalText.textContent = terminusInfo;
                arrivalText.style.fontSize = '0.9em'; 
                arrivalText.style.opacity = '0.8';  
                arrivalText.style.color = textColor;

                const contentContainer = document.createElement('div');
                contentContainer.style.display = 'flex';
                contentContainer.style.flexDirection = 'column';
                contentContainer.style.flexGrow = '1';
                contentContainer.appendChild(mainText);
                contentContainer.appendChild(arrivalText);

                busItem.style.position = 'relative';
                
                const backgroundContainer = document.createElement('div');
                backgroundContainer.style.position = 'absolute';
                backgroundContainer.style.right = '8px';
                backgroundContainer.style.bottom = '0';
                backgroundContainer.style.display = 'flex';
                backgroundContainer.style.alignItems = 'center';
                backgroundContainer.style.justifyContent = 'flex-end';
                backgroundContainer.style.pointerEvents = 'none'; 
                backgroundContainer.style.opacity = '0.2';
                backgroundContainer.style.zIndex = '0'; 
                backgroundContainer.style.scale = '1.7';
                backgroundContainer.innerHTML = vehicleBrandHtmlLight;
                
                const thumbnailImg = backgroundContainer.querySelector('.vehicle-thumbnaill');
                if (thumbnailImg) {
                    thumbnailImg.style.height = '80%';
                    thumbnailImg.style.width = 'auto';
                    thumbnailImg.style.maxHeight = '40px';
                    thumbnailImg.style.objectFit = 'contain';
                }

                busItem.textContent = '';
                busItem.style.display = 'flex';
                busItem.style.alignItems = 'center';
                busItem.style.gap = '10px';
                busItem.style.overflow = 'hidden'; 
                busItem.style.boxShadow = '0 0 7px 0px rgb(0 0 0 / 24%)';


                
                busItem.appendChild(backgroundContainer);
                
                const frontContent = document.createElement('div');
                frontContent.style.display = 'flex';
                frontContent.style.alignItems = 'center';
                frontContent.style.gap = '10px';
                frontContent.style.width = '100%';
                frontContent.style.position = 'relative';
                frontContent.style.zIndex = '1';
                
                frontContent.appendChild(busIdBox);
                frontContent.appendChild(contentContainer);
                busItem.appendChild(frontContent);

                busItem.style.cursor = 'pointer';
                busItem.classList.add('menu-item');
                busItem.style.fontFamily = 'League Spartan';
                busItem.style.color = textColor;
                busItem.style.padding = '5px 10px';
                busItem.style.marginBottom = '8px';
                busItem.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                busItem.style.borderRadius = '8px';

                lineSection.onclick = () => {
                    const mapp = document.getElementById('map');
                    mapp.style.opacity = '1';
                    safeVibrate([50, 30, 50], true);
                    const lineId = line;
                    selectedLine = lineId;
                    filterByLine(lineId);
                    const map = document.getElementById('map');
                    map.style.opacity = '1';
                    menu.classList.add('hidden');
                    if (localStorage.getItem('transparency') === 'true') {
                        const map = document.getElementById('map');
                        map.classList.remove('hiddennotransition');
                        map.classList.add('appearnotransition');
                        map.classList.remove('hidden');
                        map.classList.remove('appear');
                    } else {
                        const map = document.getElementById('map');
                        map.classList.remove('hidden');
                        map.classList.add('appear');
                        map.classList.remove('hiddennotransition');
                        map.classList.remove('appearnotransition');
                    }
                    window.isMenuShowed = false;
                    menu.addEventListener('animationend', function onAnimationEnd(event) {
                        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                            menu.style.display = 'none';
                        }
                    });
                    isMenuVisible = false;
                    const filtre = document.getElementById('filtre');
                    menubottom1.style.display = 'flex';
                    setTimeout(() => {
                        menubottom1.classList.remove('slide-upb');
                        menubottom1.classList.add('slide-downb');
                        if (selectedLine) {
                            filtre.classList.remove('slide-upc');
                            filtre.classList.add('slide-downc');
                            filtre.style.display = 'flex';
                        }
                    }, 10);
                    event.stopPropagation();

                };

                busItem.onclick = (event) => {
                    event.stopPropagation();
                    safeVibrate([50, 300, 50, 30, 50], true);
                    map.setView(bus.vehicle.getLatLng(), 15);
                    bus.vehicle.openPopup();
                    const mapp = document.getElementById('map');
                    mapp.style.opacity = '1';
                    menu.classList.add('hidden');
                    if (localStorage.getItem('transparency') === 'true') {
                        const map = document.getElementById('map');
                        map.classList.remove('hiddennotransition');
                        map.classList.add('appearnotransition');
                        map.classList.remove('hidden');
                        map.classList.remove('appear');
                    } else {
                        const map = document.getElementById('map');
                        map.classList.remove('hidden');
                        map.classList.add('appear');
                        map.classList.remove('hiddennotransition');
                        map.classList.remove('appearnotransition');
                    }
                    window.isMenuShowed = false;
                    menu.addEventListener('animationend', function onAnimationEnd(event) {
                        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                            menu.style.display = 'none';
                        }
                    });
                    isMenuVisible = false;
                    if (selectedLine) {
                        resetMapView();
                    }
                };

                destinationSection.appendChild(busItem);
            });

            lineSection.appendChild(destinationSection);
        });

    menu.appendChild(lineSection);
});
}

const menubottom1 = document.getElementById('menubtm');


        function showMenu() {
            window.isMenuShowed = true;
            const mapp = document.getElementById('map');
            mapp.style.opacity = '0.5';
            const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menu.classList.remove('hidden');
            if (localStorage.getItem('transparency') === 'true') {
                const map = document.getElementById('map');
                map.classList.add('hiddennotransition');
                map.classList.remove('appearnotransition');
                map.classList.remove('hidden');
                map.classList.remove('appear');
                menu.style.display = 'block'; 
                mapp.style.animationPlayState = 'running';
            } else {
                const map = document.getElementById('map');
                map.classList.add('hidden');
                map.classList.remove('appear');
                map.classList.remove('hiddennotransition');
                map.classList.remove('appearnotransition');

                menu.style.display = 'block'; 
                mapp.style.animationPlayState = 'running';
            }

            isMenuVisible = true; 
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
                const filtre = document.getElementById('filtre');
                filtre.classList.add('slide-upc');
                filtre.classList.remove('slide-downc');
                filtre.addEventListener('animationend', () => {
                    filtre.style.display = 'none';
                });
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });

        }

        const menubutton = document.getElementById('menubutton');
        menubutton.onclick = showMenu; 


        const closeMap = document.getElementById('map');
        closeMap.onclick = () => {
            const menu = document.getElementById('menu');
            const map = document.getElementById('map');
            map.style.opacity = '1';
            menu.classList.add('hidden');
            if (localStorage.getItem('transparency') === 'true') {
                const map = document.getElementById('map');
                map.classList.remove('hiddennotransition');
                map.classList.add('appearnotransition');
                map.classList.remove('hidden');
                map.classList.remove('appear');
            } else {
                const map = document.getElementById('map');
                map.classList.remove('hidden');
                map.classList.add('appear');
                map.classList.remove('hiddennotransition');
                map.classList.remove('appearnotransition');
            }
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });

            const menubottom1 = document.getElementById('menubtm');
            menubottom1.style.display = 'flex';
        
            setTimeout(() => {
                menubottom1.classList.remove('slide-upb');
                menubottom1.classList.add('slide-downb');
            }, 10);
                isMenuVisible = false; 
            };
            

        updateMenu();

    } catch (error) {
        return;
    }
}

const FluentSettingsMenu = (function() {
  let menuElement = null;
  let isOpen = false;
  let sections = {};
  let langSwitcher = null;
  
  const DEFAULT_CONFIG = {
    title: "Paramètres",
    accentColor: "#0078d7",
    width: "400px",
    height: "500px",
    zIndex: 10000,
    showCloseButton: true,
    animation: true
  };
  
  let options = { ...DEFAULT_CONFIG };
  

  function createStyles() {
    if (document.getElementById('fluent-settings-styles')) return;
    
    const styleElement = document.createElement('style');
    styleElement.id = 'fluent-settings-styles';
    styleElement.textContent = `
      @keyframes fluentFadeIn {
        from { opacity: 0; transform: translate(-50%, -48%); }
        to { opacity: 1; transform: translate(-50%, -50%); }
      }
      
      @keyframes fluentBackdropFadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .fluent-settings-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: ${options.zIndex - 1};
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .fluent-settings-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: ${options.width};
        height: ${options.height};
        background-color: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        display: none;
        flex-direction: column;
        font-family: 'League Spartan', sans-serif;
        z-index: ${options.zIndex};
        overflow: hidden;
        opacity: 0;
      }
      
      .fluent-settings-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }
      
      .fluent-settings-title {
        font-size: 18px;
        font-weight: 600;
        color: #333;
        margin: 0;
      }
      
      .fluent-settings-close {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: #666;
        transition: background-color 0.2s;
      }
      
      .fluent-settings-close:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }
      
      .fluent-settings-content {
        flex: 1;
        overflow-y: auto;
        padding: 0;
      }
      
      .fluent-settings-section {
        padding: 0;
        margin: 0;
      }
      
      .fluent-settings-section-title {
        font-size: 14px;
        font-weight: 600;
        color: ${options.accentColor};
        padding: 12px 20px 8px;
        margin: 0;
      }
      
      .fluent-settings-item {
        display: flex;
        align-items: center;
        padding: 12px 20px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .fluent-settings-item:hover {
        background-color: rgba(0, 0, 0, 0.03);
      }
      
      .fluent-settings-item-icon {
        width: 18px;
        height: 18px;
        margin-right: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: #666;
      }
      
      .fluent-settings-item-content {
        flex: 1;
      }
      
      .fluent-settings-item-label {
        font-size: 14px;
        color: #333;
        margin-bottom: 3px;
      }
      
      .fluent-settings-item-description {
        font-size: 12px;
        color: #666;
      }
      
      .fluent-settings-item-control {
        margin-left: 10px;
      }
      
      .fluent-settings-submenu-indicator {
        margin-left: 8px;
        color: #666;
        font-size: 10px;
      }
      
      .fluent-settings-back {
        display: flex;
        align-items: center;
        padding: 12px 20px;
        cursor: pointer;
        background-color: rgba(0, 0, 0, 0.02);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      }
      
      .fluent-settings-back:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }
      
      .fluent-settings-back-icon {
        margin-right: 10px;
        font-size: 12px;
      }
      
      .fluent-settings-back-text {
        font-size: 14px;
        color: #555;
      }
      
      .fluent-settings-submenu {
        position: absolute;
        top: 0;
        left: 100%;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.85);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
      }
      
      .fluent-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
      }
      
      .fluent-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .fluent-switch-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 20px;
      }
      
      .fluent-switch-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }
      
      input:checked + .fluent-switch-slider {
        background-color: ${options.accentColor};
      }
      
      input:checked + .fluent-switch-slider:before {
        transform: translateX(20px);
      }
      
      .fluent-select {
        padding: 5px 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: rgba(255, 255, 255, 0.8);
        font-family: 'League Spartan', sans-serif;
        font-size: 14px;
        color: #333;
      }
      
      .fluent-select:focus {
        outline: none;
        border-color: ${options.accentColor};
      }
    `;
    
    document.head.appendChild(styleElement);
  }
  

  function createMenuElement() {
    const backdrop = document.createElement('div');
    backdrop.className = 'fluent-settings-backdrop';
    
    const container = document.createElement('div');
    container.className = 'fluent-settings-container';
    
    const header = document.createElement('div');
    header.className = 'fluent-settings-header';

    // mhhhh les bonnes pizzas à l'ananas
    const pizza = document.getElementById('menuicon');
    const ananas = document.getElementById('myscheduleicon');
    const bousse = document.getElementById('vehicleicon');
    const mamamia = document.getElementById('actuicon');

    let naderbousse = 0;
    header.addEventListener('click', () => {
    naderbousse++;

    if (naderbousse === 5) {
        pizza.src = 'https://mybusfinder.fr/mamamialapizza.png'; 
        ananas.src = 'https://mybusfinder.fr/mamamialapizza.png'; 
        bousse.src = 'https://mybusfinder.fr/mamamialapizza.png';         
        mamamia.src = 'https://mybusfinder.fr/mamamialapizza.png'; 
    }
    });
    
    const title = document.createElement('h2');
    title.className = 'fluent-settings-title';
    title.textContent = options.title;
    
    header.appendChild(title);
    
    if (options.showCloseButton) {
      const closeButton = document.createElement('button');
      closeButton.className = 'fluent-settings-close';
      closeButton.innerHTML = '✕';
      closeButton.addEventListener('click', close);
      header.appendChild(closeButton);
    }
    
    container.appendChild(header);
    
    const content = document.createElement('div');
    content.className = 'fluent-settings-content';
    container.appendChild(content);
    
    document.body.appendChild(backdrop);
    document.body.appendChild(container);
    
    backdrop.addEventListener('click', close);
    
    menuElement = {
      backdrop,
      container,
      content
    };
  }
  

  function open() {
    if (!menuElement) {
      createStyles();
      createMenuElement();
      renderSections();
    }
    
    menuElement.backdrop.style.display = 'block';
    menuElement.container.style.display = 'flex';
    
    menuElement.container.offsetHeight;
    
    menuElement.backdrop.style.opacity = '1';
    menuElement.container.style.opacity = '1';
    
    if (options.animation) {
      menuElement.container.style.animation = 'fluentFadeIn 0.3s forwards';
      menuElement.backdrop.style.animation = 'fluentBackdropFadeIn 0.3s forwards';
    }
    
    isOpen = true;
  }
  

  function close(e) {
    if (!menuElement || !isOpen) return;
    
    menuElement.backdrop.style.opacity = '0';
    menuElement.container.style.opacity = '0';
    
    setTimeout(() => {
      menuElement.backdrop.style.display = 'none';
      menuElement.container.style.display = 'none';
      
      const submenus = menuElement.container.querySelectorAll('.fluent-settings-submenu');
      submenus.forEach(submenu => {
        submenu.style.transform = 'translateX(100%)';
      });
    }, 300);
    
    isOpen = false;
    e.stopPropagation();

  }
  

  function createSection(id, title) {
    if (sections[id]) {
      console.warn(`Une section avec l'ID "${id}" existe déjà.`);
      return sections[id];
    }
    
    sections[id] = {
      id,
      title,
      items: []
    };
    
    return sections[id];
  }
  

  function addToggle(sectionId, id, options) {
    const section = sections[sectionId];
    if (!section) {
      console.error(`Section "${sectionId}" non trouvée`);
      return;
    }
    
    section.items.push({
      type: 'toggle',
      id,
      icon: options.icon || '⚙️',
      label: options.label || 'Option',
      description: options.description || '',
      value: options.value || false,
      onChange: options.onChange || function() {}
    });
    
    return this;
  }
  

  function addSelect(sectionId, id, options) {
    const section = sections[sectionId];
    if (!section) {
      console.error(`Section "${sectionId}" non trouvée`);
      return;
    }
    
    section.items.push({
      type: 'select',
      id,
      icon: options.icon || '⚙️',
      label: options.label || 'Option',
      description: options.description || '',
      value: options.value || '',
      options: options.options || [],
      onChange: options.onChange || function() {}
    });
    
    return this;
  }
  
function addSubmenu(sectionId, id, options) {
  const section = sections[sectionId];
  if (!section) {
    console.error(`Section "${sectionId}" non trouvée`);
    return;
  }
  
  const submenuId = `submenu-${id}`;
  
  if (!sections[submenuId]) {
    createSection(submenuId, options.title || 'Sous-menu');
  }
  
  section.items.push({
    type: 'submenu',
    id,
    submenuId,
    icon: options.icon || '⚙️',
    label: options.label || 'Sous-menu',
    description: options.description || '',
    onclick: options.onclick || null 
  });
  
  return this;
}
  

  function addLanguageSwitcher(sectionId, options = {}) {
    const section = sections[sectionId];
    if (!section) {
      console.error(`Section "${sectionId}" non trouvée`);
      return;
    }
    
    const languages = options.languages || [
      { code: 'fr', name: 'Français 🇫🇷' },
      { code: 'en', name: 'English 🇬🇧' }
    ];
    
    section.items.push({
      type: 'language',
      id: 'language-switcher',
      icon: options.icon || '🌐',
      label: options.label || 'Langue',
      description: options.description || 'Changer la langue de l\'interface',
      languages,
      currentLang: options.currentLang || (window.i18n ? window.i18n.currentLang : languages[0].code),
      onChange: options.onChange || function(lang) {
        if (window.i18n) {
          const newLang = lang;
          
          if (newLang !== window.i18n.currentLang) {
            if (langSwitcher && langSwitcher.updateCurrentLanguage) {
              langSwitcher.updateCurrentLanguage(newLang);
            }
            
            const transitionOverlay = document.createElement('div');
            transitionOverlay.style.position = 'fixed';
            transitionOverlay.style.top = '0';
            transitionOverlay.style.left = '0';
            transitionOverlay.style.width = '100%';
            transitionOverlay.style.height = '100%';
            transitionOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            transitionOverlay.style.zIndex = '9999';
            transitionOverlay.style.opacity = '0';
            transitionOverlay.style.transition = 'opacity 0.4s ease';
            document.body.appendChild(transitionOverlay);
            
            setTimeout(() => {
              transitionOverlay.style.opacity = '1';
              
              const urlParams = new URLSearchParams(window.location.search);
              urlParams.set('lang', newLang);
              
              localStorage.setItem('preferredLanguage', newLang);
              
              setTimeout(() => {
                window.location.search = urlParams.toString();
              }, 300);
            }, 50);
          }
        }
      }
    });
    
    if (window.createLanguageSwitcher) {
      langSwitcher = window.createLanguageSwitcher();
    } else if (window.langSwitcher) {
      langSwitcher = window.langSwitcher;
    }
    
    return this;
  }
  

  function renderSections() {
    if (!menuElement) return;
    
    menuElement.content.innerHTML = '';
    
    Object.values(sections).forEach(section => {
      if (section.id.startsWith('submenu-')) return; 
      
      renderSection(section);
    });
  }
  

  function renderSection(section) {
    const sectionElement = document.createElement('div');
    sectionElement.className = 'fluent-settings-section';
    sectionElement.dataset.sectionId = section.id;
    
    const titleElement = document.createElement('h3');
    titleElement.className = 'fluent-settings-section-title';
    titleElement.textContent = section.title;
    sectionElement.appendChild(titleElement);
    
    section.items.forEach(item => {
      const itemElement = renderItem(item, section.id);
      sectionElement.appendChild(itemElement);
    });
    
    menuElement.content.appendChild(sectionElement);
    
    section.items.forEach(item => {
      if (item.type === 'submenu') {
        renderSubmenu(item.submenuId, section.id, item.label);
      }
    });
  }
  

  function renderItem(item, sectionId) {
    const itemElement = document.createElement('div');
    itemElement.className = 'fluent-settings-item';
    itemElement.dataset.itemId = item.id;
    
    const iconElement = document.createElement('div');
    iconElement.className = 'fluent-settings-item-icon';
    iconElement.textContent = item.icon;
    itemElement.appendChild(iconElement);
    
    const contentElement = document.createElement('div');
    contentElement.className = 'fluent-settings-item-content';
    
    const labelElement = document.createElement('div');
    labelElement.className = 'fluent-settings-item-label';
    labelElement.textContent = item.label;
    contentElement.appendChild(labelElement);
    
    if (item.description) {
      const descElement = document.createElement('div');
      descElement.className = 'fluent-settings-item-description';
      descElement.textContent = item.description;
      contentElement.appendChild(descElement);
    }
    
    itemElement.appendChild(contentElement);
    
    const controlElement = document.createElement('div');
    controlElement.className = 'fluent-settings-item-control';
    
    switch (item.type) {
      case 'toggle':
        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'fluent-switch';
        
        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.checked = item.value;
        toggleInput.addEventListener('change', (e) => {
          item.value = e.target.checked;
          if (item.onChange) item.onChange(item.value);
          safeVibrate([20, 10, 20], true);
        });
        
        const toggleSlider = document.createElement('span');
        toggleSlider.className = 'fluent-switch-slider';
        
        toggleLabel.appendChild(toggleInput);
        toggleLabel.appendChild(toggleSlider);
        controlElement.appendChild(toggleLabel);
        break;
        
      case 'select':
        const select = document.createElement('select');
        select.className = 'fluent-select';
        
        item.options.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.textContent = option.label;
          if (option.value === item.value) {
            optionElement.selected = true;
          }
          select.appendChild(optionElement);
        });
        
        select.addEventListener('change', (e) => {
          item.value = e.target.value;
          if (item.onChange) item.onChange(item.value);
        });
        
        controlElement.appendChild(select);
        break;
        
      case 'submenu':
        const indicator = document.createElement('span');
        indicator.className = 'fluent-settings-submenu-indicator';
        indicator.textContent = '❯';
        controlElement.appendChild(indicator);
        
        itemElement.addEventListener('click', (event) => {
        if (item.onclick && typeof item.onclick === 'function') {
            item.onclick(event);
            safeVibrate([50], true);
        }
        
        if (item.type === 'submenu') {
            const submenu = menuElement.container.querySelector(`.fluent-settings-submenu[data-submenu-id="${item.submenuId}"]`);
            if (submenu) {
            submenu.style.transform = 'translateX(0)';
            }
        }
        });
        break;
        
      case 'language':
        const langSelect = document.createElement('select');
        langSelect.className = 'fluent-select';
        
        item.languages.forEach(lang => {
          const optionElement = document.createElement('option');
          optionElement.value = lang.code;
          optionElement.textContent = lang.name;
          if (lang.code === item.currentLang) {
            optionElement.selected = true;
          }
          langSelect.appendChild(optionElement);
        });
        
        langSelect.addEventListener('change', (e) => {
          item.currentLang = e.target.value;
          safeVibrate([50, 30, 50], true);
          if (item.onChange) item.onChange(item.currentLang);
        });
        
        controlElement.appendChild(langSelect);
        break;
    }
    
    itemElement.appendChild(controlElement);
    
    return itemElement;
  }
  
  function renderSubmenu(submenuId, parentSectionId, title) {
    const submenuSection = sections[submenuId];
    if (!submenuSection) return;
    
    const submenuElement = document.createElement('div');
    submenuElement.className = 'fluent-settings-submenu';
    submenuElement.dataset.submenuId = submenuId;
    submenuElement.style.transform = 'translateX(100%)';
    
    const backButton = document.createElement('div');
    backButton.className = 'fluent-settings-back';
    
    const backIcon = document.createElement('span');
    backIcon.className = 'fluent-settings-back-icon';
    backIcon.textContent = '❮';
    backButton.appendChild(backIcon);
    
    const backText = document.createElement('span');
    backText.className = 'fluent-settings-back-text';
    backText.textContent = `Retour à ${sections[parentSectionId].title}`;
    backButton.appendChild(backText);
    
    backButton.addEventListener('click', () => {
      submenuElement.style.transform = 'translateX(100%)';
    });
    
    submenuElement.appendChild(backButton);
    
    const headerElement = document.createElement('h3');
    headerElement.className = 'fluent-settings-section-title';
    headerElement.textContent = title || submenuSection.title;
    submenuElement.appendChild(headerElement);
    
    submenuSection.items.forEach(item => {
      const itemElement = renderItem(item, submenuId);
      submenuElement.appendChild(itemElement);
    });
    
    menuElement.container.appendChild(submenuElement);
    
    submenuSection.items.forEach(item => {
      if (item.type === 'submenu') {
        renderSubmenu(item.submenuId, submenuId, item.label);
      }
    });
  }

  function init(customOptions = {}) {
    options = { ...DEFAULT_CONFIG, ...customOptions };
    
    if (menuElement) {
      menuElement.backdrop.remove();
      menuElement.container.remove();
      menuElement = null;
      
      const oldStyles = document.getElementById('fluent-settings-styles');
      if (oldStyles) oldStyles.remove();
      
      createStyles();
    }
    
    return this;
  }
  
  return {
    init,
    open,
    close,
    createSection,
    addToggle,
    addSelect,
    addSubmenu,
    addLanguageSwitcher
  };
})();

setTimeout(() => {
    if (localStorage.getItem('locateonstart') === 'true') {
        locateUser();
    } 
}, 2000);




window.addEventListener('message', function(event) {

    if (event.data.type === 'schedule') {
        showUpdatePopupPourHoraires()
    }

    if (event.data.type === 'news') {
        showUpdatePopup('alerts.html');
    }

    if (event.data.type === 'settings') {
        FluentSettingsMenu.open();
    }

    if (event.data.type === 'mbh') {
        showUpdatePopup('histovec.html');
    }

    if (event.data.type === 'openmap') {
        const accueil = document.getElementById('accueil');
        accueil.classList.add('hide');
        accueil.classList.remove("affiche")
        const menubottom1 = document.getElementById('menubtm');
        menubottom1.style.display = 'flex';
        window.isMenuShowed = false;
    
        setTimeout(() => {
            menubottom1.classList.remove('slide-upb');
            menubottom1.classList.add('slide-downb');
            setTimeout(() => {
                accueil.style.display = 'none';
            }, 500);
        }, 10);

    }
});

function afficherMenu() {
    const accueil = document.getElementById('accueil');
    accueil.classList.remove('hide');
    accueil.classList.add("affiche")
    accueil.style.display = 'block';
    window.isMenuShowed = true;

    const menubottom1 = document.getElementById('menubtm');

    setTimeout(() => {
        menubottom1.classList.add('slide-upb');
        menubottom1.classList.remove('slide-downb');
        setTimeout(() => {
            menubottom1.style.display = 'none';
            accueil.style.display = 'block';
        }, 500);
    }, 10);

    
}

afficherMenu()


let lastTripUpdateTimestamp = 0;
let worker;
let fetchInProgress = false;
const FETCH_INTERVAL = 8000; 

function initWorker() {
    worker = new Worker('worker.js');
    
    worker.onerror = (error) => {
        console.error('Erreur worker', error);
        setTimeout(() => {
            worker.terminate();
            initWorker();
        }, 1000);
    };
}

async function fetchTripUpdates() {
    if (fetchInProgress) return Promise.resolve(null);
    
    fetchInProgress = true;
    const fetchStartTime = performance.now();
    
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // timeout après 5s
        
        const response = await fetch('proxy-cors/proxy_tripupdate.php', {
            signal: controller.signal,
            cache: 'no-store' 
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);
        
        const fetchTime = performance.now() - fetchStartTime;
        
        return new Promise((resolve, reject) => {
            const workerTimeoutId = setTimeout(() => {
                reject(new Error('Worker timeout'));
            }, 3000);
            
            worker.onmessage = (e) => {
                clearTimeout(workerTimeoutId);
                const processTime = performance.now() - fetchStartTime;
                
                tripUpdates = e.data.tripUpdates;
                
                
                resolve(e.data.tripUpdates);
                fetchInProgress = false;
            };
            
            worker.postMessage(data);
        });
    } catch (error) {
        console.error('Erreur récupération trip updates:', error);
        fetchInProgress = false;
        throw error;
    }
}

let lastUpdateTime = 0;
function scheduleFetchUpdates(timestamp) {
    if (!lastUpdateTime || timestamp - lastUpdateTime >= FETCH_INTERVAL) {
        lastUpdateTime = timestamp;
        
        Promise.all([
            fetchTripUpdates().catch(() => null),
            fetchVehiclePositions().catch(() => null)
        ]).catch(error => {
            console.warn('Erreur lors des mises à jour', error);
        });
    }
    
    requestAnimationFrame(scheduleFetchUpdates);
}


async function main() {
    try {
        initWorker();
        
        const gtfsData = await initializeGTFS();
        gtfsInitialized = true;
        
        await loadGeoJsonLines();
        
        await Promise.all([
            fetchTripUpdates().catch(console.error),
            fetchVehiclePositions(),
            hideLoadingScreen()
        ]);
        
        requestAnimationFrame(scheduleFetchUpdates);
        
    } catch (error) {
        console.error("Erreur critique dans main():", error);
        toastBottomRight.error("Une erreur critique est survenue. Nous investigons actuellement sur la cause de la panne.");
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', main);
} else {
    main();
}    
</script>
</html>
