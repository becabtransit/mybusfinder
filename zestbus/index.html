<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="MyBusFinder">
	<link rel="canonical" href="https://mybusfinder.fr">
	<link rel="apple-touch-icon" href="src/logo.png">
    <title>MyBusFinder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protobufjs/6.11.2/protobuf.min.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <meta name="google-adsense-account" content="ca-pub-5815761294049475">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
        <style>
        html, body {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
            font-family: 'League Spartan', sans-serif;
            background-color: #f4f4f4; 
            color: #333; 
            transition: background-color 0.5s ease; 
        }

        @font-face {
            font-family: 'League Spartan';
            src: url('src/fonts/leaguespartan.ttf') format('truetype');
        }

        #map {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
			
			
        .update-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
    overflow-y: hidden;
}

.popup-content {
    background: white;
    width: 100%;
    height: 100%;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    position: relative;
}


.timepopup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    opacity: 95%;
    height: 100%;
    display: none; 
    justify-content: center;
    align-items: center;
    z-index: 10001;
	background-color: rgba(255, 255, 255, 0.5); 
    backdrop-filter: blur(8px); 
    -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper, .leaflet-popup-tip {
  background-color: transparent;
  border-radius: 15px;
  box-shadow: none !important;
  padding: 0px 0px 0px 0px;
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(13px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
  transform-origin: center bottom;
}

.leaflet-popup-content-wrapper.show, .leaflet-popup-tip.show {
  transform: scale(1) translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.leaflet-popup-content-wrapper.hide, .leaflet-popup-tip.hide {
  transform: scale(0.8) translateY(20px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.leaflet-popup-content {
  margin: 0px;
  width: 400px;
}


.leaflet-popup-close-button {
visibility: hidden;
}

.popup-zoom-in {
    transform: scale(1) translateY(0px); 
    opacity: 1;
}

.popup-zoom-out {
    transform: scale(0.9) translateY(20px); 
    opacity: 0;
}

#menubtm {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out, background-color 0.5s ease;
}




@keyframes fadeInPopupSvc {
    from {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

@keyframes fadeOutPopupSvc {
    from {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -20%);
    }
}

@keyframes fadeInPopup {
    from {
        opacity: 0;
        transform: translate(0%, 30%);
    }
    to {
        opacity: 1;
        transform: translate(0%, 0%);
    }
}

@keyframes fadeOutPopup {
    from {
        opacity: 1;
        transform: translate(0%, -30%);
    }
    to {
        opacity: 0;
        transform: translate(0%, 0%);
    }
}

.custom-scrollbar::-webkit-scrollbar {
    height: 8px; 
}
.custom-scrollbar::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: #888;
    border-radius: 10px;
    border: 2px solid #f1f1f1;
}

.custom-scrollbar {
    -webkit-overflow-scrolling: touch;
}

			
.popup-content h2 {
    font-size: 24px;
    font-family: 'League Spartan', sans-serif;
    color: #333;
    margin-bottom: 15px;
}

#update-notes {
    font-family: 'League Spartan', sans-serif;
    font-size: 16px;
    color: #555;
    line-height: 1;
}

#update-notes li {
    margin-bottom: 10px;
}



#menu {
    position: absolute;
    top: 0px;
    right: 0px;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 10px;
    border-radius: 0px 0px 0px 0px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 1);
    z-index: 1000;
    height: -webkit-fill-available; 
    overflow-y: auto;
    transition: all 0.3s ease;
    display: none;
}





        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: scale(0);
            opacity: 0;
            animation: ripple-animation 0.6s linear forwards;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 1;
            }
        }

        ul {
    padding: 0;
    margin: 0;
    list-style-type: none;
    padding-inline-start: 0;
}


        .menu-item {
            cursor: pointer;
            padding: 6px;
            transition: background-color 0.3s ease; 
            border-radius: 5px;
            z-index: 100000;
        }

        .menu-item:hover {
            background-color: #0000001f; 
            animation: jspcommentlappelercettekeyframe 0.1s linear forwards;
        }

        .linesection {
            cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        }

        @keyframes jspcommentlappelercettekeyframe {
            to {
                transform: scale(0.95);
            }
        }

        .popup-content {
            font-family: 'League Spartan', sans-serif;
            font-size: 12px;
            line-height: 1.1;
        }

        .popup-header {
            padding: 5px;
            border-radius: 10px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }





@keyframes textFadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}

.loading-animation {
    font-family: 'League Spartan', sans-serif;
    font-size: 50px;  
    font-weight: bold;
    background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0); 
    -webkit-background-clip: text;
    color: transparent;
    animation: gradientTextAnimation 3s ease infinite; 
}


.share-btn, .donate-btn {
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes slideInBounce {
    0% {
        right: -100%; 
    }
    100% {
        right: 0; 
    }
}

@keyframes slideInBounceInv {
    0% {
        right: 0; 
    }
    100% {
        right: -100%; 
    }
}

#menu {
    animation: slideInBounce 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
}

#menu.hidden {
  animation: slideInBounceInv 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
}

@keyframes bounceIn {
    0% {
        transform: scale(0.9);
        opacity: 0.7;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.popup-content, .popup-content1, .popup1 {
    animation: zoomFadeIn 0.6s cubic-bezier(0.25, 1.5, 0.5, 1) forwards;
}

@keyframes zoomFadeIn {
    0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(13px); 

    }
    100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0); 
    }
}


.marker-icon {
    animation: zoomInOut 2s infinite;
}

@keyframes zoomInOut {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.13); }
}


span[style*="padding: 5px 10px;"] {
    animation: badgePulse 1.5s infinite;
}
@keyframes badgePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

#nextStopsContent div {
    animation: fadeInScroll 0.3s ease-in;
	display: inherit;
}
@keyframes fadeInScroll {
    from { opacity: 0; }
    to { opacity: 1; }
}

.marker-icon:hover {
    animation: hoverBounce 0.3s ease-in-out;
}
@keyframes hoverBounce {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.glass-effect {
    position: relative;
    overflow: hidden;
}

.glass-effect::before {
    content: '';
    position: absolute;
    top: 0;
    left: -140%;
    width: 140%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: skewX(-25deg);
}

.glass-effect.animate::before {
    animation: glass-slide 1s ease forwards;
}

@keyframes glass-slide {
    0% {
        left: -100%;
    }
    100% {
        left: 150%;
    }
}
			
@keyframes gradientTextAnimation {
    0% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
    50% {
        background: linear-gradient(45deg, #ffffff, #f0f0f0, #ffffff);
    }
    100% {
        background: linear-gradient(45deg, #f0f0f0, #ffffff, #f0f0f0);
    }
}

:root {
  --base_scale: 3vh;
  --floor: 15vh;
  --color: #836ee5;
}

body {
  margin: 0;
  overflow: hidden;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none; 
}

input, textarea {
  user-select: text;
}

#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    45deg,
    #000000,
    #1a1a1a,
    #242424
  );
  background-size: 200% 200%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 10000;
  animation: gradientAnimation 5s ease infinite;
}

@keyframes gradientAnimation {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.shapes-container {
  width: 100%;
  overflow: hidden;
}

shape {
  position: absolute;
  display: block;
  left: 50%;
  bottom: 0;
  margin-left: calc(-1 * (var(--base_scale) / 2));
  margin-bottom: var(--floor);
  transform-origin: center;
}

shape.circle {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
  border-radius: 50%;
}

shape.semi-circle {
  width: var(--base_scale);
  height: calc(var(--base_scale) * 2);
  background: var(--color);
  border-bottom-right-radius: calc(var(--base_scale) * 2);
  border-top-right-radius: calc(var(--base_scale) * 2);
}

shape.square {
  width: var(--base_scale);
  height: var(--base_scale);
  background: var(--color);
}

shape.bounce-up {
  animation: bounceUp 600ms cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
}

shape.bounce-down {
  animation: bounceDown 600ms cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards;
}

@keyframes bounceUp {
  0% {
    transform: translateY(0) rotate(0deg);
  }
  100% {
    transform: translateY(-30vh) rotate(180deg);
  }
}

@keyframes bounceDown {
  0% {
    transform: translateY(-30vh) rotate(180deg);
  }
  100% {
    transform: translateY(0) rotate(360deg);
  }
}

#stop-suggestions li {
    padding: 10px;
    cursor: pointer;
    border-bottom: 1px solid #ddd;
}

#stop-suggestions li:hover {
    background-color: #f4f4f4;
}


#loading-text {
  margin-top: 20px;
  font-size: 18px;
  color: black;
  animation: fadeIn 1.5s ease forwards;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.filtre {
    display: none;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%) translateY(-100%);
    opacity: 0; 
    filter: blur(5px); 
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    padding: 10px 15px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.filtre-texte {
    color: #ffffff;
}

.menubottom-ul {
    display: flex;
    position: absolute;
    bottom: 10px;
    left: 50%; 
    transform: translateX(-50%);
    padding: 12px;
    border: none;
    list-style: none;
    margin: 0;
    z-index: 10000;
    padding: 0;
    background-color: #0F056B9c;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5); 
    border-radius: 18px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    
}

.menubottom-ul.expanded {
    width: 100%;
    height: 50vh; /* Ajustable selon tes besoins */
    bottom: 0;
    border-radius: 18px 18px 0 0; /* Coins arrondis en haut seulement */
    padding: 20px;
}

.menubottom ul li {
    margin: 0 8px; 
}

        .menubottom ul li a {
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 20px;
            font-family: League Spartan;
            text-decoration: none;
            height: 70px;
            width: 70px;
            position: relative;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
                }

        .menubottom ul li a .icon {
            position: relative;
            font-size: 20px;
            transition: transform 0.2s ease-in-out;
            transition: .3s;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .menubottom ul li a .title {
    margin-bottom: 8px; 
    font-size: 14px;
    text-align: center;
    opacity: 1; 
    transition: none; 
}

.menubottom ul li a:hover .icon {
    transform: scale(0.8); 
}

        .menubottom ul li a:active {
    transform: scaleX(70%)scaleY(70%); 
    background-color: rgba(255, 255, 255, 0); 
}


@keyframes barFadeIn {
    0% {
        opacity: 0;
        transform: translateY(60px); 
    }
    100% {
        opacity: 1;
        transform: translateY(0); 
    }
}


			
.next-stops-container {
	max-height: 100px;
    padding: 10px;
    background: #f9f9f9;
    border-top: 1px solid #ddd;
    position: relative;
}

.next-stops-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.next-stops-content {
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
    padding-inline-start: 0;
    list-style-type: none; 
    overflow-y: auto;
}

@media (max-width: 1024px) {
  .next-stops-content {
    scrollbar-width: none; 
  }

  .next-stops-content::-webkit-scrollbar {
    display: none;
  }
}

.popup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: fadeInPopup 0.5s forwards;
    background-color: #ffffff; 
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(255, 255, 255, 0.5);
    max-height: 80%;
    width: 90%;
    max-width: 500px;
    z-index: 1001;
    overflow-y: auto;
    opacity: 0; 
        }

        .popup-content {
            text-align: center;
        }

        .close-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #333;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    transition: background-color 0.3s;
}

.close-btn:hover {
    background-color: #555;
}

        .textpop h4 {
    margin-bottom: 0.3rem;
}

.textpop h1 {
    margin-top: 0;
}



.slide-down {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.logoscr {
  transform: translateY(100px); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
}

.popup-slide {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}

.popup-slide-hidden {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(-30%);
    opacity: 0;
}

.popup-slide-right {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(30%);
    opacity: 0;
}

.popup-slide-active {
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
    transform: translateX(0);
    opacity: 1;
}



.schedule-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    padding: 5px;
    background: #f8f9fa;
    border-radius: 8px;
}

.schedule-row span {
    font-weight: bold;
    color: #333;
}


.logoscrapp {
  transform: translateY(0); 
  opacity: 1; 
  filter: blur(0); 
}

.logoscrappp {
  transform: scale(0.8); 
  filter: blur(0); 
}

.logoscrapppp {
  opacity: 0; 
}

@media (max-width: 600px) {
    #logoscr {
      width: 50%;  
      max-width: 200px;  
    }
  }

  @media (min-width: 1200px) {
    #logoscr {
      width: 10%;  
      max-width: 400px;  
    }
  }

.slide-up {
  transform: translateY(-100%); 
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

.slide-downb {
  transform: translateY(0) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upb {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.2s ease-in, filter 0.2s ease-in;
}


.slide-downc {
  transform: translateY(-220%) translateX(-50%);
  opacity: 1; 
  filter: blur(0); 
  backdrop-filter: blur(8px); 
  -webkit-backdrop-filter: blur(8px);
}

.slide-upc {
  transform: translateY(100%) translateX(-50%);
  opacity: 0; 
  filter: blur(5px); 
  transition: transform 0.2s ease-in, opacity 0.2s ease-in, filter 0.2s ease-in;
}

#popup1::-webkit-scrollbar {
        width: 8px;
    }
    #popup1::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 10px;
    }
    #popup1::-webkit-scrollbar-thumb:hover {
        background: #555;
    }


@keyframes loadingBarAnimation {
    0% {
        width: 0%;
    }
    50% {
        width: 100%;
    }
    100% {
        width: 100%;
    }
}


        .marker-icon:hover {
        transform: scale(0.8);
        transition: transform 0.2s ease;
        }

      

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes zoomOut {
            from {
                transform: scale(1);
                opacity: 1;
            }
            to {
                transform: scale(1.5);
                opacity: 0;
            }
        }

@keyframes fadeColors {
    0% { background-color: rgb(0, 0, 0); }
    25% { background-color: rgb(0, 0, 168); }
    50% { background-color: rgb(0, 158, 158); }
    75% { background-color: rgb(155, 155, 0); }
    100% { background-color: rgb(0, 0, 0); }
}

.logobkg {
  transition: opacity 0.3s ease-out;
}
.loading-screen-fade {
    animation: fadeColors 1s ease-in; 
}

#webview-frame {
    width: 100%;
    height: 100%;
}

.vehicle-thumbnail {
    width: 95.5%;
    margin-left: auto;
    border-radius: 5px;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 2px;
}

.vehicle-model {
    display: flex;
    align-items: right;
    justify-content: flex-end;
    flex-direction: column;
}

.stops-timeline-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.95);
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 400px;
    z-index: 1000;
    overflow: hidden;
    max-height: 80vh;
    display: none;
    opacity: 0;
    filter: blur(5px);
    transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1),
                opacity 0.3s ease-out,
                filter 0.3s ease-out;
}

.stops-timeline-menu.visible {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
    filter: blur(0);
}

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

.overlay.visible {
    opacity: 1;
}

.show-in-map-btn {
    margin: 20px;
    padding: 12px;
    background: #363636;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    width: calc(100% - 40px);
    position: sticky;
    bottom: 0;
    transition: transform 0.3s ease, background-color 0.3s ease;
}

.show-in-map-btn:hover {
    background: #2c2c2c;
    transform: scale(0.98);
}

.show-in-map-btn:active {
    transform: scale(0.95);
}

.leaflet-control-locate a {
  cursor: pointer;
}
.leaflet-control-locate a .leaflet-control-locate-location-arrow {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate a .leaflet-control-locate-spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin: 7px;
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="black" d="M304 48a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48 368a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm208-208a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM96 256a48 48 0 1 0-96 0 48 48 0 0 0 96 0zm13 99a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm294 0a48 48 0 1 0 0 96 48 48 0 0 0 0-96zM109 61a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"/></svg>');
  animation: leaflet-control-locate-spin 2s linear infinite;
}
.leaflet-control-locate.active a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(32, 116, 182)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}
.leaflet-control-locate.following a .leaflet-control-locate-location-arrow {
  background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgb(252, 132, 40)" d="M445 4 29 195c-48 23-32 93 19 93h176v176c0 51 70 67 93 19L508 67c16-38-25-79-63-63z"/></svg>');
}

.leaflet-touch .leaflet-bar .leaflet-locate-text-active {
  width: 100%;
  max-width: 200px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  padding: 0 10px;
}
.leaflet-touch .leaflet-bar .leaflet-locate-text-active .leaflet-locate-icon {
  padding: 0 5px 0 0;
}

.leaflet-control-locate-location circle {
  animation: leaflet-control-locate-throb 4s ease infinite;
}

@keyframes leaflet-control-locate-throb {
  0% {
    stroke-width: 1;
  }
  50% {
    stroke-width: 3;
    transform: scale(0.8, 0.8);
  }
  100% {
    stroke-width: 1;
  }
}
@keyframes leaflet-control-locate-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.alerts-button {
    display: flex;
    align-items: center;
    background-color: #000000;
    color: #ffffff;
    padding: 15px 18px;
    margin-bottom: 8px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), 
                box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1),
                background-color 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
    position: relative;
    overflow: hidden;
    animation: fadeInUp 0.3s ease-out forwards;
}

.alerts-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
    transform: skewX(-25deg);
    transition: left 0.8s cubic-bezier(0.25, 1.5, 0.5, 1);
    z-index: 1;
    pointer-events: none;
}

.alerts-button:hover::before {
    left: 120%;
}

.alerts-button:hover {
    transform: scale(0.98);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    background-color: #222222;
}

.alerts-button:active {
    transform: scale(0.95);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    background-color: #333333;
    transition: all 0.1s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.alerts-button:active .alerts-icon {
    transform: scale(1.2) rotate(5deg);
    transition: transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
}

.alerts-icon {
    margin-right: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 2;
    transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
}


.alerts-button:hover .alerts-icon {
    transform: scale(1.2);
}

.alerts-content {
    z-index: 2;
}

.alerts-title {
    font-weight: normal;
    font-size: 20px;
}

.alerts-description {
    font-size: 14px;
    opacity: 0.8;
}

@media (max-width: 1024px) {
  .options {
    scrollbar-width: none; 
  }

  .options::-webkit-scrollbar {
    display: none;
  }
}

.bus-stop-marker {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: white;
    border: 1px solid black;
}

.line-popup, .stop-popup {
    padding: 5px;
}

.line-popup h4, .stop-popup h4 {
    margin: 0 0 5px 0;
    font-weight: bold;
}

#bottomsheetappearcss {
    display: none; 
}

@media screen and (min-width: 1024px) {
    #bottomsheetappearcss {
        display: flex;
    }
}

#map-container { 
            position: relative; 
            height: 100vh; 
            width: 100%; 
        }
        #map { 
            height: 100%; 
            width: 100%; 
        }
        #sun-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.5s ease-in-out; 
        }
        .sun-line {
            position: absolute;
            stroke-width: 2;
            fill: none;
        }
        .hour-circle {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            opacity: 0.9;
            color: white;
            text-shadow: 1px 1px 2px black;
            transform: translate(-50%, -50%);
        }
        #toggle-sun-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        .first-visit-tooltip {
    position: absolute;
    bottom: 80px;
    left: 50%;
    width: auto;
    transform: translateX(-50%);
    background-color: rgba(15, 5, 107, 0.384);
    color: white;
    padding: 10px 15px;
    border-radius: 15px;
    z-index: 10001;
    display: flex;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.first-visit-tooltip.show {
    opacity: 1;
    visibility: visible;
}

.first-visit-tooltip .tooltip-content {
    display: flex;
    align-items: center;
    gap: 8px;
}

.first-visit-tooltip svg {
    stroke: white;
    animation: bounce 1s infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

.logo-bottom {
  display: block;
  margin: 0 auto;
  max-width: 50%;
  height: auto;
  position: absolute;
  bottom: 50px; 
  left: 50%;
  transform: translateX(-50%);
}

.logo-bottom.logoscr {
  transform: translateX(-50%) translateY(100px);
  opacity: 0;
  filter: blur(5px);
  transition: transform 0.5s cubic-bezier(0.25, 1.5, 0.5, 1), opacity 0.3s ease-out, filter 0.3s ease-out;
}

.logo-bottom.logoscrapp {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
  filter: blur(0);
}

@media (max-width: 600px) {
  .logo-bottom {
    width: 50%;
    max-width: 200px;
  }
}

@media (min-width: 1200px) {
  .logo-bottom {
    width: 10%;
    max-width: 400px;
  }
}

@keyframes rainbowShadow {
  0% { filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7)); }  
  16.6% { filter: drop-shadow(0 0 10px rgba(255, 165, 0, 0.7)); }  
  33.3% { filter: drop-shadow(0 0 10px rgba(255, 255, 0, 0.7)); }  
  50% { filter: drop-shadow(0 0 10px rgba(0, 255, 0, 0.7)); }  
  66.6% { filter: drop-shadow(0 0 10px rgba(0, 0, 255, 0.7)); } 
  83.3% { filter: drop-shadow(0 0 10px rgba(128, 0, 128, 0.7)); } 
  100% { filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.7)); }  
}

.rainbow-shadow {
  animation: rainbowShadow 3s infinite linear;
}

    </style>

</head>
<body>
<!--          _   __                         ________                                                                          -->
<!--         //   ) )                __     /__  ___/                                                                          -->
<!--        ((                  ___ / /       / /   __      ___       __      ___      ___      ___      __    __  ___  ___    -->
<!--          \\     //   / / //   ) /       / /  //  ) ) //   ) ) //   ) ) ((   ) ) //   ) ) //   ) ) //  ) )  / /   ((   ) ) -->
<!--            ) ) //   / / //   / /       / /  //      //   / / //   / /   \ \    //___/ / //   / / //       / /     \ \     -->
<!--     ((___ / / ((___( ( ((___/ /       / /  //      ((___( ( //   / / //   ) ) //       ((___/ / //       / /   //   ) )   -->
<!--                                                          Code ayant pour entière propriété Sud Transports/Bechir Abidi    -->
<!--                                                                Réutilisation non autorisée sauf en cas de dérogation !    -->

<div class="filtre" id="filtre">
    <span data-i18n="filtersreset" class="filtre-texte">Réinitialiser les filtres</span>
</div>

<div id="first-visit-tooltip" class="first-visit-tooltip">
    <div class="tooltip-content">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="up-arrow">
            <path d="M12 5l-7 7h14l-7-7z" fill="white"/>
        </svg>
        <span data-i18n="slideuptosettings">Glissez vers le haut pour les paramètres</span>
    </div>
</div>
 <div class="menubottom">
        <ul id="menubtm" class="menubottom-ul">
            <li>
                <a href="https://mybusfinder.fr/"><span class="icon"><img src="src/menu.png" style="width: 40px; height: 40px;"></img></span> <span
                    class="title" data-i18n="menu">Menu</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('schedule.html');" id="clock"><span class="icon"><img src="src/horloge.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="schedule">Horaires</span></a>
            </li>
            <li>
                <a id="menubutton"><span class="icon"><img src="src/bus.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="network">Réseau</span></a>
            </li>
            <li>
                <a onclick="showUpdatePopup('alerts.html');" id="histovecbutton"><span class="icon"><img src="src/newspaper.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="news">Actualités</span></a>
            </li>
            <li id="bottomsheetappearcss">
                <a id="bottomsheetappear"><span class="icon"><img src="src/sandwichbtn.png" style="width: 40px; height: 40px;"></img></span> <span
                        class="title" data-i18n="seemore">Voir plus</span></a>
            </li>
        </ul>
</div>

	



	<amp-auto-ads type="adsense"
        data-ad-client="ca-pub-5815761294049475">
</amp-auto-ads>


    <div id="map"></div>
    <svg id="sun-overlay" xmlns="http://www.w3.org/2000/svg"></svg>



    <div id="menu"></div>
    <div id="update-popup" class="update-popup">
        <div class="popup-content">
            <button id="close-popup" class="close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            <iframe id="webview-frame" src="" frameborder="0"></iframe>
        </div>
    </div>
                


	
	
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


	
<div id="loading-screen" class="logobkg">
    <img id="logoscr" class="logoscr rainbow-shadow" src="src/whitelogo.png" style="display: block; margin: 0 auto; max-width: 50%; height: auto;"/>
    <img id="bottom-logo" class="logoscr logo-bottom" src="src/credits.png" />
</div>
  

 <script src="src/js/toastjs.js"></script>       
 <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5815761294049475"
     crossorigin="anonymous"></script>
 <script src="../js/tarteaucitron/tarteaucitron.min.js"></script>
 <script>
 /* tarteaucitron */
tarteaucitron.init({
          "bodyPosition": "middle",

    	  "hashtag": "#cookies", /* Hashtag qui permet d'ouvrir le panneau de contrôle  */
    	  "cookieName": "tarteaucitron", /* Nom du cookie (uniquement lettres et chiffres) */
    
    	  "orientation": "middle", /* Position de la bannière (top - bottom - popup - banner) */
       
          "groupServices": true, /* Grouper les services par catégorie */
          "showDetailsOnClick": true, /* Cliquer pour ouvrir la description */
          "serviceDefaultState": "wait", /* Statut par défaut (true - wait - false) */
                           
    	  "showAlertSmall": false, /* Afficher la petite bannière en bas à droite */
    	  "cookieslist": false, /* Afficher la liste des cookies */
                           
          "closePopup": true, /* Afficher un X pour fermer la bannière */

          "showIcon": false, /* Afficher un cookie pour ouvrir le panneau */
          //"iconSrc": "src/whitelogo.png", /* Optionnel: URL ou image en base64 */
          "iconPosition": "BottomRight", /* Position de l'icons: (BottomRight - BottomLeft - TopRight - TopLeft) */

    	  "adblocker": true, /* Afficher un message si un Adblocker est détecté */
                           
          "DenyAllCta" : true, /* Afficher le bouton Tout refuser */
          "AcceptAllCta" : true, /* Afficher le bouton Tout accepter */
          "highPrivacy": true, /* Attendre le consentement */
          "alwaysNeedConsent": false, /* Demander le consentement même pour les services "Privacy by design" */
                           
    	  "handleBrowserDNTRequest": false, /* Refuser tout par défaut si Do Not Track est activé sur le navigateur */

    	  "removeCredit": true, /* Retirer le lien de crédit vers tarteaucitron.io */
    	  "moreInfoLink": true, /* Afficher le lien En savoir plus */

          "useExternalCss": false, /* Mode expert : désactiver le chargement des fichiers .css tarteaucitron */
          "useExternalJs": false, /* Mode expert : désactiver le chargement des fichiers .js tarteaucitron */

    	  //"cookieDomain": ".my-multisite-domaine.fr", /* Optionnel: domaine principal pour partager le consentement avec des sous domaines */
                          
          "mandatory": true, /* Afficher un message pour l'utilisation de cookies obligatoires */
    
          
          "googleConsentMode": true, /* Activer le Google Consent Mode v2 pour Google ads & GA4 */

          "partnersList": true /* Afficher le détail du nombre de partenaires sur la bandeau */
        });
    </script>

    <script>
        (tarteaucitron.job = tarteaucitron.job || []).push('gcmadstorage');
    </script>

<script>
    const i18n = {
    translations: {},
    currentLang: 'fr',
    supportedLanguages: ['fr', 'it', 'ar', 'en'],
    defaultLang: 'fr',
    
    getBrowserLanguage() {
        const fullLang = navigator.language || navigator.userLanguage;
        const primaryLang = fullLang.split('-')[0];
        
        if (this.supportedLanguages.includes(primaryLang)) {
        return primaryLang;
        }
        
        return this.defaultLang;
    },
    
    getLanguageFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const lang = urlParams.get('lang');
        return lang || localStorage.getItem('preferredLanguage') || this.defaultLang;
    },
    
    async loadTranslations() {
        this.currentLang = this.getLanguageFromUrl();
        localStorage.setItem('preferredLanguage', this.currentLang);
        
        try {
        const response = await fetch(`../locales/${this.currentLang}.json`);
        this.translations = await response.json();
        document.dispatchEvent(new CustomEvent('translationsLoaded'));
        return this.translations;
        } catch (error) {
        console.error("Erreur lors du chargement des traductions:", error);
        return {};
        }
    },
    
    t(key, params = {}) {
        let text = this.translations[key] || key;
        
        Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
        });
        
        return text;
    },
    
    applyTranslations() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (this.translations[key]) {
            element.innerHTML = this.translations[key];
        }
        });
    },
    
    addLangToUrl() {
        const browserLang = this.getBrowserLanguage();
        
        if (browserLang !== this.defaultLang) {
        const currentUrl = new URL(window.location.href);
        if (!currentUrl.searchParams.has('lang')) {
            currentUrl.searchParams.set('lang', browserLang);
            window.history.replaceState({}, '', currentUrl.toString());
        }
        }
        
        return browserLang;
    },
    
    init() {
        const detectedLang = this.addLangToUrl();
        const urlLang = new URLSearchParams(window.location.search).get('lang');
        
        if (!localStorage.getItem('preferredLanguage')) {
        localStorage.setItem('preferredLanguage', urlLang || detectedLang);
        }
        
        return this.loadTranslations();
    }
    };

    window.t = (key, params) => i18n.t(key, params);

    function waitForTranslations() {
    return new Promise(resolve => {
        if (Object.keys(i18n.translations).length > 0) {
        resolve();
        } else {
        document.addEventListener('translationsLoaded', () => resolve(), { once: true });
        }
    });
    }

    document.addEventListener('DOMContentLoaded', () => {
    i18n.init().then(() => {
        i18n.applyTranslations();
    });
    });

    window.i18n = i18n;
    </script>


<script>


document.addEventListener('DOMContentLoaded', function() {
    const menuItems = document.querySelectorAll('.menubottom-ul li a');
    
    menuItems.forEach(item => {
        item.addEventListener('touchstart', function() {
            safeVibrate(50);
        });
        
        item.addEventListener('touchend', function() {
            safeVibrate(50);
        });
    });
});


if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        
        let refreshing = false;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            toastBottomRight.info('Préparation en cours.')

          if (!refreshing) {
            refreshing = true;
            window.location.reload();
          }
        });
        
        registration.update();
      })
      .catch(error => {
        console.error('Erreur lors de l\'enregistrement du service Worker:', error);
      });
  });
}

document.addEventListener('DOMContentLoaded', function() {
    const tooltip = document.getElementById('first-visit-tooltip');
    
    let navigationCount = parseInt(localStorage.getItem('navigationCount') || '0');
    
    function showTooltip() {
        tooltip.classList.add('show');
        
        const tooltipTimeout = setTimeout(() => {
            tooltip.classList.remove('show');
        }, 10000);
        
        const hideTooltip = () => {
            tooltip.classList.remove('show');
            document.removeEventListener('click', clickHandler);
        };
        
        const clickHandler = (event) => {
            if (!tooltip.contains(event.target)) {
                clearTimeout(tooltipTimeout);
                hideTooltip();
            }
        };
        
        document.addEventListener('click', clickHandler);
    }
    
    function checkNavigationAndShowTooltip() {
        navigationCount++;
        localStorage.setItem('navigationCount', navigationCount.toString());
        
        if (navigationCount === 2) {
            setTimeout(showTooltip, 3000);
        }
    }
    
    const originalHideLoadingScreen = window.hideLoadingScreen;
    window.hideLoadingScreen = function() {
        if (originalHideLoadingScreen) {
            originalHideLoadingScreen.apply(this, arguments);
        }
        checkNavigationAndShowTooltip();
    };
});

async function getSetvar() {
    try {
        const response5 = await fetch('setvar/settings/theme/maincolor.txt');
        const setvar5 = await response5.text();  
        const colorbkg = setvar5.trim();

        const response = await fetch('setvar/settings/map/defaultzoom.txt');
        const setvar = await response.text();
        const view = setvar.trim();  

        const response1 = await fetch('setvar/settings/networkname.txt');
        const setvar1 = await response1.text();
        const nomdureseau = setvar1.trim();  

        return { colorbkg, view, nomdureseau };

    } catch (error) {
        console.error('Erreur chargement setvar ! ', error);
    }
}

getSetvar();



const vehicleModels = {};

const vehicleTypes = {
    'elec': new Set(),
    'hybrid': new Set(),
    'gnv': new Set(),
    'usb': new Set(),
    'clim': new Set()
};

let map;

async function setColors() {
    const data = await getSetvar();
    if (data) {
        document.getElementById("menubtm").style.backgroundColor = `${data.colorbkg}9c`;
        document.getElementById("menu").style.backgroundColor = `${data.colorbkg}9c`;
        document.getElementById("filtre").style.backgroundColor = `${data.colorbkg}9c`;

    }
}
setColors();

setTimeout(() => {
    const logoscr = document.getElementById('logoscr');
    logoscr.classList.add('logoscrapp');
    document.getElementById("bottom-logo").classList.add("logoscrapp");
}, 10); 

async function initMap() {
    const data = await getSetvar();
    let defaultCoords = [43.125463, 5.930077];
    let defaultZoom = 13;
    
    if (data && data.view) {
        try {
            const viewConfig = data.view.match(/\[(.*?)\],\s*(\d+)/);
            if (viewConfig && viewConfig.length >= 3) {
                const coords = viewConfig[1].split(',').map(coord => parseFloat(coord.trim()));
                defaultCoords = [coords[0], coords[1]];
                defaultZoom = parseInt(viewConfig[2]);
            }
        } catch (error) {
            console.error('Erreur parsing des coord gps', error);
        }
    }
    
    const mapInstance = L.map('map', {
        zoomControl: false 
    }).setView(defaultCoords, defaultZoom);
    
    L.popup({
        closeButton: false
    });

    mapInstance.on('moveend', function() {
        if (isSunOrientationVisible) {
            updateSunOrientation();
        }
    });
    
    mapInstance.on('popupopen', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-out', 'popup-zoom-in');
        setTimeout(() => {
            popupWrapper.classList.add('popup-zoom-in');
        }, 10); 
    });
    
    mapInstance.on('popupclose', function (e) {
        const popupWrapper = e.popup._wrapper; 
        popupWrapper.classList.remove('popup-zoom-in');
        popupWrapper.classList.add('popup-zoom-out');
        popupWrapper.addEventListener(
            'transitionend',
            () => {
                popupWrapper.classList.remove('popup-zoom-out');
            },
            { once: true }
        );
    });

    
   const getSunTimes = (latitude, longitude) => {
        const currentDate = new Date();
        const sunTimes = SunCalc.getTimes(currentDate, latitude, longitude);
        return {
            sunrise: sunTimes.sunrise,
            sunset: sunTimes.sunset
        };
    };

    const { sunrise, sunset } = getSunTimes(defaultCoords[0], defaultCoords[1]);
    const currentTime = new Date();
    
    const isNightMode = currentTime >= sunset || currentTime <= sunrise;

    const isStandardView = localStorage.getItem('isStandardView') === 'true';
    
    if (!isStandardView) {
    const tileLayerUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
    
    const tileLayer = L.tileLayer(tileLayerUrl, {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(mapInstance);
    
    if (isNightMode) {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        const mapPane = mapInstance.getPanes().tilePane;
        mapPane.style.filter = 'none';
    }
} else {
    const mapPane = mapInstance.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(mapInstance);
}




mapInstance.attributionControl.setPrefix('');

    mapInstance.on('locationfound', onLocationFound);
    mapInstance.on('locationerror', onLocationError);

    return mapInstance;
}

function onLocationFound(e) {
    const radius = e.accuracy / 2;

    if (window.locationMarker) {
        map.removeLayer(window.locationMarker);
    }
    if (window.locationCircle) {
        map.removeLayer(window.locationCircle);
    }

    window.locationCircle = L.circle(e.latlng, {
        radius: radius,
        color: '#136AEC',
        fillColor: '#136AEC',
        fillOpacity: 0.15,
        weight: 2
    }).addTo(map);

    map.setView(e.latlng, 16);
}

function onLocationError(e) {
    toastBottomRight.warning("Vous avez refusé la localisation.");
}

function locateUser() {
    if (!map) return;
    
    if ("geolocation" in navigator) {
        const locationOptions = {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
        };

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;

                map.fireEvent('locationfound', {
                    latlng: L.latLng(lat, lng),
                    accuracy: accuracy,
                    timestamp: position.timestamp
                });
            },
            (error) => {
                map.fireEvent('locationerror', {
                    code: error.code,
                    message: error.message
                });
            },
            locationOptions
        );
    } else {
        toastBottomRight.error("La géolocalisation n'est pas supportée par votre navigateur");
    }
}

(async function() {
    map = await initMap();
})();

const sunOverlay = document.getElementById('sun-overlay');
    let isSunOrientationVisible = false; 

    function updateSunOrientation(date = new Date()) {
        sunOverlay.innerHTML = '';

        const center = map.getCenter();
        const centerLat = center.lat;
        const centerLon = center.lng;

        const sunTimes = SunCalc.getTimes(date, centerLat, centerLon);
        const sunrise = sunTimes.sunrise;
        const sunset = sunTimes.sunset;

        const mapSize = map.getSize();
        const centerPoint = {
            x: mapSize.x / 2,
            y: mapSize.y / 2
        };

        const currentTime = new Date(sunrise);
        const radius = Math.min(mapSize.x, mapSize.y) * 0.4; 

        while (currentTime <= sunset) {
            const sunPosition = SunCalc.getPosition(currentTime, centerLat, centerLon);
            
            const azimuthDegrees = sunPosition.azimuth * (180 / Math.PI);
            const angleRad = (azimuthDegrees + 90) * (Math.PI / 180); 

            const endX = centerPoint.x + radius * Math.cos(angleRad);
            const endY = centerPoint.y + radius * Math.sin(angleRad);

            const hourColor = getColorForTime();

            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', centerPoint.x);
            line.setAttribute('y1', centerPoint.y);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', hourColor);
            line.setAttribute('stroke-width', '2');
            line.classList.add('sun-line');
            sunOverlay.appendChild(line);

            const hourCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            hourCircle.setAttribute('cx', endX);
            hourCircle.setAttribute('cy', endY);
            hourCircle.setAttribute('r', '25');
            hourCircle.setAttribute('fill', hourColor);

            const hourText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            hourText.setAttribute('x', endX);
            hourText.setAttribute('y', endY);
            hourText.setAttribute('text-anchor', 'middle');
            hourText.setAttribute('dy', '.3em');
            hourText.setAttribute('fill', 'white');
            hourText.setAttribute('font-size', '18');
            hourText.textContent = currentTime.getHours();

            sunOverlay.appendChild(hourCircle);
            sunOverlay.appendChild(hourText);

            currentTime.setHours(currentTime.getHours() + 1);
        }

        const now = new Date();
        if (now >= sunrise && now <= sunset) {
            const nowSunPosition = SunCalc.getPosition(now, centerLat, centerLon);
            const nowAzimuthDegrees = nowSunPosition.azimuth * (180 / Math.PI);
            const nowAngleRad = (nowAzimuthDegrees + 90) * (Math.PI / 180); 

            const nowEndX = centerPoint.x + radius * Math.cos(nowAngleRad);
            const nowEndY = centerPoint.y + radius * Math.sin(nowAngleRad);

            const nowLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            nowLine.setAttribute('x1', centerPoint.x);
            nowLine.setAttribute('y1', centerPoint.y);
            nowLine.setAttribute('x2', nowEndX);
            nowLine.setAttribute('y2', nowEndY);
            nowLine.setAttribute('stroke', 'black');
            nowLine.setAttribute('stroke-width', '4');
            sunOverlay.appendChild(nowLine);
        }
    }

    function getColorForTime() {
        return 'black'; 
    }

    function toggleSunOrientation() {
        isSunOrientationVisible = !isSunOrientationVisible;
        
        if (isSunOrientationVisible) {
            sunOverlay.style.opacity = 1; 
            updateSunOrientation();
            window.nearbyVehiclesControl.show();
            window.nearbyVehiclesControl.collapse();

        } else {
            sunOverlay.style.opacity = 0; 
            setTimeout(() => sunOverlay.innerHTML = '', 500); 
            window.nearbyVehiclesControl.hide();
        }
    }





        const markers = {};
        let lineColors = {};
        let lineName = {};
        let stopIds = [];
        let stopNameMap = {}
        let selectedLine = null;
        let geoJsonLines = []; 
        let tripUpdates = {};
        let loadingInterval;


function showLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    loadingScreen.style.display = 'flex';
    loadingInterval = setInterval(() => {}, 100);
}
		


var audio = new Audio("src/sounds/musique.mp3"); 

function showUpdatePopup(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = link; 
    popup.style.display = 'flex'; 
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const menubotom = document.getElementById('menubottom');

    menubottom1.classList.remove('slide-downb');
    menubottom1.classList.add('slide-upb');
        if (selectedLine) {
            const filtre = document.getElementById('filtre');
            filtre.classList.add('slide-upc');
            filtre.classList.remove('slide-downc');
            filtre.addEventListener('animationend', () => {
                filtre.style.display = 'none';
        });
    resetMapView();            
}

menubottom1.addEventListener('transitionend', () => {
    if (menubottom1.classList.contains('slide-up')) {
        menubottom1.style.display = 'none';
        }
    }, { once: true });
}


function showUpdatePopupmusic(link) {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = link; 
    popup.style.display = 'flex'; 
    musique();
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    const menubotom = document.getElementById('menubottom');

    menubottom1.classList.remove('slide-downb');
    menubottom1.classList.add('slide-upb');
        if (selectedLine) {
            const filtre = document.getElementById('filtre');
            filtre.classList.add('slide-upc');
            filtre.classList.remove('slide-downc');
            filtre.addEventListener('animationend', () => {
                filtre.style.display = 'none';
        });
    resetMapView();            
}

menubottom1.addEventListener('transitionend', () => {
    if (menubottom1.classList.contains('slide-up')) {
        menubottom1.style.display = 'none';
        }
    }, { once: true });
}

window.addEventListener('message', function(event) {
    if (event.data && event.data.action === 'showUpdatePopup') {
        if (window.parent && typeof window.parent.showUpdatePopup === 'function') {
            window.parent.showUpdatePopup(event.data.url);
        }
    }
}, false);



function focusOnVehicle(vehicleId) {
    try {        
        closeUpdatePopup();
        
        const marker = Object.values(markers).find(m => m.id === vehicleId);
        
        if (!marker) {
            toastBottomRight.error('La position du véhicule est indisponible');
            return;
        }
        
        
        try {
            map.setView(marker.getLatLng(), 17);
            marker.openPopup();
            
            const markerIcon = marker._icon.querySelector('.marker-icon');
            if (!markerIcon) {
                toastBottomRight.error('La position du véhicule est indisponible');

                return;
            }
            
            markerIcon.style.transform = 'scale(1.3)';
            setTimeout(() => {
                markerIcon.style.transform = 'scale(1)';
            }, 500);
            
        } catch (mapError) {
            toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : manipulating marker error');
        }
    } catch (error) {
        toastBottomRight.error('Une erreur interne est survenue ! Prière contacter le support MyBusFinder en leur indiquant ce code d\'erreur : focusOnVehicle function error');
    }
}

window.addEventListener('message', function(event) {
    try {        
        if (event.data && event.data.type === 'vehicleSelected') {
            const vehicleId = event.data.vehicleId;
            focusOnVehicle(vehicleId);
        }
    } catch (error) {
        console.error('Error ', error);
    }
});

function closeUpdatePopup() {
    const popup = document.getElementById('update-popup');
    const iframe = document.getElementById('webview-frame');
    iframe.src = ""; 
    popup.style.display = 'none'; 
    
    const menubottom1 = document.getElementById('menubtm');
    const menu = document.getElementById('menu');
    menu.classList.add('hidden');
    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
    if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
        menu.style.display = 'none';
    }
    });
    isMenuVisible = false; 
    menubottom1.style.display = 'flex';
    
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);
    
    if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
    }
}


function musique() {
    if (audio.paused) {
        audio.play();
    }
}


document.getElementById('close-popup').addEventListener('click', closeUpdatePopup);




function hideLoadingScreen() {
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading-screen');


        setTimeout(() => {
            const logoscr = document.getElementById('logoscr');
            logoscr.classList.add('logoscrappp');
            loadingScreen.classList.add('logoscrapppp');


            setTimeout(() => {
                loadingScreen.style.display = 'none';
                if(!localStorage.getItem('premierLancement')) {
                    showUpdatePopup('https://mybusfinder.fr/updatecm/updatecm.html');
                    localStorage.setItem('premierLancement', 'true');
                } 
            }, 300);
        }, 900);
    }, 100);
}


document.addEventListener('DOMContentLoaded', initializeApp);
const doc = document;
showLoadingScreen();


let data;

let DB_NAME;
let STORE_NAME;
const DB_VERSION = 4;

async function initConstants() {
    try {
        const { nomdureseau } = await getSetvar();
        DB_NAME = `MyBusFinder${nomdureseau}`;
        STORE_NAME = `gtfsStore${nomdureseau}`;
        return { DB_NAME, STORE_NAME };
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des constantes', error);
        DB_NAME = 'MyBusFinderDefault';
        STORE_NAME = 'gtfsStoreDefault';
        return { DB_NAME, STORE_NAME };
    }
}

async function initDB() {
    if (!DB_NAME || !STORE_NAME) {
        await initConstants();
    }
    
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function calculateSHA256(data) {
    let buffer;
    if (data instanceof ArrayBuffer) {
        buffer = data;
    } else if (typeof data === 'string') {
        const encoder = new TextEncoder();
        buffer = encoder.encode(data).buffer;
    } else if (data instanceof Blob) {
        buffer = await data.arrayBuffer();
    } else {
        const jsonString = JSON.stringify(data);
        const encoder = new TextEncoder();
        buffer = encoder.encode(jsonString).buffer;
    }

    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return hashHex;
}

async function getFileHash() {
    try {
        const response = await fetch('proxy-cors/proxy_gtfs.php', {
            method: 'GET',
            headers: {
                'X-Content-Only-Header': 'true'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Échec de la vérif ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const partialData = buffer.slice(0, Math.min(buffer.byteLength, 1024 * 50));
        
        const fileHash = await calculateSHA256(partialData);
        
        return { fileHash, needsFullDownload: true };
    } catch (error) {
        console.error('Erreur lors de la vérif du hash', error);
        return { needsFullDownload: true };
    }
}

async function checkGTFSUpdate() {
    try {
        const db = await initDB();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        
        const storedMetadata = await new Promise((resolve, reject) => {
            const request = store.get('gtfsMetadata');
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        if (!storedMetadata || !storedMetadata.fileHash) {
            return { needsUpdate: true };
        }
        
        const { fileHash, needsFullDownload } = await getFileHash();
        
        if (fileHash !== storedMetadata.fileHash) {
            return { needsUpdate: true, fileHash };
        }
        
        return { needsUpdate: false, metadata: storedMetadata };
    } catch (error) {
        console.error('Erreur vérif maj GTFS', error);
        return { needsUpdate: true };
    }
}

async function saveToCache(data, metadata) {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            store.put(data, 'gtfsData');
            
            if (!metadata) {
                metadata = {};
            }
            metadata.lastUpdate = new Date().toISOString();
            store.put(metadata, 'gtfsMetadata');

            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('Erreur sauvegarde dans le cache', error);
        throw error;
    }
}

async function getFromCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('gtfsData');

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de la récup cache', error);
        return null;
    }
}

async function extractGTFSFiles() {
    try {
        toastBottomRight.info('Mise à jour de la base de données dynamiques. Cette opération va prendre quelques secondes 🙂');


        const response = await fetch('proxy-cors/proxy_gtfs.php');
        if (!response.ok) {
            throw new Error(`Échec téléchargement ${response.status} ${response.statusText}`);
            toastBottomRight.warning('Oups ! Une erreur s\'est produite... avez vous actualisé la page ?');

        }
        
        const zipData = await response.arrayBuffer();
        
        const fileHash = await calculateSHA256(zipData.slice(0, Math.min(zipData.byteLength, 1024 * 50)));
        
        const zip = await JSZip.loadAsync(zipData);
        
        const extractedFiles = {};
        
        const filePromises = [];
        zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir) {
                const promise = zipEntry.async("string").then(content => {
                    extractedFiles[relativePath] = content;
                });
                filePromises.push(promise);
            }
        });
        
        await Promise.all(filePromises);
        
        const metadata = {
            fileHash,
            lastUpdate: new Date().toISOString()
        };
        
        return { extractedFiles, metadata };
    } catch (error) {
        throw error;
    }
}

async function loadLineColors(routesFileContent) {
    try {
        if (!routesFileContent) {
            return;
        }
        
        const data = await getSetvar();
        if (!data) {
            console.error('Échec récupération variables de config');
            return;
        }
        
        const lines = routesFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const routeIdIndex = headers.indexOf('route_id');
        const routeLongNameIndex = headers.indexOf('route_short_name');
        const routeColorIndex = headers.indexOf('route_color');
        
        if (routeIdIndex === -1 || routeLongNameIndex === -1 || routeColorIndex === -1) {
            console.error('Impossible de trouver tous les entêttes requis dans fichier routes.txt');
            return;
        }
        
        const startIndex = data.slicelinecolor ? parseInt(data.slicelinecolor) : 1;
        
        lines.slice(startIndex).forEach(line => {
            if (!line.trim()) return;
            
            const columns = line.split(',');
            
            if (columns.length <= Math.max(routeIdIndex, routeLongNameIndex, routeColorIndex)) {
                return;
            }
            
            const routeId = columns[routeIdIndex];
            const routeLongName = columns[routeLongNameIndex];
            let routeColor = columns[routeColorIndex];
            if (routeColor && !routeColor.startsWith('#') && routeColor.trim() !== '') {
                routeColor = `#${routeColor}`;
            }
            
            let cleanedLineName = routeLongName ? routeLongName.replace(/\"/g, '').trim() : '';
            if (routeId) {
                lineColors[routeId] = routeColor;
                lineName[routeId] = cleanedLineName;
            }
        });
        
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadStopIds(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        
        if (stopIdIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    if (stopId) {
                        stopIds.push(stopId);
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function loadLineTerminusData(stopsFileContent) {
    try {
        if (!stopsFileContent) {
            return;
        }
        
        const lines = stopsFileContent.split('\n');
        const headers = lines[0].split(',');
        const stopIdIndex = headers.indexOf('stop_id');
        const stopNameIndex = headers.indexOf('stop_name');
        
        if (stopIdIndex !== -1 && stopNameIndex !== -1) {
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const columns = line.split(',');
                    const stopId = columns[stopIdIndex];
                    let stopName = columns[stopNameIndex];
                    
                    stopName = stopName.replace(/\"/g, '');
                    
                    if (stopId && stopName) {
                        stopNameMap[stopId] = stopName;
                    }
                }
            });
        }
    } catch (error) {
        console.error('Erreur', error);
    }
}

async function initializeGTFS() {
    try {
        Object.keys(lineColors).forEach(key => delete lineColors[key]);
        Object.keys(lineName).forEach(key => delete lineName[key]);
        stopIds.length = 0;
        Object.keys(stopNameMap).forEach(key => delete stopNameMap[key]);
        
        let extractedFiles;
        
        const { needsUpdate, fileHash, metadata } = await checkGTFSUpdate();
        
        if (needsUpdate) {
            const result = await extractGTFSFiles();
            extractedFiles = result.extractedFiles;
            
            await saveToCache(extractedFiles, result.metadata);
            
        } else {
            extractedFiles = await getFromCache();
            if (!extractedFiles) {
                const result = await extractGTFSFiles();
                extractedFiles = result.extractedFiles;
                await saveToCache(extractedFiles, result.metadata);
                toastBottomRight.success('Données téléchargées avec succès !');
            } 
        }
        
        if (extractedFiles['routes.txt']) {
            await loadLineColors(extractedFiles['routes.txt']);
        }
        
        if (extractedFiles['stops.txt']) {
            await loadStopIds(extractedFiles['stops.txt']);
            await loadLineTerminusData(extractedFiles['stops.txt']);
        } else {
            console.error('Fichier stops.txt non trouvé');
        }
        
        return {
            lineColors,
            lineName,
            stopIds,
            stopNameMap
        };
        
    } catch (error) {
        console.error('Erreur lors de l\'initialisation data théorique gtfs', error);
        throw error;
    }
}

async function clearGTFSCache() {
    try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();

            request.onsuccess = () => {
                toastBottomRight.success('Cache effacé avec succès !');
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    } catch (error) {
        console.error('Erreur lors de l\'effacement du cache', error);
        toastBottomRight.error('Erreur lors de l\'effacement du cache');
        throw error;
    }
}

async function decodeProtobuf(buffer) {
            const root = await protobuf.load('gtfs-realtime.proto');
            const FeedMessage = root.lookupType('transit_realtime.FeedMessage');
            const message = FeedMessage.decode(new Uint8Array(buffer));
            return FeedMessage.toObject(message, { longs: String });
        }

        window.addEventListener('message', function(event) {
    if (event.data.type === 'vehicleSelected') {
        const vehicleId = event.data.vehicleId;
        const tripId = event.data.tripId;
        const stopId = event.data.stopId;
        const routeId = event.data.routeId;
        
        const marker = findMarkerByVehicleId(vehicleId);
        if (marker) {
            map.setView(marker.getLatLng(), 17);
            
            marker.openPopup();
            
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false;
            
            if (selectedLine) {
                resetMapView();
            }
        }
    }
});

function findMarkerByVehicleId(vehicleId) {
    for (const [id, marker] of Object.entries(markers)) {
        if (marker.id === vehicleId) {
            return marker;
        }
    }
    return null;
}

let lastActiveMarkerId = null;

let lastActiveColor = null;
window.isMenuShowed = false;


function createColoredMarker(lat, lon, route_id, bearing = 0) {
    const generateUniqueId = () => `popup-style-${Math.random().toString(36).substr(2, 9)}`;
    
    const color = lineColors[route_id] || '#000000';
    const markerHtmlStyles = `
        background-color: ${color};
        width: 12px;
        height: 12px;
        display: block;
        left: -6px;
        top: -6px;
        position: relative;
        border-radius: 50%;
        border: 2px solid white;
        transition: transform 0.2s ease, background-color 0.3s ease;
    `;

    const arrowSvg = `
        <svg class="marker-arrow" style="
            position: absolute;
            width: 16px;
            height: 16px;
            left: 4px;
            top: -2px;
            transform-origin: 2px; 
            transform: rotate(${bearing - 90}deg);
            transition: transform 0.5s ease;"
            viewBox="0 0 24 24">
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="white"
                stroke-width="6"
                stroke-linecap="round"
                stroke-linejoin="round"
            />
            <path 
                d="M8 4 L16 12 L8 20"
                fill="none"
                stroke="${color}"
                stroke-width="3"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="marker-arrow-path"
            />
        </svg>
    `;

    const icon = L.divIcon({
        className: "my-custom-pin",
        iconAnchor: [0, 0],
        popupAnchor: [0, 5],
        html: `
            <div style="position: relative;">
                <span style="${markerHtmlStyles}" class="marker-icon" />
                ${arrowSvg}
            </div>
        `
    });

    const marker = L.marker([lat, lon], { icon });
    const styleId = generateUniqueId();
    
    marker.on('popupopen', function(e) {
        const menubtm = document.getElementById('menubtm');
        const filtre = document.getElementById('filtre');
            safeVibrate([50]);

        if (menubtm) {
            const markerId = marker.id;
            const color = lineColors[route_id] || '#000000';
            

            if (lastActiveMarkerId !== null && lastActiveMarkerId !== markerId && lastActiveColor !== null) {
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                let textColor = '#FFFFFF';
                if (rgb) {
                    const r = parseInt(rgb[1], 16);
                    const g = parseInt(rgb[2], 16);
                    const b = parseInt(rgb[3], 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                }
                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                    #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            } else {
                const currentColor = window.getComputedStyle(menubtm).backgroundColor;
                
                const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                let textColor = '#FFFFFF';
                if (rgb) {
                    const r = parseInt(rgb[1], 16);
                    const g = parseInt(rgb[2], 16);
                    const b = parseInt(rgb[3], 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                }
                
                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                menubtm.style.backgroundColor = `${color}9c`;
                filtre.style.backgroundColor = `${color}9c`;

                document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                
                const styleSheet = document.createElement('style');
                styleSheet.id = styleId;
                styleSheet.classList.add('menu-color-style');
                
                styleSheet.textContent = `
                    #menubtm * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }

                        #filtre * {
                        color: ${textColor};
                        transition: color 0.5s ease;
                    }
                `;
                
                document.head.appendChild(styleSheet);
                marker.styleId = styleId;
            }
            
            lastActiveMarkerId = markerId;
            lastActiveColor = color;
        }
    });

    marker.on('popupclose', async function(e) {
    const menubtm = document.getElementById('menubtm');
    const filtre = document.getElementById('filtre');
    safeVibrate([50]);
    
    if (menubtm && filtre) {
        try {
            setTimeout(async () => {
                if (lastActiveMarkerId === marker.id) {
                    const data = await getSetvar();
                    
                    if (data) {
                        const menubtmCurrentTransition = window.getComputedStyle(menubtm).transition;
                        const filtreCurrentTransition = window.getComputedStyle(filtre).transition;
                        
                        if (!menubtmCurrentTransition.includes('background-color')) {
                            menubtm.style.transition = menubtmCurrentTransition 
                                ? `${menubtmCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        if (!filtreCurrentTransition.includes('background-color')) {
                            filtre.style.transition = filtreCurrentTransition 
                                ? `${filtreCurrentTransition}, background-color 0.5s ease` 
                                : 'background-color 0.5s ease';
                        }
                        
                        menubtm.style.backgroundColor = `${data.colorbkg}9c`;
                        filtre.style.backgroundColor = `${data.colorbkg}9c`;
                        
                        document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                        const styleSheet = document.createElement('style');
                        styleSheet.id = styleId;
                        styleSheet.classList.add('menu-color-style');
                        
                        const rgb = data.colorbkg.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                        let textColor = '#000000';
                        if (rgb) {
                            const r = parseInt(rgb[1], 16);
                            const g = parseInt(rgb[2], 16);
                            const b = parseInt(rgb[3], 16);
                            const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                            textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                        }
                        
                        styleSheet.textContent = `
                            #menubtm * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }

                            #filtre * {
                                color: ${textColor};
                                transition: color 0.5s ease;
                            }
                        `;
                        
                        document.head.appendChild(styleSheet);
                        
                        lastActiveMarkerId = null;
                        lastActiveColor = null;
                        
                        if (marker.styleId) {
                            const oldStyle = document.getElementById(marker.styleId);
                            if (oldStyle) {
                                setTimeout(() => {
                                    oldStyle.remove();
                                }, 500);
                            }
                        }
                    }
                }
            }, 50); 
        } catch (error) {
            return false;
        }
    }
});
    return marker;
}

function animateMarker(marker, newPosition) {
    const startLatLng = marker.getLatLng();
    const endLatLng = L.latLng(newPosition[0], newPosition[1]);
    const duration = 1000; 
    const startTime = performance.now();

    if (marker.animationFrame) {
        cancelAnimationFrame(marker.animationFrame);
    }

    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function animate(time) {
        const elapsed = time - startTime;
        const linearProgress = Math.min(elapsed / duration, 1);
        
        const easedProgress = easeInOutQuad(linearProgress);
        
        const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * easedProgress;
        const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * easedProgress;
        
        marker.setLatLng([lat, lng]);

        if (linearProgress < 1) {
            marker.animationFrame = requestAnimationFrame(animate);
        }
    }

    marker.animationFrame = requestAnimationFrame(animate);
}

let busStopLayers = [];
let selectedLines = [];




async function loadGeoJsonLines() {
    const response = await fetch('proxy-cors/proxy_geojson.php');
    const geoJsonData = await response.json();

    const busLines = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry.type === 'LineString';
        },
        style: function(feature) {
            return {
                color: lineColors[feature.properties.route_id] || '#3388ff',
                weight: 6,
                opacity: 0.7,  
                lineJoin: 'round',
                lineCap: 'round',
                className: 'bus-line', 
                dashArray: feature.properties.route_type === '3' ? '5, 5' : null
            };
        },
        onEachFeature: function(feature, layer) {
            
            if (feature.properties && feature.properties.route_id) {
                geoJsonLines.push(layer);
            }
        }
    }).addTo(map);

    const busStops = L.geoJSON(geoJsonData, {
        filter: function(feature) {
            return feature.geometry && feature.geometry.type === 'Point';
        },
        pointToLayer: function(feature, latlng) {
            return L.circleMarker(latlng, {
                radius: 3,
                fillColor: '#ffffff',
                color: '#000000',
                weight: 0.5,
                opacity: 0.7,
                fillOpacity: 0.6
            });
        }
    }).addTo(map);
    
    busStops.eachLayer(function(layer) {
        if (layer.feature && layer.feature.properties) {
            layer.busLine = layer.feature.properties.route_id || null;
            busStopLayers.push(layer);
        }
    });
    
}



function filterByLine(lineId) {
  const lineIndex = selectedLines.indexOf(lineId);

  if (lineIndex !== -1) {
    selectedLines.splice(lineIndex, 1);
  } else {
    selectedLines.push(lineId);
  }

  updateLinesDisplay();

  if (selectedLines.length === 0) {
    const filtre = document.getElementById('filtre');
    filtre.classList.add('slide-upc');
    filtre.classList.remove('slide-downc');
    filtre.addEventListener('animationend', () => {
        filtre.style.display = 'none';
    });
    resetMapView();
  } else if (selectedLines.length === 1) {
    zoomToSelectedLine(selectedLines[0]);
  } else if (selectedLines.length > 1) {
    zoomToMultipleLines(selectedLines);
  }
}

function zoomToSelectedLine(lineId) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (layer.feature.properties.route_id === lineId) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [10, 10], 
      maxZoom: 17        
    });
  }
}

function zoomToMultipleLines(lineIds) {
  const bounds = L.latLngBounds();

  geoJsonLines.forEach(layer => {
    if (lineIds.includes(layer.feature.properties.route_id)) {
      bounds.extend(layer.getBounds());
    }
  });

  if (bounds.isValid()) {
    map.fitBounds(bounds, {
      padding: [50, 50], 
      maxZoom: 15       
    });
  }
}

function updateLinesDisplay() {
  geoJsonLines.forEach(layer => {
    const routeId = layer.feature.properties.route_id;

    if (selectedLines.length === 0 || selectedLines.includes(routeId)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  busStopLayers.forEach(layer => {
    const busLine = layer.busLine;
    
    if (selectedLines.length === 0 || selectedLines.includes(busLine)) {
      if (!map.hasLayer(layer)) {
        map.addLayer(layer);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });

  Object.entries(markers).forEach(([id, marker]) => {
    if (selectedLines.length === 0 || selectedLines.includes(marker.line)) {
      if (!map.hasLayer(marker)) {
        map.addLayer(marker);
      }
    } else {
      if (map.hasLayer(marker)) {
        if (marker.isPopupOpen()) {
          marker.closePopup();
        }
        map.removeLayer(marker);
      }
    }
  });
}

function resetMapView() {
    selectedLines = [];

    selectedLine = null;

    geoJsonLines.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    busStopLayers.forEach(layer => {
        if (!map.hasLayer(layer)) {
            map.addLayer(layer);
        }
    });

    Object.values(markers).forEach(marker => {
        if (!map.hasLayer(marker)) {
            map.addLayer(marker);
        }
    });
}

function showPopup() {
    const popup2 = document.getElementById('popup2');

    popup2.style.display = 'block';
    

    const menubottom1 = document.getElementById('menubtm');


    const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
                const filtre = document.getElementById('filtre');
                filtre.classList.add('slide-upc');
                filtre.classList.remove('slide-downc');
                filtre.addEventListener('animationend', () => {
                    filtre.style.display = 'none';
                });
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });



}

function closePopup() {
    const popup2 = document.getElementById('popup2');
    popup2.style.display = 'none';
    const menubottom1 = document.getElementById('menubtm');
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false; 
            menubottom1.style.display = 'flex';
    setTimeout(() => {
        menubottom1.classList.remove('slide-upb');
        menubottom1.classList.add('slide-downb');
    }, 10);


}



const filtre = document.getElementById('filtre');
    filtre.onclick = () => {
        if (selectedLine) {
            filtre.classList.add('slide-upc');
            filtre.classList.remove('slide-downc');
            filtre.addEventListener('animationend', () => {
                filtre.style.display = 'none';
            });
    resetMapView();
    }
};










async function loadVehicleModels() {
    try {
        const response = await fetch('setvar/vehicules/index.php');
        const fileList = await response.json();
        
        for (const file of fileList) {
            if (file.endsWith('.txt')) {
                await loadVehicleModelFile(file);
            }
        }
        
    } catch (error) {
        console.error('Erreur lors du chargement des modèles de véhicules ', error);
        toastBottomRight.error('Erreur lors du chargement des modèles de véhicules ', error);
    }
}

async function loadVehicleModelFile(fileName) {
    try {
        const response = await fetch(`setvar/vehicules/${fileName}`);
        const content = await response.text();
        const lines = content.split('\n').map(line => line.trim()).filter(line => line !== '');
        
        if (lines.length < 8) {
            console.error(`Format invalide pour le fichier ${fileName}`);
            toastBottomRight.error(`Format invalide pour le fichier ${fileName}`);
            return;
        }
        
        const modelName = lines[0];
        const thumbnailPath = lines[1];
        
        const params = {
            isElectric: parseParamValue(lines[2]),       
            isHybrid: parseParamValue(lines[3]),       
            isGnv: parseParamValue(lines[4]),     
            isUsbPlugs: parseParamValue(lines[5]),  
            isAirConditioned: parseParamValue(lines[6]), 
            isHeatingUnit: parseParamValue(lines[7])
        };
        
        const vehicleIds = lines.slice(8);
        
        const modelKey = fileName.replace('.txt', '');
        
        vehicleModels[modelKey] = {
            name: modelName,
            thumbnail: thumbnailPath,
            params: params,
            vehicles: new Set(vehicleIds)
        };
        
        vehicleIds.forEach(id => {
            if (params.isElectric) vehicleTypes['elec'].add(id);
            if (params.isHybrid) vehicleTypes['hybrid'].add(id);
            if (params.isGnv) vehicleTypes['gnv'].add(id);
            if (params.isUsbPlugs) vehicleTypes['usb'].add(id);
            if (params.isAirConditioned || params.isHeatingUnit) vehicleTypes['clim'].add(id);
        });
        
    } catch (error) {
        console.error(`Erreur lors du chargement du fichier ${fileName}:`, error);
        toastBottomRight.error('Une erreur est survenue.');

    }
}

function parseParamValue(paramLine) {
    const parts = paramLine.split('=');
    if (parts.length !== 2) return false;
    
    return parts[1].toLowerCase() === 'true';
}

function getVehicleModel(parkNumber) {
    const parkId = String(parkNumber);    
    for (const [modelKey, model] of Object.entries(vehicleModels)) {
        if (model.vehicles.has(parkId)) {
            return model;
        }
    }
    return null;
}

function getVehicleOptionsBadges(parkNumber) {
    const model = getVehicleModel(parkNumber);
    let badges = '';
    
    if (model) {
        const params = model.params;
        
        const badgeStyle = `
            padding: 6px 10px; 
            background: #00000077; 
            font-weight: normal; 
            white-space: nowrap; 
            -webkit-backdrop-filter: blur(8px); 
            border-radius: 10px; 
            display: inline-flex; 
            align-items: center; 
            gap: 6px;
            height: 20px;
        `;
        
        const svgStyle = `
            display: inline-block;
            vertical-align: top;
            position: relative;
            top: -1px;
        `;
        
        const textStyle = `
            display: inline-block;
            line-height: 20px;
            vertical-align: middle;
            position: relative;
            top: 1px;
        `;

        if (params.isElectric) {
            badges += `<span style="${badgeStyle}">
                <img src="src/elec.png" alt="Électrique" style="height: 20px;">
            </span> `;
        }
        if (params.isHybrid) {
            badges += `<span style="${badgeStyle}">
                <img src="src/hyb.png" alt="Hybride" style="height: 20px;">
            </span> `;
        }
        if (params.isGnv) {
            badges += `<span style="${badgeStyle}">
                <img src="src/gnv.png" alt="Gaz Naturel" style="height: 20px;">
            </span> `;
        }
        if (params.isUsbPlugs) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle cx="12" cy="17" r="1" stroke="#ffffff" stroke-width="1.5"></circle> <circle cx="8" cy="9" r="1" stroke="#ffffff" stroke-width="1.5"></circle> <path d="M11.25 16C11.25 16.4142 11.5858 16.75 12 16.75C12.4142 16.75 12.75 16.4142 12.75 16H11.25ZM12 6L12.5303 5.46967C12.2374 5.17678 11.7626 5.17678 11.4697 5.46967L12 6ZM12.4697 7.53033C12.7626 7.82322 13.2374 7.82322 13.5303 7.53033C13.8232 7.23744 13.8232 6.76256 13.5303 6.46967L12.4697 7.53033ZM10.4697 6.46967C10.1768 6.76256 10.1768 7.23744 10.4697 7.53033C10.7626 7.82322 11.2374 7.82322 11.5303 7.53033L10.4697 6.46967ZM11.4697 6.53033L12.4697 7.53033L13.5303 6.46967L12.5303 5.46967L11.4697 6.53033ZM11.4697 5.46967L10.4697 6.46967L11.5303 7.53033L12.5303 6.53033L11.4697 5.46967ZM12.75 16V14.125H11.25V16H12.75ZM12.75 14.125V6H11.25V14.125H12.75Z" fill="#ffffff"></path> <path d="M8 10V11.0296C8 11.9044 8.5685 12.6777 9.40345 12.9386L10.8069 13.3772C11.5167 13.599 12 14.2563 12 15" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M16 11V12.0296C16 12.9044 15.4315 13.6777 14.5966 13.9386L13.1931 14.3772C12.4833 14.599 12 15.2563 12 16" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M15 10C15 9.5286 15 9.29289 15.1464 9.14645C15.2929 9 15.5286 9 16 9C16.4714 9 16.7071 9 16.8536 9.14645C17 9.29289 17 9.5286 17 10C17 10.4714 17 10.7071 16.8536 10.8536C16.7071 11 16.4714 11 16 11C15.5286 11 15.2929 11 15.1464 10.8536C15 10.7071 15 10.4714 15 10Z" stroke="#ffffff" stroke-width="1.5"></path> <path d="M7 3.33782C8.47087 2.48697 10.1786 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 10.1786 2.48697 8.47087 3.33782 7" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>             
                <span style="${textStyle}">${t("usb")}</span>
            </span> `;
        }
        if (params.isAirConditioned) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g id="a"></g> <g id="b"> <path d="M29,8v5c0,1.1-.9,2-2,2h-1.21l-.1-1H6.31l-.1,1h-1.21c-1.1,0-2-.9-2-2v-5c0-1.1,.9-2,2-2H27c1.1,0,2,.9,2,2Z" style="fill:#ffffff;"></path> <path d="M27,5H5c-1.6543,0-3,1.3457-3,3v5c0,1.6543,1.3457,3,3,3h.098l-.0926,.8975c-.0293,.2812,.0625,.562,.252,.7725,.1899,.21,.4595,.3301,.7427,.3301H26c.2832,0,.5527-.1201,.7427-.3301,.1895-.2104,.2812-.4912,.252-.7725l-.0926-.8975h.098c1.6543,0,3-1.3457,3-3v-5c0-1.6543-1.3457-3-3-3ZM7.1084,16l.1035-1H24.7881l.1035,1H7.1084Zm20.8916-3c0,.5513-.4487,1-1,1h-.3044l-.0106-.1025c-.0527-.5098-.4819-.8975-.9946-.8975H6.3096c-.5127,0-.9419,.3877-.9946,.8975l-.0106,.1025h-.3044c-.5513,0-1-.4487-1-1v-5c0-.5513,.4487-1,1-1H27c.5513,0,1,.4487,1,1v5Zm-1-3c0,.5522-.4478,1-1,1h-1c-.5522,0-1-.4478-1-1s.4478-1,1-1h1c.5522,0,1,.4478,1,1Zm-4,0c0,.5522-.4478,1-1,1h-1c-.5522,0-1-.4478-1-1s.4478-1,1-1h1c.5522,0,1,.4478,1,1Zm-1.3291,15.2422c.4097,.3706,.4414,1.0029,.0708,1.4126-.1973,.2183-.4692,.3291-.7422,.3291-.2393,0-.479-.0854-.6704-.2583-2.5371-2.2954-2.3774-6.5806-2.3696-6.7622,.0244-.5513,.4976-.9932,1.0415-.9536,.5508,.0234,.979,.4893,.9565,1.0405-.0015,.0352-.1216,3.5322,1.7134,5.1919Zm6.2363-.8213c-.1694,.3647-.5308,.5791-.9077,.5791-.1411,0-.2842-.0298-.4204-.0928-.1099-.0513-2.6978-1.2852-3.667-4.624-.1538-.5303,.1514-1.0854,.6816-1.2393,.5322-.1538,1.0854,.1514,1.2393,.6816,.707,2.4355,2.5693,3.3589,2.5879,3.3672,.501,.2324,.7188,.8271,.4863,1.3281Zm-13.8667-4.4575c.0078,.1816,.1675,4.4668-2.3696,6.7622-.1914,.1729-.4312,.2583-.6704,.2583-.2729,0-.5444-.1108-.7422-.3291-.3706-.4097-.3389-1.042,.0708-1.4126,1.5327-1.3862,1.7563-4.2168,1.7134-5.1899-.0244-.5518,.4028-1.019,.9546-1.0435,.5381-.0249,1.0186,.4023,1.0435,.9546Zm-4.9526,.3198c-.9692,3.3389-3.5571,4.5728-3.667,4.624-.1362,.063-.2793,.0928-.4204,.0928-.377,0-.7383-.2144-.9077-.5791-.2314-.499-.0161-1.0913,.481-1.3257,.0938-.0454,1.8901-.9468,2.5933-3.3696,.1538-.5303,.7065-.8359,1.2393-.6816,.5303,.1538,.8354,.709,.6816,1.2393Z" style="fill:#ffffff;"></path> </g> </g></svg>
                <span style="${textStyle}">${t("ac")}</span>
            </span> `;
        }
        if (params.isHeatingUnit) {
            badges += `<span style="${badgeStyle}">
                <svg style="${svgStyle}" width="17" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path style="fill:#ffffff;" d="M465.94,475.301h-70.358c-7.484,0-13.553-6.068-13.553-13.553s6.069-13.553,13.553-13.553h70.358 c10.452,0,18.955-8.503,18.955-18.955V182.167c0-10.452-8.503-18.955-18.955-18.955H137.925c-10.452,0-18.955,8.503-18.955,18.955 v247.073c0,10.452,8.503,18.955,18.955,18.955h182.984c7.484,0,13.553,6.068,13.553,13.553s-6.069,13.553-13.553,13.553H137.925 c-25.398,0-46.06-20.663-46.06-46.06V182.167c0-25.398,20.663-46.06,46.06-46.06H465.94c25.398,0,46.06,20.663,46.06,46.06v247.073 C512,454.637,491.337,475.301,465.94,475.301z"></path> <path style="fill:#ffffff;" d="M190.663,411.956L190.663,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C214.333,401.304,203.68,411.956,190.663,411.956 z"></path> <path style="fill:#ffffff;" d="M190.663,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221s37.223,16.697,37.223,37.221v165.167C227.884,408.811,211.187,425.508,190.663,425.508z M190.663,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117 V223.118C200.779,217.541,196.241,213.004,190.663,213.004z"></path> <path style="fill:#ffffff;" d="M301.932,411.956L301.932,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C325.601,401.304,314.95,411.956,301.932,411.956 z"></path> <path style="fill:#ffffff;" d="M301.931,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221c20.526,0,37.223,16.697,37.223,37.221v165.167 C339.154,408.811,322.457,425.508,301.931,425.508z M301.931,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166 c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117V223.118C312.048,217.541,307.509,213.004,301.931,213.004z"></path> <path style="fill:#ffffff;" d="M413.202,411.956L413.202,411.956c-13.019,0-23.67-10.651-23.67-23.67V223.118 c0-13.019,10.651-23.67,23.67-23.67l0,0c13.019,0,23.67,10.651,23.67,23.67v165.167C436.87,401.304,426.219,411.956,413.202,411.956 z"></path> <g> <path style="fill:#ffffff;" d="M413.202,425.508c-20.526,0-37.223-16.698-37.223-37.223V223.118 c0-20.524,16.697-37.221,37.223-37.221s37.223,16.697,37.223,37.221v165.167C450.424,408.811,433.726,425.508,413.202,425.508z M413.202,213.004c-5.578,0-10.117,4.539-10.117,10.116v165.166c0,5.578,4.539,10.117,10.117,10.117s10.117-4.539,10.117-10.117 V223.118C423.319,217.541,418.78,213.004,413.202,213.004z"></path> <path style="fill:#ffffff;" d="M105.416,230.486H58.277c-7.484,0-13.553-6.068-13.553-13.553c0-7.485,6.069-13.553,13.553-13.553 h47.139c7.484,0,13.553,6.068,13.553,13.553C118.969,224.418,112.901,230.486,105.416,230.486z"></path> <path style="fill:#ffffff;" d="M105.416,408.027H58.277c-7.484,0-13.553-6.068-13.553-13.553c0-7.485,6.069-13.553,13.553-13.553 h47.139c7.484,0,13.553,6.068,13.553,13.553C118.969,401.959,112.901,408.027,105.416,408.027z"></path> <path style="fill:#ffffff;" d="M47.435,251.51c-7.484,0-13.553-6.068-13.553-13.553V92.943c0-7.485,6.069-13.553,13.553-13.553 s13.553,6.068,13.553,13.553v145.014C60.987,245.442,54.918,251.51,47.435,251.51z"></path> <path style="fill:#ffffff;" d="M47.435,475.301c-7.484,0-13.553-6.068-13.553-13.553V305.703c0-7.485,6.069-13.553,13.553-13.553 s13.553,6.068,13.553,13.553v156.045C60.987,469.234,54.918,475.301,47.435,475.301z"></path> </g> <rect x="13.553" y="50.253" style="fill:#ffffff;" width="67.764" height="73.185"></rect> <path style="fill:#ffffff;" d="M81.317,136.989H13.553C6.069,136.989,0,130.922,0,123.436V50.252 c0-7.485,6.069-13.553,13.553-13.553h67.764c7.484,0,13.553,6.068,13.553,13.553v73.185C94.869,130.922,88.8,136.989,81.317,136.989 z M27.106,109.884h40.658V63.804H27.106V109.884z"></path> </g></svg>
                <span style="${textStyle}">${t("hot")}</span>
            </span> `;
        }
    } 
    
    return badges;
}

function getVehicleBrandHtml(parkNumber) {
    const model = getVehicleModel(parkNumber);
    const defaultImagePath = "src/generic.png";
    
    if (model) {
        return `
            <div class="vehicle-model">

                <img src="${model.thumbnail}" 
                     onerror="this.onerror=null; this.src='${defaultImagePath}';" 
                     alt="Thumbnail ${model.name}" 
                     class="vehicle-thumbnail"  />

                <span style="margin-top: 6px; margin-left: 20px; font-size: 12px; ">${t("determinantun")} ${model.name}</span>
            </div>
        `;
    }

    return `
        <div class="vehicle-model">
            <img src="${defaultImagePath}" 
                 alt="Bus par défaut" 
                 class="vehicle-thumbnail"  />
            <span style="margin-top: 6px; margin-left: 20px; font-size: 12px;">${t("abus")}</span>
        </div>
    `;
}


async function initializeApp() {
    try {
        
        for (const key in vehicleTypes) {
            vehicleTypes[key] = new Set();
        }
        
        await loadVehicleModels();
        
        await fetchVehiclePositions();
    } catch (error) {
        console.error('BECAB Launcher : erreur lors de l\'initialisation :', error);
        toastBottomRight.error('BECAB Launcher : erreur lors de l\'initialisation :', error);

    }
}

let isVibrating = false;
let vibrationTimeout = null;

/**
 * Fonction pour gérer les vibrations de manière sécurisée sans chevauchement
 * @param {Array|Number} pattern - Motif de vibration (un nombre pour une vibration simple, un tableau pour un motif)
 * @param {Boolean} force - Forcer la vibration même si une autre est en cours
 * @returns {Boolean} - Indique si la vibration à été déclenchée
 * Par Becab Systems
 */
function safeVibrate(pattern, force = false) {
    if (!navigator.vibrate) {
        return false;
    }
    
    if (isVibrating && !force) {
        return false;
    }
    
    if (isVibrating && force) {
        navigator.vibrate(0);
        
        if (vibrationTimeout) {
            clearTimeout(vibrationTimeout);
            vibrationTimeout = null;
        }
    }
    
    isVibrating = true;
    
    const vibrationPattern = Array.isArray(pattern) ? pattern : [pattern];
    
    const totalDuration = vibrationPattern.reduce((a, b) => a + b, 0) + 50;
    
    try {
        const success = navigator.vibrate(vibrationPattern);
        
        if (success === false) {
            isVibrating = false;
            return false;
        }
    } catch (error) {
        isVibrating = false;
        return false;
    }
    
    vibrationTimeout = setTimeout(() => {
        isVibrating = false;
        vibrationTimeout = null;
    }, totalDuration);
    
    return true;
}



let gtfsInitialized = false;
window.isBottomSheetOpen = false;

const langSwitcher = createLanguageSwitcher();

function createLanguageSwitcher(container) {
  // Config des langues disponibles (pour rajoutes langues, juste rajouter un objet dans le tableau
  // et rajouter la langue dans le fichier de traduction i18n.js)
  const languages = [
    { code: 'fr', name: 'Français 🥖🥐' },
    { code: 'en', name: 'English 🐟🍟' },
    { code: 'it', name: 'Italiano 🍕🍍 (désolé nader)' },
    { code: 'ar', name: 'عربي 🫖🍖' }
  ];
  
  const switcherContainer = document.createElement('div');
  switcherContainer.style.display = 'none';
  switcherContainer.className = 'language-switcher glass-effect';
  switcherContainer.style.position = 'absolute';
  switcherContainer.style.top = '20px';
  switcherContainer.style.right = '20px';
  switcherContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  switcherContainer.style.backdropFilter = 'blur(8px)';
  switcherContainer.style.WebkitBackdropFilter = 'blur(8px)';
  switcherContainer.style.borderRadius = '12px';
  switcherContainer.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.4)';
  switcherContainer.style.padding = '12px';
  switcherContainer.style.zIndex = '10000000000';
  switcherContainer.style.fontFamily = 'League Spartan, sans-serif';
  switcherContainer.style.transition = 'all 0.4s cubic-bezier(0.32, 0.64, 0.45, 1)';
  switcherContainer.style.transform = 'translateY(-100px)';
  switcherContainer.style.opacity = '0';
  
  const mainButton = document.createElement('div');
  mainButton.className = 'lang-main-button';
  mainButton.style.display = 'flex';
  mainButton.style.alignItems = 'center';
  mainButton.style.justifyContent = 'space-between';
  mainButton.style.cursor = 'pointer';
  mainButton.style.color = '#ffffff';
  mainButton.style.padding = '8px 12px';
  mainButton.style.borderRadius = '8px';
  mainButton.style.transition = 'background-color 0.4s';
  
  const globeIcon = document.createElement('span');
  globeIcon.innerHTML = '🌐';
  globeIcon.style.marginRight = '10px';
  globeIcon.style.fontSize = '18px';
  
  const currentLangText = document.createElement('span');
  currentLangText.id = 'current-lang-text';
  currentLangText.textContent = languages.find(lang => lang.code === i18n.currentLang)?.name || 'Langue';
  
  const arrowIcon = document.createElement('span');
  arrowIcon.innerHTML = '▼';
  arrowIcon.style.fontSize = '12px';
  arrowIcon.style.marginLeft = '10px';
  arrowIcon.style.transition = 'transform 0.4s';
  
  mainButton.appendChild(globeIcon);
  mainButton.appendChild(currentLangText);
  mainButton.appendChild(arrowIcon);
  
  const dropdown = document.createElement('div');
  dropdown.className = 'lang-dropdown';
  dropdown.style.display = 'none';
  dropdown.style.flexDirection = 'column';
  dropdown.style.marginTop = '10px';
  dropdown.style.borderRadius = '8px';
  dropdown.style.overflow = 'hidden';
  dropdown.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
  dropdown.style.backgroundColor = 'rgba(36, 36, 36, 0.95)';
  dropdown.style.animation = 'none';
  
  languages.forEach(lang => {
    const langOption = document.createElement('div');
    langOption.className = 'lang-option';
    langOption.textContent = lang.name;
    langOption.dataset.lang = lang.code;
    langOption.style.padding = '10px 15px';
    langOption.style.cursor = 'pointer';
    langOption.style.transition = 'background-color 0.3s';
    langOption.style.color = '#ffffff';
    


    if (lang.code === i18n.currentLang) {
      langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
      langOption.style.fontWeight = 'bold';
    }
    
    langOption.onmouseover = () => {
      langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.3)';
    };
    
    langOption.onmouseout = () => {
      if (lang.code !== i18n.currentLang) {
        langOption.style.backgroundColor = 'transparent';
      } else {
        langOption.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
      }
    };
    
    langOption.onclick = async (e) => {
      e.stopPropagation();
      const newLang = lang.code;
      
      if (newLang !== i18n.currentLang) {
        const transitionOverlay = document.createElement('div');
        transitionOverlay.style.position = 'fixed';
        transitionOverlay.style.top = '0';
        transitionOverlay.style.left = '0';
        transitionOverlay.style.width = '100%';
        transitionOverlay.style.height = '100%';
        transitionOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        transitionOverlay.style.zIndex = '9999';
        transitionOverlay.style.opacity = '0';
        transitionOverlay.style.transition = 'opacity 0.4s ease';
        document.body.appendChild(transitionOverlay);
        
        setTimeout(() => {
          transitionOverlay.style.opacity = '1';
          
          const urlParams = new URLSearchParams(window.location.search);
          urlParams.set('lang', newLang);
          
          localStorage.setItem('preferredLanguage', newLang);
          
          setTimeout(() => {
            window.location.search = urlParams.toString();
          }, 300);
        }, 50);
      }
      
      toggleDropdown(false);
    };
    
    dropdown.appendChild(langOption);
  });
  
  switcherContainer.appendChild(mainButton);
  switcherContainer.appendChild(dropdown);
  
  let isOpen = false;
  
  function toggleDropdown(forceState) {
    isOpen = forceState !== undefined ? forceState : !isOpen;
    
    if (isOpen) {
      dropdown.style.display = 'flex';
      dropdown.style.animation = 'zoomFadeIn 0.5s cubic-bezier(0.25, 1.5, 0.5, 1) forwards';
      arrowIcon.style.transform = 'rotate(180deg)';
      mainButton.style.backgroundColor = 'rgba(80, 80, 80, 0.3)';
    } else {
      dropdown.style.animation = 'none';
      dropdown.style.display = 'none';
      arrowIcon.style.transform = 'rotate(0deg)';
      mainButton.style.backgroundColor = 'transparent';
    }
  }
  
  mainButton.onclick = () => toggleDropdown();
  
  document.addEventListener('click', (e) => {
    if (!switcherContainer.contains(e.target) && isOpen) {
      toggleDropdown(false);
    }
  });
  
  
  if (container) {
    if (typeof container === 'string') {
      document.querySelector(container).appendChild(switcherContainer);
    } else {
      container.appendChild(switcherContainer);
    }
  } else {
    document.body.appendChild(switcherContainer);
  }
  
  return {
    element: switcherContainer,
    updateCurrentLanguage: (langCode) => {
      currentLangText.textContent = languages.find(lang => lang.code === langCode)?.name || 'Langue';
      
      document.querySelectorAll('.lang-option').forEach(option => {
        if (option.dataset.lang === langCode) {
          option.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
          option.style.fontWeight = 'bold';
        } else {
          option.style.backgroundColor = 'transparent';
          option.style.fontWeight = 'normal';
        }
      });
    }
  };
}



function hideLanguageSwitcher() {
  langSwitcher.element.style.transform = 'translateY(-100px)';
  langSwitcher.element.style.opacity = '0';
  
  setTimeout(() => {
    langSwitcher.element.style.display = 'none';
  }, 300); 
}

function showLanguageSwitcher() {
  langSwitcher.element.style.display = 'block';
  
  setTimeout(() => {
    langSwitcher.element.style.transform = 'translateY(0)';
    langSwitcher.element.style.opacity = '1';
  }, 10);
}




async function fetchVehiclePositions() {

    if (!gtfsInitialized) {
        console.log("fetchVehiclePositions: GTFS pas encore initialisé, attente...");
        return; 
    }
        if (!window.timeAnimationStyleAdded) {
        const timeAnimationStyle = `
        <style id="time-animation-styles">
            .time-display {
                transition: opacity 0.3s ease-out;
            }
            
            .time-display.fade-out {
                opacity: 0;
            }
            
            @keyframes radiateWaves {
                0% { transform: scale(0.7); opacity: 0.5; }
                50% { transform: scale(1.2); opacity: 1; }
                100% { transform: scale(1); opacity: 0.7; }
            }
            
            .time-indicator .rss-waves {
                transform-origin: 5px 19px; 
            }
            
            .time-indicator.animate .rss-waves {
                animation: radiateWaves 0.6s ease-out;
            }
            
            @keyframes scrollText {
                0% { transform: translateX(0); }
                10% { transform: translateX(0); }
                60% { transform: translateX(calc(-100% + 70px)); }
                90% { transform: translateX(calc(-100% + 70px)); }
                100% { transform: translateX(0); }
            }
            
            .stop-name-container:hover .stop-name-wrapper[style*="animation"] {
                animation-play-state: running !important;
            }
        </style>
        `;
        document.head.insertAdjacentHTML('beforeend', timeAnimationStyle);
        window.timeAnimationStyleAdded = true;
    }
    try {
        const response = await fetch('proxy-cors/proxy_vehpos.php');
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);

        const activeVehicleIds = new Set();

                const tempElement = document.createElement('div');
        tempElement.style.font = getComputedStyle(document.body).font;
        tempElement.style.visibility = 'hidden';
        tempElement.style.position = 'absolute';
        tempElement.style.whiteSpace = 'nowrap';
        document.body.appendChild(tempElement);
        


            data.entity.forEach(entity => {
                const vehicle = entity.vehicle;
                if (vehicle) {

                const id = vehicle.vehicle.id;
                const vehicleOptionsBadges = getVehicleOptionsBadges(id);
                const vehicleBrandHtml = getVehicleBrandHtml(id);
                const line = vehicle.trip && vehicle.trip.routeId ? vehicle.trip.routeId : 'Inconnu';
                const directionId = vehicle.trip ? vehicle.trip.directionId : undefined;
                activeVehicleIds.add(id);

                const statusMap = {
                    0: '❌ Hors service commercial',
                    1: ' En service - Portes ouvertes',
                    2: ' En service'
                };
                const status = statusMap[vehicle.currentStatus] || 'Inconnu';

                const stopIdun = vehicle.stopId || 'Inconnu';
                let stopId = stopIdun.replace("0:", "");
                const latitude = vehicle.position.latitude;
                const longitude = vehicle.position.longitude;

                if (isNaN(latitude) || isNaN(longitude)) {
                    return; 
                }

                const speed = vehicle.position.speed ? (vehicle.position.speed).toFixed(0) + ' km/h' : 'Arrêté';
                const bearing = vehicle.position.bearing || 'Inconnu';
                const tripId = vehicle.trip && vehicle.trip.tripId ? vehicle.trip.tripId : 'Inconnu';

                const lastStopId = tripUpdates[tripId] ? tripUpdates[tripId].lastStopId : 'Inconnu';
                const lastStopNameun = stopNameMap[lastStopId] || 'Destination inconnue';
                let lastStopName = lastStopNameun.replace("0:", "");
                
                const nextStops = tripUpdates[tripId]?.nextStops || [];
                let currentStopIndex = nextStops.findIndex(stop => stop.stopId.replace("0:", "") === stopId.replace("0:", ""));
                const now = Math.floor(Date.now() / 1000);

                let filteredStops = [];
                if (currentStopIndex !== -1) {
                    filteredStops = nextStops.slice(currentStopIndex).filter(stop => {
                        return stop.delay === null || stop.delay >= -60;
                    });
                } else {
                    filteredStops = nextStops.filter(stop => stop.delay === null || stop.delay > 0);
                }

                let stopsHeaderText = t("loading");
                if (currentStopIndex !== -1 && filteredStops.length > 0) {
                    const firstStopDelay = filteredStops[0].delay || 0;
                    const minutes = Math.max(0, Math.ceil(firstStopDelay / 60));
                    
                    stopsHeaderText = t("nextstops");
                    
                    if (filteredStops.length === 1) {
                        stopsHeaderText = minutes === 0 ? t("imminentdeparture") : `${t("departurein")} ${minutes} ${t("min")}`;
                    } else if (minutes > 3) {
                        stopsHeaderText = `${t("departurein")} ${minutes} ${t("minutes")}`;
                    }
                }
                
                let stopsListHTML = '';
                if (filteredStops.length > 0) {
                    stopsListHTML = filteredStops.map(stop => {
                        const timeLeft = stop.delay;
                        const timeLeftText = timeLeft !== null 
                            ? timeLeft <= 0 ? t("imminent") : `${Math.ceil(timeLeft / 60)} min`
                            : '';
                        
                        const stopName = stopNameMap[stop.stopId] || stop.stopId;
                        
                        tempElement.textContent = stopName;
                        
                        return `
                        <li style="list-style: none; padding: 0px; display: flex; justify-content: space-between;">
                            <div class="stop-name-container" style="position: relative; overflow: hidden; max-width: 70%; white-space: nowrap;">
                                <div class="stop-name-wrapper" style="position: relative; display: inline-block; padding-right: 10px;">
                                    <div class="stop-name" style="position: relative; display: inline-block;">${stopName}</div>
                                </div>
                            </div>
                            <div class="time-container" style="position: relative; min-height: 1.2em; text-align: right;">
                                <div class="time-display" 
                                    data-time-left="${timeLeftText}" 
                                    data-departure-time="${stop.departureTime || stop.arrivalTime || "Inconnu"}">
                                    ${timeLeftText}
                                </div>
                                <svg class="time-indicator" xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <g class="rss-waves">
                                        <path class="rss-arc-large" d="M4 4a16 16 0 0 1 16 16"></path>
                                        <path class="rss-arc-small" d="M4 11a9 9 0 0 1 9 9"></path>
                                    </g>
                                    <circle class="rss-dot" cx="5" cy="19" r="1"></circle>
                                </svg>
                            </div>
                        </li>`;
                    }).join('');
                }

                const nextStopsHTML = `
                    <div style="position: relative; max-height: 120px;">
                        <ul style="padding: 0; margin: 0; list-style-type: none; max-height: 120px;">
                            ${stopsListHTML}
                        </ul>
                    </div>
                `;

                if (!window.toggleTimeDisplay) {
                    window.isAnimating = false;
                    window.showTimeLeft = true;
                    
                    window.toggleTimeDisplay = function() {
                        if (window.isAnimating) return;
                        
                        window.isAnimating = true;
                        
                        const timeDisplays = document.querySelectorAll('.time-display');
                        const indicators = document.querySelectorAll('.time-indicator');
                        
                        timeDisplays.forEach(display => {
                            display.classList.add('fade-out');
                        });
                        
                        indicators.forEach(indicator => {
                            indicator.classList.add('animate');
                            
                            setTimeout(() => {
                                indicator.classList.remove('animate');
                            }, 600);
                        });
                        
                        setTimeout(() => {
                            window.showTimeLeft = !window.showTimeLeft;
                            
                            timeDisplays.forEach(display => {
                                const timeLeft = display.getAttribute('data-time-left');
                                const departureTime = display.getAttribute('data-departure-time');
                                display.textContent = window.showTimeLeft ? timeLeft : departureTime;
                            });
                            
                            timeDisplays.forEach(display => {
                                display.classList.remove('fade-out');
                            });
                            
                            setTimeout(() => {
                                window.isAnimating = false;
                            }, 350);
                        }, 350);
                    };

                    if (window.timeToggleInterval) {
                        clearInterval(window.timeToggleInterval);
                    }
                    window.timeToggleInterval = setInterval(window.toggleTimeDisplay, 4000);
                }

                const delayInfo = tripUpdates[tripId] ? tripUpdates[tripId].stopUpdates.find(update => update.stopId === stopId) : null;

                const arrivalDelay = delayInfo ? delayInfo.arrivalDelay : 0; 
                const scheduledArrival = delayInfo ? delayInfo.scheduledArrival : null; 

                                
                function getTextColorForBackground(bgColor) {
                    const color = bgColor.replace('#', '');
                    const r = parseInt(color.substring(0, 2), 16);
                    const g = parseInt(color.substring(2, 4), 16);
                    const b = parseInt(color.substring(4, 6), 16);
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    return brightness > 150 ? '#000000' : '#FFFFFF';
                }

                const backgroundColor = lineColors[line] || '#000000';
                const textColor = getTextColorForBackground(backgroundColor);

                let arrivalTime = 'Inconnu';
                if (scheduledArrival) {
                    const arrivalDate = new Date(scheduledArrival * 1000);
                    arrivalTime = arrivalDate.toLocaleTimeString();
                }

                let delayMessage = 'À l\'heure';
                if (arrivalDelay > 0) {
                    delayMessage = `En retard de ${arrivalDelay} secondes`;
                } else if (arrivalDelay < 0) {
                    delayMessage = `En avance de ${Math.abs(arrivalDelay)} secondes`;
                }

                let remainingTimeMessage = t("endstop");
                if (nextStops.length > 1) {
                    const penultimateStop = nextStops[nextStops.length - 2]; // avant der arrêt
                    const scheduledArrivalPenultimate = penultimateStop.departureTime;

                    if (scheduledArrivalPenultimate && scheduledArrivalPenultimate.includes(":")) {
                        const [hours, minutes] = scheduledArrivalPenultimate.split(':').map(num => parseInt(num, 10));

                        const now = new Date();
                        const scheduledArrivalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);

                        const currentTime = new Date();
                        const timeRemaining = Math.max(scheduledArrivalDate - currentTime, 0);
                        const minutesRemaining = Math.floor(timeRemaining / 60000);
                        const secondsRemaining = Math.floor((timeRemaining % 60000) / 1000);

                        remainingTimeMessage = ` ${minutesRemaining} ${t("minutes")}.`;
                    } else {
                        remainingTimeMessage = ' ' + t("unknownarrival");
                    }
                }
                
                const popupContent = `
                    <div style="position: relative; font-family: 'League Spartan', sans-serif; font-size: 14px; color: #333; border-radius: 15px; box-shadow: 0px 0px 20px 4px ${backgroundColor}9c; overflow: hidden; background-color: ${backgroundColor}9c; color: ${textColor}; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">
                        
                <div style="position: relative; padding: 10px; color: ${textColor}; text-align: center; overflow: hidden; display: flex; justify-content: space-between; align-items: center; box-shadow: 0px 4px 20px 5px rgba(0, 0, 0, 0.3); border-radius: 11px; margin: 7px; ">
                    <!-- Texte principal -->
                    <div style="z-index: 2; text-align: left; width: 100%;">
                        <p style="margin: 0; font-size: 24px; ">${t("line")} ${lineName[line] || t("unknownline")}</p>
                        <strong style="margin: 0; font-size: 14px;">➜ ${lastStopName}</strong>
                <div>
                    <div style="position: relative; display: flex; align-items: center; ">
                        <div style="
                            position: relative;
                            flex: 1;
                            overflow: hidden;
                            border-radius: 10px;
                        ">
                            <!-- Contenu défilant horizontalement -->
                            <div class="options" style="
                                display: flex;
                                gap: 10px;
                                padding: 0px;
                                overflow-x: auto; 
                                white-space: nowrap;
                                scrollbar-width: thin; 
                                scrollbar-color: #888 #f1f1f1;
                                color: #ffffff;
                            " class="custom-scrollbar">
                                <!-- Numéro de parc -->
                                <span style="
                                    padding: 6px 10px; 
                                    background: #00000077; 
                                    font-weight: normal; 
                                    white-space: nowrap; 
                                    -webkit-backdrop-filter: blur(8px); 
                                    border-radius: 10px; 
                                    display: inline-flex; 
                                    align-items: center; 
                                    gap: 6px;
                                    height: 20px;
                                ">

                                <svg style="display: inline-block;vertical-align: top; position: relative;" width="17" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M10 2.00879C7.52043 2.04466 6.11466 2.22859 5.17157 3.17167C4 4.34324 4 6.22886 4 10.0001V12.0001C4 15.7713 4 17.657 5.17157 18.8285C6.34315 20.0001 8.22876 20.0001 12 20.0001C15.7712 20.0001 17.6569 20.0001 18.8284 18.8285C20 17.657 20 15.7713 20 12.0001V10.0001C20 6.22886 20 4.34324 18.8284 3.17167C17.8853 2.22859 16.4796 2.04466 14 2.00879" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M20 13H16M4 13H12" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M15.5 16H17" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M7 16H8.5" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M6 19.5V21C6 21.5523 6.44772 22 7 22H8.5C9.05228 22 9.5 21.5523 9.5 21V20" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M18 19.5V21C18 21.5523 17.5523 22 17 22H15.5C14.9477 22 14.5 21.5523 14.5 21V20" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M20 9H21C21.5523 9 22 9.44772 22 10V11C22 11.3148 21.8518 11.6111 21.6 11.8L20 13" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M4 9H3C2.44772 9 2 9.44772 2 10V11C2 11.3148 2.14819 11.6111 2.4 11.8L4 13" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M4.5 5H8.25M19.5 5H12" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>
                                <span style="display: inline-block; line-height: 20px; vertical-align: middle; position: relative; top: 1px;">${vehicle.vehicle.label || t("unknownparc")}</span>

                                    
                                </span>
                                
                                <!-- Badges des options du véhicule -->
                                ${vehicleOptionsBadges}
                            </div>
                        </div>
                    </div>
                </div>
            </div>


                    <!-- Texte en arrière-plan -->
                    <div style="
                        position: absolute;
                        right: 10px;
                        top: 0;
                        bottom: 0;
                        z-index: 1;
                        opacity: 0.1;
                        font-size: 100px;
                        color: ${textColor};
                        display: flex;
                        align-items: center;
                        justify-content: flex-end;
                        white-space: nowrap;
                    ">
                        ${t("line")} ${lineName[line] || "🚌🚍🚌🚍🚌🚍🚌"}
                    </div>
                </div>

                <div style="margin-right: 10px; margin-top: 10px; text-align: right;">
                ${vehicleBrandHtml}
                </div>



                <div style="padding-top: 10px; padding-left: 10px; padding-right: 10px; color: ${textColor};">
                <p style="margin: 0; font-size: 18px; text-align: right;">${stopsHeaderText}</p>
                    <ul>
                    <div id="nextStopsContent" class="next-stops-content">
                          ${nextStopsHTML}
                    </div>   
                </div>
                </div>
                `;
                
                if (markers[id]) {
        animateMarker(markers[id], [latitude, longitude]);
        
        if (!markers[id].id) {
            markers[id].id = id;
        }
        
        if (markers[id].line !== line) {
            const oldLine = markers[id].line;
            markers[id].line = line;
            
            const color = lineColors[line] || '#000000';
            if (markers[id]._icon) {
                const markerIcon = markers[id]._icon.querySelector('.marker-icon');
                if (markerIcon) {
                    markerIcon.style.transition = 'background-color 0.5s ease';
                    markerIcon.style.backgroundColor = color;
                }
                
                const arrowElement = markers[id]._icon.querySelector('.marker-arrow-path');
                if (arrowElement) {
                    arrowElement.style.transition = 'stroke 0.5s ease';
                    arrowElement.setAttribute('stroke', color);
                }
            }
            
            if (markers[id].isPopupOpen()) {
                const menubtm = document.getElementById('menubtm');
                const filtre = document.getElementById('filtre');
                if (menubtm) {
                    lastActiveColor = color;
                    
                    menubtm.style.backgroundColor = `${color}9c`;
                    filtre.style.backgroundColor = `${color}9c`;

                    
                    const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                    let textColor = '#FFFFFF';
                    if (rgb) {
                        const r = parseInt(rgb[1], 16);
                        const g = parseInt(rgb[2], 16);
                        const b = parseInt(rgb[3], 16);
                        const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                        textColor = brightness > 150 ? '#000000' : '#FFFFFF';
                    }
                    
                    const styleId = `popup-style-${Math.random().toString(36).substr(2, 9)}`;
                    const styleSheet = document.createElement('style');
                    styleSheet.id = styleId;
                    styleSheet.classList.add('menu-color-style');
                    
                    styleSheet.textContent = `
                        #menubtm * {
                            color: ${textColor};
                            transition: color 0.5s ease;
                        }

                        #filtre * {
                            color: ${textColor};
                            transition: color 0.5s ease;
                        }
                    `;
                    
                    document.querySelectorAll('.menu-color-style').forEach(style => style.remove());
                    document.head.appendChild(styleSheet);
                    markers[id].styleId = styleId;
                }
            }
        }
        
        if (markers[id]._icon) {
            const arrowElement = markers[id]._icon.querySelector('.marker-arrow');
            
            if (arrowElement) {
                const targetRotation = bearing - 90;
                arrowElement.style.transition = 'transform 0.5s ease';
                arrowElement.style.transform = `rotate(${targetRotation}deg)`;
                arrowElement._currentRotation = targetRotation;
            }
        }

        updateLinesDisplay();

        const existingPopup = markers[id].getPopup();
        const currentContent = existingPopup ? existingPopup.getContent() : '';

        if (existingPopup && currentContent === popupContent) {
            return;
        }

        markers[id].setPopupContent(popupContent);

        if (markers[id].isPopupOpen()) {
            const popup = markers[id]._popup;
            if (popup && popup._contentNode) {
                const popupElement = popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('hide'); 
                    popupElement.classList.add('show'); 
                    markers[id].openPopup();
                }
            }
        }

        if (selectedLine && markers[id].line !== selectedLine) {
            if (map.hasLayer(markers[id])) {
                map.removeLayer(markers[id]);
            }
        } else {
            if (!map.hasLayer(markers[id])) {
                map.addLayer(markers[id]);
            }
        }
    } else {
        const marker = createColoredMarker(latitude, longitude, line, bearing);
        updateLinesDisplay();
        markers[id] = marker;
        markers[id].line = line;
        markers[id].id = id;

        if (!selectedLine || selectedLine === line) {
            marker.addTo(map);
        }
        
        marker.bindPopup(popupContent);

        marker.on('popupopen', function (e) {
            if (e.popup && e.popup._contentNode) {
                const popupElement = e.popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('hide'); 
                    popupElement.classList.add('show');  
                }
            }
        });

        marker.on('popupclose', function (e) {
            if (e.popup && e.popup._contentNode) {
                const popupElement = e.popup._contentNode.parentElement;
                if (popupElement) {
                    popupElement.classList.remove('show');
                    popupElement.classList.add('hide');

                    setTimeout(() => {
                        if (e.popup) {
                            e.popup.remove(); 
                        }
                    }, 200); 
                }
            }
        });
    }}
});

                Object.keys(markers).forEach(id => {
            if (!activeVehicleIds.has(id)) {
                map.removeLayer(markers[id]); 
                delete markers[id]; 
            }
        });

				
        let isMenuVisible = true;

const favoriteLines = new Set(JSON.parse(localStorage.getItem('favoriteLines') || '[]'));

const ANIMATION_CONFIG = {
    DURATION: 400,
    POP_DURATION: 100,
    SPRING_TIMING: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    SCALE_UP: 1.03,
    ITEM_MARGIN: 10
};

function createNearbyVehiclesControl() {
    if (window.nearbyVehiclesControlInstance) {
        return window.nearbyVehiclesControlInstance;
    }

    const NearbyVehiclesControl = L.Control.extend({
        options: {
            position: 'topleft'
        },

        initialize: function(map) {
            L.Control.prototype.initialize.call(this, { map: map });
            this._lastUpdateCenter = null;
        },

        onAdd: function(map) {
            if (this._container) {
                return this._container;
            }

            this._container = L.DomUtil.create('div', 'nearby-vehicles-control');
            this._container.style.cssText = `
                position: absolute;
                width: max-content;
                font-family: 'League Spartan', sans-serif;
                margin-left: 12px;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 15px;
                box-shadow: 0 4px 20px 4px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                overflow: hidden;
                transition: all 0.5s cubic-bezier(0.25, 1.2, 0.5, 1);
                max-height: 60px;
                opacity: 0;
                display: none;
            `;

            const header = L.DomUtil.create('div', 'nearby-vehicles-header');
            header.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                cursor: pointer;
            `;

            const title = L.DomUtil.create('h3', '');
            title.textContent = 'Véhicules à proximité';
            title.style.cssText = `
                margin: 0;
                font-size: 20px;
                font-weight: 600;
                color: white;
                text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            `;


            header.appendChild(title);
            this._container.appendChild(header);

            this._listContainer = L.DomUtil.create('div', 'nearby-vehicles-list');
            this._listContainer.style.cssText = `
                max-height: 350px;
                overflow-y: auto;
                padding: 10px 15px;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.5s cubic-bezier(0.25, 1.5, 0.5, 1);
            `;
            this._container.appendChild(this._listContainer);

            this._isExpanded = false;
            this._isVisible = false;

            header.addEventListener('click', () => {
                this.toggleExpand();
            });


            map.on('moveend', () => this._updateVehiclesIfNeeded(map));

            return this._container;
        },

        _updateVehiclesIfNeeded: function(map) {
            const currentCenter = map.getCenter();
            const distanceMoved = this._lastUpdateCenter 
                ? currentCenter.distanceTo(this._lastUpdateCenter) 
                : Infinity;

            if (!this._lastUpdateCenter || distanceMoved > 500) {
                this._lastUpdateCenter = currentCenter;
                
                if (this._isExpanded) {
                    this.show();
                }
            }
        },

        show: function() {
            this._container.style.display = 'block';
            
            setTimeout(() => {
                this._container.style.opacity = '1';
            }, 10);

            const userLocation = map.getCenter();

            const closestVehicles = Object.values(markers)
                .filter(marker => marker.options && marker.options.icon)
                .map(marker => ({
                    marker: marker,
                    distance: userLocation.distanceTo(marker.getLatLng())
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 5);

            this._listContainer.innerHTML = '';

            closestVehicles.forEach((item) => {
                const marker = item.marker;
                const distance = (item.distance / 1000).toFixed(1);
                
                const vehicleId = marker.id;
                const line = marker.line;
                const backgroundColor = lineColors[line] || '#000000';
                const textColor = 'white';

                const vehicleItem = L.DomUtil.create('div', 'nearby-vehicle-item');
                vehicleItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    background-color: rgba(255, 255, 255, 0.1);
                    border-radius: 10px;
                    padding: 10px;
                    cursor: pointer;
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    color: white;
                `;

                vehicleItem.innerHTML = `
                    <div style="flex-grow: 1; z-index: 1; position: relative;">
                        <strong>Ligne ${lineName[line] || 'Inconnue'}</strong>
                        <div style="font-size: 0.8em; opacity: 0.7;">
                            à ${distance} km
                        </div>
                    </div>
                    <div style="
                        background: transparent; 
                        color: white; 
                        padding: 5px 10px; 
                        border-radius: 5px; 
                        z-index: 1; 
                        position: relative;
                        border: 1px solid white;
                    ">
                        ${vehicleId}
                    </div>
                `;

                vehicleItem.addEventListener('click', () => {
                    map.setView(marker.getLatLng(), 15);
                    marker.openPopup();
                    this.collapse();
                });

                this._listContainer.appendChild(vehicleItem);
            });

            if (!this._isExpanded) {
                this.expand();
            }

            this._isVisible = true;
            return this;
        },

        hide: function() {
            this._container.style.opacity = '0';
            
            setTimeout(() => {
                this._container.style.display = 'none';
            }, 300);

            this._isVisible = false;
            this._isExpanded = false;
            return this;
        },

        expand: function() {
            const header = this._container.querySelector('.nearby-vehicles-header');
            const listContainer = this._listContainer;

            this._container.style.maxHeight = '500px';
            listContainer.style.opacity = '1';
            listContainer.style.transform = 'translateY(0)';
            

            this._isExpanded = true;
            return this;
        },

        collapse: function() {
            const header = this._container.querySelector('.nearby-vehicles-header');
            const listContainer = this._listContainer;

            this._container.style.maxHeight = '60px';
            listContainer.style.opacity = '0';
            listContainer.style.transform = 'translateY(-20px)';
            

            this._isExpanded = false;
            return this;
        },

        toggleExpand: function() {
            if (this._isExpanded) {
                this.collapse();
            } else {
                this.expand();
            }
            return this;
        }
    });

    const nearbyVehiclesControl = new NearbyVehiclesControl(map);
    map.addControl(nearbyVehiclesControl);

    window.nearbyVehiclesControlInstance = nearbyVehiclesControl;

    window.nearbyVehiclesControl = {
        show: () => nearbyVehiclesControl.show(),
        hide: () => nearbyVehiclesControl.hide(),
        expand: () => nearbyVehiclesControl.expand(),
        collapse: () => nearbyVehiclesControl.collapse(),
        toggleExpand: () => nearbyVehiclesControl.toggleExpand()
    };

    return nearbyVehiclesControl;
}

createNearbyVehiclesControl();

let isAnimating = false;

function getAbsolutePositions(menu) {
    const sections = Array.from(menu.querySelectorAll('.linesection'));
    const positions = new Map();
    let accumulatedHeight = 0;
    
    sections.forEach(section => {
        const rect = section.getBoundingClientRect();
        positions.set(section, {
            top: accumulatedHeight,
            height: rect.height,
            index: sections.indexOf(section)
        });
        accumulatedHeight += rect.height + ANIMATION_CONFIG.ITEM_MARGIN;
    });
    
    return { sections, positions };
}

function getTargetIndex(sections, movingSection, isFavorite, favoriteLines) {
    const movingLine = movingSection.dataset.line;
    
    if (isFavorite) {
        const firstNonFavoriteIndex = sections.findIndex(section => 
            !favoriteLines.has(section.dataset.line)
        );
        
        if (firstNonFavoriteIndex === sections.indexOf(movingSection)) {
            return -1;
        }
        
        return firstNonFavoriteIndex === -1 ? sections.length : firstNonFavoriteIndex;
    } else {
        let targetIndex = 0; 
        
        for (let i = 0; i < sections.length; i++) {
            const sectionLine = sections[i].dataset.line;
            
            if (favoriteLines.has(sectionLine)) {
                const movingNum = parseInt(movingLine);
                const sectionNum = parseInt(sectionLine);
                
                if (!isNaN(movingNum) && !isNaN(sectionNum)) {
                    if (movingNum < sectionNum) {
                        return i;
                    }
                } else if (movingLine.localeCompare(sectionLine) < 0) {
                    return i;
                }
            } else {
                return i; 
            }
        }
        
        return sections.length;
    }
}

function prepareSectionsForAnimation(sections) {
    sections.forEach(section => {
        section.style.transition = 'none';
        section.style.position = 'relative';
        section.style.zIndex = '1';
        section.style.transform = 'translateY(0)';
    });
    
    // Force reflow
    sections[0].offsetHeight;
}

async function animateFavoriteTransition(button, lineSection, line, isFavorite) {
    if (isAnimating) return;
    isAnimating = true;
    
    const menu = document.getElementById('menu');
    if (!menu || !lineSection) return;
    
    try {
        menu.style.pointerEvents = 'none';
        button.style.pointerEvents = 'none';
        
        const { sections, positions } = getAbsolutePositions(menu);
        const currentIndex = sections.indexOf(lineSection);
        
        if (isFavorite) {
            favoriteLines.delete(line);
        } else {
            favoriteLines.add(line);
        }
        
        const targetIndex = getTargetIndex(sections, lineSection, isFavorite, favoriteLines);
        
        if (targetIndex === -1 || currentIndex === -1 || targetIndex === currentIndex) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            try {
                localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
            } catch (error) {
                console.error('Error saving favorite', error);
            }
            await cleanup(menu, button);
            return;
        }
        
        if (isFavorite) {
            await animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
            button.innerHTML = '☆';
        } else {
            await animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex);
        }
        
        try {
            localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
        } catch (error) {
            console.error('Error saving favorite', error);
        }
        
    } catch (error) {
        console.error('Animation err', error);
    } finally {
        await cleanup(menu, button);
    }
}

async function animateAddFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    for (let i = 0; i < targetIndex; i++) {
        if (i !== currentIndex) {
            const section = sections[i];
            const sectionPos = positions.get(section);
            targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = 0;
            
            if (currentIndex < targetIndex) {
                if (index > currentIndex && index <= targetIndex) {
                    displacement = -(currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
                }
            } else {
                if (index >= targetIndex && index < currentIndex) {
                    displacement = currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
                }
            }
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    lineSection.style.transform = `scale(1.05)`;
    await new Promise(r => setTimeout(r, 100));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1.05)`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    lineSection.style.transform = `translateY(${deltaY}px) scale(1)`;
    
    button.innerHTML = '★';
    button.style.transform = 'scale(1.2)';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

async function animateRemoveFavorite(button, lineSection, sections, positions, currentIndex, targetIndex) {
    prepareSectionsForAnimation(sections);
    
    lineSection.style.zIndex = '2';
    lineSection.style.transition = `all ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
    
    const currentPos = positions.get(lineSection);
    let targetY = 0;
    
    if (targetIndex === -1) {
        targetIndex = sections.length;
        sections.forEach((section, idx) => {
            if (idx !== currentIndex) {
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        });
    } else {
        for (let i = 0; i < targetIndex; i++) {
            if (i !== currentIndex) {
                const section = sections[i];
                const sectionPos = positions.get(section);
                targetY += sectionPos.height + ANIMATION_CONFIG.ITEM_MARGIN;
            }
        }
    }
    
    const deltaY = targetY - currentPos.top;
    
    sections.forEach((section, index) => {
        if (section !== lineSection) {
            let displacement = calculateDisplacement(index, currentIndex, targetIndex, 
                currentPos.height + ANIMATION_CONFIG.ITEM_MARGIN);
            
            if (displacement !== 0) {
                section.style.transition = `transform ${ANIMATION_CONFIG.DURATION}ms ${ANIMATION_CONFIG.SPRING_TIMING}`;
                section.style.transform = `translateY(${displacement}px)`;
            }
        }
    });
    
    await animateMovingSection(lineSection, deltaY);
    
    button.style.transform = 'scale(0.8)';
    button.innerHTML = '☆';
    await new Promise(r => setTimeout(r, 100));
    button.style.transform = 'scale(1)';
}

function calculateDisplacement(index, currentIndex, targetIndex, sectionHeight) {
    if (targetIndex === -1) {
        return index > currentIndex ? -sectionHeight : 0;
    }
    
    if (currentIndex < targetIndex) {
        return (index > currentIndex && index <= targetIndex) ? -sectionHeight : 0;
    } else {
        return (index >= targetIndex && index < currentIndex) ? sectionHeight : 0;
    }
}

async function animateMovingSection(section, deltaY) {
    section.style.transform = `scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.POP_DURATION));
    
    section.style.transform = `translateY(${deltaY}px) scale(${ANIMATION_CONFIG.SCALE_UP})`;
    await new Promise(r => setTimeout(r, ANIMATION_CONFIG.DURATION - 150));
    
    section.style.transform = `translateY(${deltaY}px) scale(1)`;
}


function updateFavoriteState(button, line, isFavorite) {
    if (isFavorite) {
        favoriteLines.delete(line);
        button.innerHTML = '☆';
    } else {
        favoriteLines.add(line);
        button.innerHTML = '★';
    }
    
    try {
        localStorage.setItem('favoriteLines', JSON.stringify([...favoriteLines]));
    } catch (error) {
        console.error('Error saving favorite', error);
    }
}



async function cleanup(menu, button) {
    await new Promise(r => setTimeout(r, 50));
    
    const sections = menu.querySelectorAll('.linesection');
    sections.forEach(section => {
        section.style.transform = '';
        section.style.transition = '';
        section.style.zIndex = '';
        section.style.position = '';
    });
    
    menu.style.pointerEvents = 'auto';
    button.style.pointerEvents = 'auto';
    
    updateMenu();
    isAnimating = false;
}

const animationStyle = document.createElement('style');
animationStyle.textContent = `
    .linesection {
        transition: transform 0.2s  cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.2s cubic-bezier(0.25, 1.5, 0.5, 1);
    }
    
    .linesection.removing {
        animation: remove-favorite 0.3s ease-out forwards;
    }
    
    @keyframes remove-favorite {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .favorite-button {
        transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    }
    
    .favorite-button:hover {
        transform: scale(1.1);
    }
    
    .favorite-button:active {
        transform: scale(0.9);
    }
`;
document.head.appendChild(animationStyle);



function updateMenu() {

    const menu = document.getElementById('menu');
    menu.innerHTML = '';

    const logoContainer = document.createElement('div');
    logoContainer.style.textAlign = 'center';
    logoContainer.style.marginBottom = '7px';

    const logo = document.createElement('img');
    logo.src = 'src/whitelogo.png'; 
    logo.alt = 'Logo de My Bus Finder';
    logo.style.maxWidth = '200px';
    logo.style.display = 'block';
    logo.style.margin = '0 auto';
    logo.style.cursor = 'pointer';
    logo.onclick = () => {
        showUpdatePopup('https://mybusfinder.fr/updatecm/updatecm.html');
        musique();
    };


    logoContainer.appendChild(logo);
    menu.appendChild(logoContainer);

    const now = new Date();
    const currentHour = now.getHours();
    const currentMinutes = now.getMinutes();
    const totalMinutes = currentHour * 60 + currentMinutes;

    let transportState = `${t("normal")}`;
    if ((totalMinutes >= 420 && totalMinutes <= 510) || (totalMinutes >= 960 && totalMinutes <= 1050)) {
        transportState = `${t("presquesature")}`; 
    } else if ((totalMinutes > 510 && totalMinutes <= 570) || (totalMinutes > 1020 && totalMinutes <= 1110)) {
        transportState = `${t("sature")}`;
    }

    const transportStateContainer = document.createElement('div');
    transportStateContainer.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 8px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        cursor: pointer;
    `;

    const filterTipContainer = document.createElement('div');
filterTipContainer.style.cssText = `
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 8px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    position: relative;
`;

if (localStorage.getItem('hideFilterTip') !== 'true') {
    document.body.appendChild(filterTipContainer);
}

const filterTipIcon = document.createElement('div');
filterTipIcon.innerHTML = `
<svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4 6 Q14 2, 24 6" stroke="white" stroke-width="2" fill="none" stroke-linecap="round"/>
    <path d="M4 14 Q14 10, 24 14" stroke="white" stroke-width="2" fill="none" stroke-linecap="round"/>
    <path d="M4 22 Q14 18, 24 22" stroke="white" stroke-width="2" fill="none" stroke-linecap="round"/>
    
    <circle cx="4" cy="6" r="2" fill="white"/>
    <circle cx="24" cy="6" r="2" fill="white"/>
    
    <circle cx="4" cy="14" r="2" fill="white"/>
    <circle cx="24" cy="14" r="2" fill="white"/>
    
    <circle cx="4" cy="22" r="2" fill="white"/>
    <circle cx="24" cy="22" r="2" fill="white"/>
</svg>
`;
filterTipIcon.style.marginRight = '12px';

const filterTipContent = document.createElement('div');
filterTipContent.style.color = 'white';

const filterTipTitle = document.createElement('div');
filterTipTitle.textContent = t("presentfilterbyline");
filterTipTitle.style.fontSize = '16px';

const filterTipDescription = document.createElement('div');
filterTipDescription.textContent = t("filterbylinedesc");
filterTipDescription.style.fontSize = '12px';
filterTipDescription.style.opacity = '0.7';
filterTipDescription.style.cssText = `
    font-size: 12px;
    opacity: 0.7;
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: normal;
`;

const closeButton = document.createElement('div');
closeButton.innerHTML = '&times;';
closeButton.style.cssText = `
    top: 5px;
    right: 10px;
    font-size: 18px;
    color: white;
    cursor: pointer;
`;

closeButton.addEventListener('click', () => {
    filterTipContainer.style.display = 'none';
    localStorage.setItem('hideFilterTip', 'true'); 
});

filterTipContent.appendChild(filterTipTitle);
filterTipContent.appendChild(filterTipDescription);

filterTipContainer.appendChild(filterTipIcon);
filterTipContainer.appendChild(filterTipContent);


const firstMenuElement = menu.firstChild;
menu.insertBefore(filterTipContainer, firstMenuElement.nextSibling);


let isStandardView = localStorage.getItem('isStandardView') === 'true';

function toggleMapView() {
    isStandardView = !isStandardView;
    
    localStorage.setItem('isStandardView', isStandardView);

    const menubottom1 = document.getElementById('menubtm');
        const menu = document.getElementById('menu');
        menu.classList.add('hidden');
        window.isMenuShowed = false;
        menu.addEventListener('animationend', function onAnimationEnd(event) {
            if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                menu.style.display = 'none';
            }
        });
        isMenuVisible = false;
        menubottom1.style.display = 'flex';
        setTimeout(() => {
            menubottom1.classList.remove('slide-upb');
            menubottom1.classList.add('slide-downb');
            if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.remove('slide-upc');
        filtre.classList.add('slide-downc');
        filtre.style.display = 'flex';
        }
        }, 10);

    
    applyMapView();

}

function applyMapView() {
    const currentDate = new Date();
    const latitude = map.getCenter().lat;  
    const longitude = map.getCenter().lng;  

    const sunTimes = SunCalc.getTimes(currentDate, latitude, longitude);
    const sunrise = sunTimes.sunrise;
    const sunset = sunTimes.sunset;

    const isNightMode = currentDate >= sunset || currentDate <= sunrise;

    map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer) {
            map.removeLayer(layer);
        }
    });

    if (!isStandardView) {
    const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        minZoom: 12,
        maxZoom: 19,
    }).addTo(map);
    
    if (isNightMode) {
        const mapPane = map.getPanes().tilePane;
        mapPane.style.filter = 'invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)';
    } else {
        const mapPane = map.getPanes().tilePane;
        mapPane.style.filter = 'none';
    }
} else {
    const mapPane = map.getPanes().tilePane;
    mapPane.style.filter = 'none';
    
    L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
        minZoom: 12,
        maxZoom: 19,
        format: 'image/jpeg',
        style: 'normal'
    }).addTo(map);
}
}


let startY;
let endY;
let startX;
let endX;
const menubtm = document.getElementById('menubtm');
let touchStartX = null;
let touchStartTime = null;
let isEdgeTouch = false;
const edgeThreshold = 10;
const minSwipeDistance = 20; 

menubtm.addEventListener('touchstart', (e) => {
    const touchStartY = e.touches[0].clientY;
    const menuRect = menubtm.getBoundingClientRect();
    
    startX = e.touches[0].clientX;
    
    if (touchStartY >= menuRect.bottom - 50) {
        startY = touchStartY;
    } else {
        startY = null;
    }
});

menubtm.addEventListener('touchmove', (e) => {
    if (startY !== null) {
        endY = e.touches[0].clientY;
    }
    
    endX = e.touches[0].clientX;
});

menubtm.addEventListener('touchend', () => {
    if (startX !== null && endX !== null && startY !== null && endY !== null) {
        if (!isBottomSheetOpen && !isMenuShowed) {
        const horizontalSwipeDistance = startX - endX;
        const verticalSwipeDistance = startY - endY;
        const minSwipeDistance = 50;
        
        if (Math.abs(horizontalSwipeDistance) > Math.abs(verticalSwipeDistance)) {
            if (horizontalSwipeDistance > minSwipeDistance) {
                showMenu();
            }
        } else {
            if (verticalSwipeDistance > minSwipeDistance) {
                showBottomSheet();
            }
        }
    }
}
    
    startX = null;
    endX = null;
    startY = null;
    endY = null;
});

function isTouchNearRightEdge(x) {
    return window.innerWidth - x <= edgeThreshold;
}

document.addEventListener('touchstart', function(e) {
    const touchX = e.touches[0].clientX;
    
    if (isTouchNearRightEdge(touchX)) {
        touchStartX = touchX;
        touchStartTime = Date.now();
        isEdgeTouch = true;
    }
}, { passive: true }); 

document.addEventListener('touchmove', function(e) {
    if (isEdgeTouch) {
        const currentX = e.touches[0].clientX;
    }
}, { passive: true });

document.addEventListener('touchend', function(e) {
    if (isEdgeTouch && touchStartX !== null) {
        const touchEndX = e.changedTouches[0].clientX;
        const swipeDistance = touchStartX - touchEndX;
        const touchDuration = Date.now() - touchStartTime;
        if (!isBottomSheetOpen) {
            if (swipeDistance > minSwipeDistance && touchDuration < 300) {
                showMenu();
            }
        }   
        
        isEdgeTouch = false;
        touchStartX = null;
        touchStartTime = null;
    }
});



function createBottomSheet() {
    const SNAP_POINTS = {
        CLOSED: 100,  // 100% of height (fully closed)
        PEEK: 60,    // 60% of height (partially open)
        OPEN: 0      // 0% (fully open)
        // By Becab Solutions - BottomSheetDisplay.js
    };
    const bottomSheet = document.createElement('div');
    bottomSheet.id = 'bottomSheet';
    bottomSheet.style.cssText = `
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: rgba(0, 0, 0, 0.7);
        border-top-left-radius: 20px;
        border-top-right-radius: 20px;
        backdrop-filter: blur(20px);
        box-shadow: 0 -10px 20px rgba(0, 0, 0, 0.2);
        transform: translateY(100%);
        transition: transform 0.4s cubic-bezier(0.32, 0.64, 0.45, 1);
        z-index: 1000;
        max-height: 80vh;
        overflow-y: auto;
        padding-bottom: 20px;
        touch-action: pan-y;
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
    `;

    const dragHandle = document.createElement('div');
    dragHandle.style.cssText = `
        width: 40px;
        height: 5px;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
        margin: 10px auto;
        cursor: grab;
    `;
    bottomSheet.appendChild(dragHandle)

    const now = new Date();
    const currentHour = now.getHours();
    const currentMinutes = now.getMinutes();
    const totalMinutes = currentHour * 60 + currentMinutes;

    let transportState = `${t("normal")}`;
    if ((totalMinutes >= 420 && totalMinutes <= 510) || (totalMinutes >= 960 && totalMinutes <= 1050)) {
        transportState = `${t("presquesature")}`; 
    } else if ((totalMinutes > 510 && totalMinutes <= 570) || (totalMinutes > 1020 && totalMinutes <= 1110)) {
        transportState = `${t("sature")}`;
    }

    function getTransportGreeting() {
        const now = new Date();
        const currentHour = now.getHours();

        const greetings = {
            morning: [
                t("greetings-morning1"),
                t("greetings-morning2"),
                t("greetings-morning3"),
                t("greetings-morning4"),
                t("greetings-morning5"),
                t("greetings-morning6"),
            ],
            midday: [
                t("greetings-midday1"),
                t("greetings-midday2"),
                t("greetings-midday3"),
                t("greetings-midday4"),
                t("greetings-midday5"),
                t("greetings-midday6"),
            ],
            afternoon: [
                t("greetings-afternoon1"),
                t("greetings-afternoon2"),
                t("greetings-afternoon3"),
                t("greetings-afternoon4"),
                t("greetings-afternoon5"),
                t("greetings-afternoon6"),
            ],
            evening: [
                t("greetings-evening1"),
                t("greetings-evening2"),
                t("greetings-evening3"),
                t("greetings-evening4"),
                t("greetings-evening5"),
                t("greetings-evening6"),
            ],
            night: [
                t("greetings-night1"),
                t("greetings-night2"),
                t("greetings-night3"),
                t("greetings-night4"),
                t("greetings-night5"),
                t("greetings-night6"),
            ]
        };

        if (currentHour >= 5 && currentHour < 10) return greetings.morning[Math.floor(Math.random() * greetings.morning.length)];
        if (currentHour >= 10 && currentHour < 14) return greetings.midday[Math.floor(Math.random() * greetings.midday.length)];
        if (currentHour >= 14 && currentHour < 18) return greetings.afternoon[Math.floor(Math.random() * greetings.afternoon.length)];
        if (currentHour >= 18 && currentHour < 23) return greetings.evening[Math.floor(Math.random() * greetings.evening.length)];
        return greetings.night[Math.floor(Math.random() * greetings.night.length)];
    }



    const transportStateContainer = document.createElement('div');
    transportStateContainer.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 15px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(255, 255, 255, 0.1);
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        cursor: pointer;
    `;

    const transportImage = document.createElement('img');
    transportImage.alt = t("transportstate");
    transportImage.style.width = '50px';
    transportImage.style.height = '36px';
    transportImage.style.marginRight = '10px';

    if (transportState === `${t("normal")}`) {
        transportImage.src = 'src/1of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.success(t("statenormal"));
        };
    } else if (transportState === `${t("presquesature")}`) {
        transportImage.src = 'src/2of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.warning(t("statemiddle"));
        };
    } else if (transportState === `${t("sature")}`) {
        transportImage.src = 'src/3of3body.png';
        transportStateContainer.onclick = () => {
            toastBottomRight.error(t("statecrowded"));
        };
    }

    transportStateContainer.onmouseover = () => {
        transportStateContainer.style.transform = 'scale(0.98,0.98)';
        transportStateContainer.style.boxShadow = '0 6px 12px rgba(255, 255, 255, 0.15)';
    };
    transportStateContainer.onmouseout = () => {
        transportStateContainer.style.transform = 'scale(1,1)';
        transportStateContainer.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
    };

    const transportStateTextContainer = document.createElement('div');
    transportStateTextContainer.style.textAlign = 'left';

    const transportStateLabel = document.createElement('div');
    transportStateLabel.textContent = t("transportstate");
    transportStateLabel.style.fontSize = '14px';
    transportStateLabel.style.marginTop = '7px';
    transportStateLabel.style.color = '#fff';

    const transportStateText = document.createElement('div');
    transportStateText.textContent = transportState.charAt(0).toUpperCase() + transportState.slice(1);
    transportStateText.style.fontSize = '22px';
    transportStateText.style.fontWeight = 'normal';
    transportStateText.style.color = '#fff';



    transportStateTextContainer.appendChild(transportStateLabel);
    transportStateTextContainer.appendChild(transportStateText);

    transportStateContainer.appendChild(transportImage);
    transportStateContainer.appendChild(transportStateTextContainer);


    const actu = createStyledButton(
        'Actualités', 
        'Dernières informations sur les transports en commun.', 
        `
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M9.23163 8.61762C7.26389 9.06284 6.28001 9.28545 6.04594 10.0382C5.81186 10.7909 6.4826 11.5753 7.82408 13.1439L8.17113 13.5498C8.55234 13.9955 8.74294 14.2184 8.82869 14.4942C8.91444 14.7699 8.88562 15.0673 8.82799 15.662L8.77552 16.2035C8.5727 18.2965 8.4713 19.343 9.08412 19.8082C9.69694 20.2734 10.6181 19.8492 12.4605 19.0009L12.9372 18.7815C13.4607 18.5404 13.7225 18.4199 14 18.4199C14.2775 18.4199 14.5393 18.5404 15.0628 18.7815L15.5395 19.0009C17.3819 19.8492 18.3031 20.2734 18.9159 19.8082C19.5287 19.343 19.4273 18.2965 19.2245 16.2035M20.1759 13.1439C21.5174 11.5753 22.1881 10.7909 21.9541 10.0382C21.72 9.28545 20.7361 9.06284 18.7684 8.61762L18.2593 8.50244C17.7001 8.37592 17.4205 8.31266 17.196 8.14225C16.9716 7.97183 16.8276 7.71355 16.5396 7.19699L16.2775 6.7267C15.2641 4.9089 14.7575 4 14 4C13.2425 4 12.7359 4.9089 11.7225 6.7267" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M2.08887 16C3.20445 15.121 4.68639 14.7971 6.08887 15.1257" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M2.08887 10.5C3.08887 10 3.37862 10.0605 4.08887 10" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M2 5.60867L2.20816 5.48676C4.41383 4.19506 6.75032 3.84687 8.95304 4.48161L9.16092 4.54152" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>
        `,
        () => showUpdatePopup("alerts.html")
    );


    const locationButton = createStyledButton(
        t("position"), 
        t("positiondesc"), 
        `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
        `,
        locateUser
    );

    const satelliteButton = createStyledButton(
        t("satellite"), 
        t("satellitedesc"), 
        `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3.6 9l1.5 1.5M9 3.6L10.5 5M21 3l-9 9M18.4 15l1.5 1.5M15 18.4l1.5 1.5M3 21l9-9"/>
            <circle cx="12" cy="12" r="3"/>
            <path d="M14.5 9.5L19 5"/>
            <path d="M5 19l4.5-4.5"/>
        </svg>
        `,
        toggleMapView
    );

    const histovecButton = createStyledButton(
        t("histovec"), 
        t("histovecdesc"), 
        `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M12 8V12L14.5 14.5" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M5.60423 5.60423L5.0739 5.0739V5.0739L5.60423 5.60423ZM4.33785 6.87061L3.58786 6.87438C3.58992 7.28564 3.92281 7.61853 4.33408 7.6206L4.33785 6.87061ZM6.87963 7.63339C7.29384 7.63547 7.63131 7.30138 7.63339 6.88717C7.63547 6.47296 7.30138 6.13549 6.88717 6.13341L6.87963 7.63339ZM5.07505 4.32129C5.07296 3.90708 4.7355 3.57298 4.32129 3.57506C3.90708 3.57715 3.57298 3.91462 3.57507 4.32882L5.07505 4.32129ZM3.75 12C3.75 11.5858 3.41421 11.25 3 11.25C2.58579 11.25 2.25 11.5858 2.25 12H3.75ZM16.8755 20.4452C17.2341 20.2378 17.3566 19.779 17.1492 19.4204C16.9418 19.0619 16.483 18.9393 16.1245 19.1468L16.8755 20.4452ZM19.1468 16.1245C18.9393 16.483 19.0619 16.9418 19.4204 17.1492C19.779 17.3566 20.2378 17.2341 20.4452 16.8755L19.1468 16.1245ZM5.14033 5.07126C4.84598 5.36269 4.84361 5.83756 5.13505 6.13191C5.42648 6.42626 5.90134 6.42862 6.19569 6.13719L5.14033 5.07126ZM18.8623 5.13786C15.0421 1.31766 8.86882 1.27898 5.0739 5.0739L6.13456 6.13456C9.33366 2.93545 14.5572 2.95404 17.8017 6.19852L18.8623 5.13786ZM5.0739 5.0739L3.80752 6.34028L4.86818 7.40094L6.13456 6.13456L5.0739 5.0739ZM4.33408 7.6206L6.87963 7.63339L6.88717 6.13341L4.34162 6.12062L4.33408 7.6206ZM5.08784 6.86684L5.07505 4.32129L3.57507 4.32882L3.58786 6.87438L5.08784 6.86684ZM12 3.75C16.5563 3.75 20.25 7.44365 20.25 12H21.75C21.75 6.61522 17.3848 2.25 12 2.25V3.75ZM12 20.25C7.44365 20.25 3.75 16.5563 3.75 12H2.25C2.25 17.3848 6.61522 21.75 12 21.75V20.25ZM16.1245 19.1468C14.9118 19.8483 13.5039 20.25 12 20.25V21.75C13.7747 21.75 15.4407 21.2752 16.8755 20.4452L16.1245 19.1468ZM20.25 12C20.25 13.5039 19.8483 14.9118 19.1468 16.1245L20.4452 16.8755C21.2752 15.4407 21.75 13.7747 21.75 12H20.25ZM6.19569 6.13719C7.68707 4.66059 9.73646 3.75 12 3.75V2.25C9.32542 2.25 6.90113 3.32791 5.14033 5.07126L6.19569 6.13719Z" fill="#ffffff"></path> </g></svg>
        `,
        () => showUpdatePopup("histovec.html")
    );

    const togglesun = createStyledButtonBeta(
        t("spottingmode"), 
        '', 
        `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle cx="12" cy="13" r="3" stroke="#ffffff" stroke-width="1.5"></circle> <path d="M3.0001 12.9999C3.0001 10.191 2.99995 8.78673 3.67407 7.77783C3.96591 7.34107 4.34091 6.96607 4.77767 6.67423C5.78656 6.00011 7.19103 6.00011 9.99995 6.00011H14C16.8089 6.00011 18.2133 6.00011 19.2222 6.67423C19.659 6.96607 20.034 7.34107 20.3258 7.77783C21 8.78673 21.0001 10.191 21.0001 12.9999C21.0001 15.8088 21.0001 17.2133 20.326 18.2222C20.0341 18.6589 19.6591 19.0339 19.2224 19.3258C18.2135 19.9999 16.809 19.9999 14.0001 19.9999H10.0001C7.19117 19.9999 5.78671 19.9999 4.77782 19.3258C4.34106 19.0339 3.96605 18.6589 3.67422 18.2222C3.44239 17.8752 3.29028 17.4815 3.19049 16.9999" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M18 10H17.5" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> <path d="M14.5 3.5H9.5" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>
        `,
        toggleSunOrientation
    );


    
    
    const about = createStyledButton(
        t("about"), 
        'MBF 3Xperience build 100425', 
        `
        <svg width="24" height="24" viewBox="0 0 52 52" fill="#ffffff" stroke="currentColor" stroke-width="2" data-name="Layer 1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" stroke="#ffffff"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path d="M26,52A26,26,0,0,1,22.88.19,25.78,25.78,0,0,1,34.73,1.5a2,2,0,1,1-1.35,3.77,22,22,0,0,0-21,38,22,22,0,0,0,35.41-20,2,2,0,1,1,4-.48A26,26,0,0,1,26,52Z"></path><path d="M26,43.86a2,2,0,0,1-2-2V22.66a2,2,0,1,1,4,0v19.2A2,2,0,0,1,26,43.86Z"></path><circle cx="26" cy="15.71" r="2.57"></circle></g></svg>
        `,
        () => showUpdatePopupmusic("https://www.mybusfinder.fr/updatecm/updatecm.html")
    );


    bottomSheet.appendChild(dragHandle);
    const greetingText = document.createElement('div');
    greetingText.style.cssText = `
        text-align: center;
        font-size: 27px;
        color: white;
        margin: 22px 20px 0 15px;
        text-align: right;
        justify-content: right;
    `;
    const createStyledBox = (text, elements) => {
        const box = document.createElement('div');
        
        const title = document.createElement('div');
        title.textContent = text;
        title.style.cssText = `
            font-size: 20px;
            color: white;
            margin-top: 17px;
            margin-right: 15px;
            text-align: right;
            justify-content: right;
        `;
        
        box.appendChild(title);
        elements.forEach(el => box.appendChild(el));
        
        box.style.cssText = `
            margin: 10px;
            border-radius: 15px;
        `;
        return box;
    };

    greetingText.textContent = getTransportGreeting();
    bottomSheet.appendChild(greetingText);

    const sedeplacerBox = createStyledBox(t("tomove"), [transportStateContainer, locationButton, satelliteButton]);
    bottomSheet.appendChild(sedeplacerBox);

    const allerplusloinBox = createStyledBox(t("gofurther"), [histovecButton, togglesun, about]);
    bottomSheet.appendChild(allerplusloinBox);

    let startY, initialY, isDragging = false;
    
    function startDrag(e) {
    if (e.type.includes('touch')) {
        e.preventDefault();
    }
    isDragging = true;
    startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
    initialY = startY;
    
    const transform = window.getComputedStyle(bottomSheet).transform;
    const matrix = new DOMMatrix(transform);
    currentTranslateY = matrix.m42;
    
    bottomSheet.style.transition = 'none';
}

function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const currentY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
    const deltaY = currentY - startY;
    const newTranslateY = Math.max(0, currentTranslateY + deltaY);
    
    const maxTranslate = bottomSheet.offsetHeight;
    const boundedTranslateY = Math.min(maxTranslate, newTranslateY);
    
    bottomSheet.style.transform = `translateY(${boundedTranslateY}px)`;
}

function stopDrag(e) {
    if (!isDragging) return;
    isDragging = false;
    
    const finalY = e.type.includes('mouse') ? e.clientY : e.changedTouches[0].clientY;
    const deltaY = finalY - initialY;
    const currentTranslate = getTranslateY(bottomSheet);
    const sheetHeight = bottomSheet.offsetHeight;
    
    bottomSheet.style.transition = 'transform 0.3s ease-out';
    
    const percentageMoved = (currentTranslate / sheetHeight) * 100;
    
    if (deltaY > 0) { 
        if (percentageMoved > 50) {
            closeBottomSheet();
        } else if (percentageMoved > 30) {
            bottomSheet.style.transform = `translateY(${sheetHeight * (SNAP_POINTS.PEEK/100)}px)`;
        } else {
            bottomSheet.style.transform = 'translateY(0)';
        }
    } else { 
        if (percentageMoved < 30) {
            bottomSheet.style.transform = 'translateY(0)';
        } else if (percentageMoved < 70) {
            bottomSheet.style.transform = `translateY(${sheetHeight * (SNAP_POINTS.PEEK/100)}px)`;
        } else {
            closeBottomSheet();
        }
    }
}


    // Event listeners
    bottomSheet.addEventListener('mousedown', startDrag);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);

    bottomSheet.addEventListener('touchstart', startDrag, { passive: false });
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', stopDrag);
    function getTranslateY(element) {
    const style = window.getComputedStyle(element);
    const matrix = new DOMMatrix(style.transform);
    return matrix.m42;
}

    document.body.appendChild(bottomSheet);
    return bottomSheet;
}

function createStyledButtonBeta(title, description, svgContent, onClickHandler) {
    const button = document.createElement('div');
    button.className = 'alerts-button';
    button.style.cssText = `
        display: flex;
        align-items: center;
        margin: 15px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(255, 255, 255, 0.1);
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        cursor: pointer;
    `;

    const icon = document.createElement('div');
    icon.className = 'alerts-icon';
    icon.innerHTML = svgContent;
    icon.style.color = 'white';
    icon.style.marginRight = '10px';

    const content = document.createElement('div');
    content.className = 'alerts-content';
    content.style.color = 'white';
    content.style.display = 'flex';
    content.style.alignItems = 'center';

    const titleWrapper = document.createElement('div');
    titleWrapper.style.display = 'flex';
    titleWrapper.style.alignItems = 'center';

    const titleElement = document.createElement('div');
    titleElement.className = 'alerts-title';
    titleElement.textContent = title;
    titleElement.style.fontSize = '18px';
    titleElement.style.marginRight = '10px';

    const betaTag = document.createElement('div');
    betaTag.textContent = 'beta';
    betaTag.style.cssText = `
        background-color: green;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        text-transform: uppercase;
        font-weight: bold;
    `;

    titleWrapper.appendChild(titleElement);
    titleWrapper.appendChild(betaTag);

    const descriptionElement = document.createElement('div');
    descriptionElement.className = 'alerts-description';
    descriptionElement.textContent = description;
    descriptionElement.style.fontSize = '14px';
    descriptionElement.style.opacity = '0.7';

    content.appendChild(titleWrapper);
    content.appendChild(descriptionElement);

    button.appendChild(icon);
    button.appendChild(content);

    const handleAction = () => {
        onClickHandler();
        setTimeout(() => {
            closeBottomSheet();
        }, 50);
    };

    let touchStartY = 0;
    let touchMoved = false;
    const touchThreshold = 5;

    const handleButtonAction = () => {
        onClickHandler();
        setTimeout(() => {
            closeBottomSheet();
        }, 50);
    };

    if ('ontouchstart' in window) {
        button.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
            touchMoved = false;
            button.style.transform = 'scale(0.98,0.98)';
            button.style.boxShadow = '0 6px 12px rgba(255, 255, 255, 0.15)';
        }, { passive: true });

        button.addEventListener('touchmove', (e) => {
            const touchCurrentY = e.touches[0].clientY;
            if (Math.abs(touchCurrentY - touchStartY) > touchThreshold) {
                touchMoved = true;
                button.style.transform = 'scale(1,1)';
                button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
            }
        }, { passive: true });

        button.addEventListener('touchend', (e) => {
            e.preventDefault();
            button.style.transform = 'scale(1,1)';
            button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
            
            if (!touchMoved) {
                handleButtonAction();
                setTimeout(() => {
                    closeBottomSheet();
                }, 50);
            }
        });

        button.addEventListener('touchcancel', () => {
            button.style.transform = 'scale(1,1)';
            button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
        });
    } else {
        button.addEventListener('click', () => {
            handleButtonAction();
            setTimeout(() => {
                closeBottomSheet();
            }, 50);
        });
    }

    button.onmouseover = () => {
        button.style.transform = 'scale(0.98,0.98)';
        button.style.boxShadow = '0 6px 12px rgba(255, 255, 255, 0.15)';
    };

    button.onmouseout = () => {
        button.style.transform = 'scale(1,1)';
        button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
    };

    return button;
}

function createStyledButton(title, description, svgContent, onClickHandler) {
    const button = document.createElement('div');
    button.className = 'alerts-button';
    button.style.cssText = `
        display: flex;
        align-items: center;
        margin: 15px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(255, 255, 255, 0.1);
        transition: transform 0.3s cubic-bezier(0.25, 1.5, 0.5, 1), box-shadow 0.3s cubic-bezier(0.25, 1.5, 0.5, 1);
        cursor: pointer;
    `;

    const icon = document.createElement('div');
    icon.className = 'alerts-icon';
    icon.innerHTML = svgContent;
    icon.style.color = 'white';
    icon.style.marginRight = '10px';

    const content = document.createElement('div');
    content.className = 'alerts-content';
    content.style.color = 'white';

    const titleElement = document.createElement('div');
    titleElement.className = 'alerts-title';
    titleElement.textContent = title;
    titleElement.style.fontSize = '18px';

    const descriptionElement = document.createElement('div');
    descriptionElement.className = 'alerts-description';
    descriptionElement.textContent = description;
    descriptionElement.style.fontSize = '14px';
    descriptionElement.style.opacity = '0.7';

    content.appendChild(titleElement);
    content.appendChild(descriptionElement);

    button.appendChild(icon);
    button.appendChild(content);

    const handleAction = () => {
        onClickHandler();
        setTimeout(() => {
            closeBottomSheet();
        }, 50);

    };

    let touchStartY = 0;
    let touchMoved = false;
    const touchThreshold = 5;

    const handleButtonAction = () => {
        onClickHandler();
        setTimeout(() => {
            closeBottomSheet();
        }, 50);
    };

    if ('ontouchstart' in window) {
        button.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
            touchMoved = false;
            button.style.transform = 'scale(0.98,0.98)';
            button.style.boxShadow = '0 6px 12px rgba(255, 255, 255, 0.15)';
        }, { passive: true });

        button.addEventListener('touchmove', (e) => {
            const touchCurrentY = e.touches[0].clientY;
            if (Math.abs(touchCurrentY - touchStartY) > touchThreshold) {
                touchMoved = true;
                button.style.transform = 'scale(1,1)';
                button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
            }
        }, { passive: true });

        button.addEventListener('touchend', (e) => {
            e.preventDefault();
            button.style.transform = 'scale(1,1)';
            button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
            
            if (!touchMoved) {
                handleButtonAction();
                setTimeout(() => {
                    closeBottomSheet();
                }, 50);
            }
        });

        button.addEventListener('touchcancel', () => {
            button.style.transform = 'scale(1,1)';
            button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
        });
    } else {
        button.addEventListener('click', () => {
            handleButtonAction();
            setTimeout(() => {
                closeBottomSheet();
            }, 50);
        });
    }

    button.onmouseover = () => {
        button.style.transform = 'scale(0.98,0.98)';
        button.style.boxShadow = '0 6px 12px rgba(255, 255, 255, 0.15)';
    };

    button.onmouseout = () => {
        button.style.transform = 'scale(1,1)';
        button.style.boxShadow = '0 4px 6px rgba(255, 255, 255, 0.1)';
    };

    return button;
}

window.isMenuShowed = false;

function showBottomSheet() {
    showLanguageSwitcher();
    const bottomSheet = document.getElementById('bottomSheet') || createBottomSheet();
    const menu = document.getElementById('menu');
    safeVibrate(50);
    // Hide menu
    menu.classList.add('hidden');
    window.isMenuShowed = false;
    menu.addEventListener('animationend', function onAnimationEnd(event) {
        if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
            menu.style.display = 'none';
        }
    });
    isMenuVisible = false;

    const menubotom = document.getElementById('menubottom');

    menubottom1.classList.remove('slide-downb');
    menubottom1.classList.add('slide-upb');
    if (selectedLine) {
        const filtre = document.getElementById('filtre');
        filtre.classList.add('slide-upc');
        filtre.classList.remove('slide-downc');
        filtre.addEventListener('animationend', () => {
            filtre.style.display = 'none';
        });
    }

    menubottom1.addEventListener('transitionend', () => {
    if (menubottom1.classList.contains('slide-up')) {
    menubottom1.style.display = 'none';
    }
    }, { once: true });

    // Show bottom sheet with animation
    bottomSheet.style.opacity = '1';
    bottomSheet.style.transform = 'translateY(100%)';

    bottomSheet.style.display = 'block';
    
    // Trigger reflow
    bottomSheet.offsetHeight;
    
    // Animate in
    bottomSheet.style.transition = 'transform 0.4s cubic-bezier(0,.74,.28,.99), opacity 0.3s ease-out';
    bottomSheet.style.transform = 'translateY(0)';
    
    // Set state to open
    window.isBottomSheetOpen = true;

}

function closeBottomSheet() {
    hideLanguageSwitcher();
    const bottomSheet = document.getElementById('bottomSheet');

    safeVibrate(50);

    if (bottomSheet) {
        bottomSheet.style.transition = 'transform 0.4s cubic-bezier(0.32, 0.64, 0.45, 1), opacity 0.3s ease-out';
        
        bottomSheet.style.transform = 'translateY(100%)';
        bottomSheet.style.opacity = '0';
        
        bottomSheet.addEventListener('transitionend', function onTransitionEnd(e) {
            if (e.propertyName === 'transform') {
                bottomSheet.style.display = 'none';
                bottomSheet.removeEventListener('transitionend', onTransitionEnd);
            }
        });
        menubottom1.style.display = 'flex';
        setTimeout(() => {
            menubottom1.classList.remove('slide-upb');
            menubottom1.classList.add('slide-downb');
            if (selectedLine) {
            const filtre = document.getElementById('filtre');
            filtre.classList.remove('slide-upc');
            filtre.classList.add('slide-downc');
            filtre.style.display = 'flex';
            
            }
        }, 10);


        setTimeout(() => {
            if (bottomSheet.style.display !== 'none') {
                bottomSheet.style.display = 'none';
            }
            setTimeout(() => {
                window.isBottomSheetOpen = false;
            }, 200);
        }, 500);
    }
}

document.getElementById('bottomsheetappear').addEventListener('click', function() {
showBottomSheet();
});

function getNextStopInfo(vehicleId) {
    const vehicle = markers[vehicleId];
    if (!vehicle) return null;
    
    const currentStopId = vehicle.stopId ? vehicle.stopId.replace("0:", "") : null;
    
    for (const [tripId, tripData] of Object.entries(tripUpdates)) {
        if (!tripData.nextStops || !tripData.nextStops.length) continue;
        
        const currentStopIndex = tripData.nextStops.findIndex(stop => 
            stop.stopId.replace("0:", "") === currentStopId
        );
        
        if (currentStopIndex !== -1 && tripData.nextStops[currentStopIndex + 1]) {
            const nextStop = tripData.nextStops[currentStopIndex + 1];
            return {
                name: stopNameMap[nextStop.stopId] || nextStop.stopId,
                delay: nextStop.delay,
                departureTime: nextStop.departureTime
            };
        }
    }
    return null;
}


    const busesByLineAndDestination = {};

    Object.keys(markers).forEach(id => {
    const vehicle = markers[id];
    const line = vehicle.line;
    
    let destination = "Inconnue";
    const popupContent = vehicle.getPopup().getContent();
    
    const patterns = [
        /<strong[^>]*>➜\s*(.*?)<\/strong>/,
        />➜\s*(.*?)</,
        /Ligne \d+<\/p>\s*<strong[^>]*>➜\s*(.*?)<\/strong>/
    ];

    for (const pattern of patterns) {
        const match = popupContent.match(pattern);
        if (match && match[1]) {
            destination = match[1].trim();
            if (destination.toLowerCase() !== 'Destination inconnue') {
                break;
            }
        }
    }

    if (!busesByLineAndDestination[line]) {
        busesByLineAndDestination[line] = {};
    }

    if (!busesByLineAndDestination[line][destination]) {
        busesByLineAndDestination[line][destination] = [];
    }

    busesByLineAndDestination[line][destination].push({
        parkNumber: vehicle.id,
        vehicle
    });
});

    const sortedLines = Object.keys(busesByLineAndDestination)
        .sort((a, b) => {
            const aIsFavorite = favoriteLines.has(a);
            const bIsFavorite = favoriteLines.has(b);
            
            if (aIsFavorite && !bIsFavorite) return -1;
            if (!aIsFavorite && bIsFavorite) return 1;
            
            return isNaN(a) ? (isNaN(b) ? a.localeCompare(b) : 1) : (isNaN(b) ? -1 : parseInt(a) - parseInt(b));
        });


function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return { r, g, b };
}


function calculateLuminance(r, g, b) {
    return (r * 0.299 + g * 0.587 + b * 0.114);
}


function getTextColor(backgroundColor) {
    try {
        let hexColor = backgroundColor;
        
        if (!hexColor.startsWith('#')) {
            hexColor = '#' + hexColor;
        }
        
        const { r, g, b } = hexToRgb(hexColor);
        
        const luminance = calculateLuminance(r, g, b);
        
        const threshold = 150;
                
        return luminance > threshold ? '#000000' : '#ffffff';
    } catch (e) {
        return '#ffffff';
    }
}


    sortedLines.forEach(line => {
        const lineNameText = lineName[line] || t("unknown_line");
        const lineColor = lineColors[line] || '#000000';
        const textColor = getTextColor(lineColor);


        const lineSection = document.createElement('div');
        lineSection.dataset.line = line;
        lineSection.style.backgroundColor = lineColor;
        lineSection.classList.add('linesection');
        lineSection.style.marginBottom = '10px';
        lineSection.style.padding = '10px';
        lineSection.style.borderRadius = '8px';
        lineSection.style.position = 'relative';

        lineSection.onmouseover = () => {
        lineSection.style.transform = 'scale(0.98,0.98)';
        lineSection.style.opacity = '0.9';
        lineSection.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
        };  
        lineSection.onmouseout = () => {
            lineSection.style.transform = 'scale(1,1)';
            lineSection.style.opacity = '0.9';
            lineSection.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
        };

        const favoriteButton = document.createElement('button');
        favoriteButton.style.position = 'absolute';
        favoriteButton.style.right = '5px';
        favoriteButton.style.top = '5px';
        favoriteButton.style.background = 'none';
        favoriteButton.style.border = 'none';
        favoriteButton.style.color = textColor;
        favoriteButton.style.fontSize = '20px';
        favoriteButton.style.cursor = 'pointer';
        favoriteButton.innerHTML = favoriteLines.has(line) ? '★' : '☆';
        favoriteButton.onclick = async (e) => {
            e.stopPropagation();
            const lineSection = e.target.closest('.linesection');
            const isFavorite = favoriteLines.has(line);
            await animateFavoriteTransition(e.target, lineSection, line, isFavorite);
        };

        const lineTitle = document.createElement('div');
        lineTitle.textContent = `${t("line")} ${lineNameText}`;
        lineTitle.style.fontSize = '23px';
        lineTitle.style.fontWeight = 'normal';
        lineTitle.style.color = textColor;
        lineTitle.style.paddingRight = '30px';
        lineTitle.style.paddingLeft = '10px';


        lineSection.appendChild(lineTitle);
        lineSection.appendChild(favoriteButton);

        Object.keys(busesByLineAndDestination[line])
    .sort()
    .forEach(destination => {
        const destinationSection = document.createElement('div');
        destinationSection.style.marginTop = '5px';
        destinationSection.style.paddingLeft = '10px';

        const destinationTitle = document.createElement('div');
        destinationTitle.textContent = `➜ ${destination}`;
        destinationTitle.style.fontSize = '16px';
        destinationTitle.style.fontWeight = 'normal';
        destinationTitle.style.color = textColor;
        destinationSection.appendChild(destinationTitle);

        busesByLineAndDestination[line][destination].forEach(bus => {
            const busItem = document.createElement('div');
            const marker = bus.vehicle;
            const popupContent = marker.getPopup().getContent();
            
            let nextStopInfo = '';
            let terminusInfo = '';
            
            const stopNameContainers = popupContent.match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/g);
            const timeDisplays = popupContent.match(/<div class="time-display"[^>]*data-time-left="([^"]*)"[^>]*data-departure-time="([^"]*)"[^>]*>([\s\S]*?)<\/div>/g);
            
            if (stopNameContainers && stopNameContainers.length > 0 && timeDisplays && timeDisplays.length > 0) {
                const firstStopNameMatch = stopNameContainers[0].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                const firstTimeMatch = timeDisplays[0].match(/data-time-left="([^"]*)"/);
                
                if (firstStopNameMatch && firstStopNameMatch[1] && firstTimeMatch && firstTimeMatch[1]) {
                    const stopName = firstStopNameMatch[1].trim();
                    const timeInfo = firstTimeMatch[1].trim();
                    if (stopName && timeInfo) {
                        nextStopInfo = `| ${stopName}`;
                    }
                }
                
                if (stopNameContainers.length > 1 && timeDisplays.length > 1) {
                    const lastIndex = stopNameContainers.length - 1;
                    const lastStopNameMatch = stopNameContainers[lastIndex].match(/<div class="stop-name"[^>]*>([\s\S]*?)<\/div>/);
                    const lastTimeMatch = timeDisplays[lastIndex].match(/data-time-left="([^"]*)"/);
                    
                    if (lastStopNameMatch && lastStopNameMatch[1] && lastTimeMatch && lastTimeMatch[1]) {
                        const terminusName = lastStopNameMatch[1].trim();
                        const terminusTime = lastTimeMatch[1].trim();
                        if (terminusName && terminusTime) {
                            terminusInfo = `${t("arrivalat")} ${destination} ${terminusTime !== t("imminent") ? t("in") + ' ' + terminusTime : t("imminent")}.`;
                        }
                    }
                }
            }
            
            if (!nextStopInfo || !terminusInfo) {
                const stopsHeaderMatch = popupContent.match(/<p style="margin: 0; font-size: 18px; text-align: right;">(.*?)<\/p>/);
                if (stopsHeaderMatch && stopsHeaderMatch[1]) {
                    const headerText = stopsHeaderMatch[1].trim();
                    if (headerText.includes('imminent')) {
                        nextStopInfo = '| ' + t("imminentdeparture") + '.';
                    } else if (headerText.includes('min')) {
                        const minMatch = headerText.match(/dans (\d+) min/);
                        if (minMatch && minMatch[1]) {
                            nextStopInfo = `| ${t("departurein")} ${minMatch[1]} ${t("min")}.`;
                        }
                    }
                }
                
                if (!terminusInfo) {
                    terminusInfo = `${t("indirectionof")} ${destination}.`;
                }
            }
                const mainText = document.createElement('div');
                    const labelMatch = popupContent.match(/<span style="display: inline-block[^>]*>([^<]+)<\/span>/);
                    const vehicleLabel = labelMatch ? labelMatch[1].trim() : "Véhicule inconnu";

                    const displayLabel = vehicleLabel.replace(/Véhicule inconnu\./, "inconnu");

                    mainText.textContent = `${t("bus")} ${displayLabel} ${nextStopInfo}`;
                    mainText.style.fontSize = '1.2em';  
                    mainText.style.fontWeight = '500';  
                    mainText.style.color = textColor;
                    
                    const arrivalText = document.createElement('div');
                    arrivalText.textContent = terminusInfo;
                    arrivalText.style.fontSize = '0.9em'; 
                    arrivalText.style.opacity = '0.8';  
                    arrivalText.style.textAlign = 'right';
                    arrivalText.style.color = textColor;

                    busItem.textContent = '';
                    busItem.appendChild(mainText);
                    busItem.appendChild(arrivalText);
                    
                    busItem.style.cursor = 'pointer';
                    busItem.classList.add('menu-item');
                    busItem.style.fontFamily = 'League Spartan';
                    busItem.style.color = textColor;
                    busItem.style.padding = '5px 10px';
                    busItem.style.marginBottom = '5px';
                    busItem.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                    busItem.style.border = '1px solid rgba(0, 0, 0, 0.2)'; 
                    busItem.style.borderRadius = '8px';
                    busItem.style.overflow = 'hidden';
                    busItem.style.maxWidth = '300px';
                    lineSection.onclick = () => {
                        safeVibrate([50, 30, 50], true);
                        const lineId = line;
                        selectedLine = lineId;
                        filterByLine(lineId);
                        menu.classList.add('hidden');
                        window.isMenuShowed = false;
                        menu.addEventListener('animationend', function onAnimationEnd(event) {
                            if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                                menu.style.display = 'none';
                            }
                        });
                        isMenuVisible = false;
                        const filtre = document.getElementById('filtre');
                        menubottom1.style.display = 'flex';
                        setTimeout(() => {
                            menubottom1.classList.remove('slide-upb');
                            menubottom1.classList.add('slide-downb');
                            if (selectedLine) {
                                filtre.classList.remove('slide-upc');
                                filtre.classList.add('slide-downc');
                                filtre.style.display = 'flex';
                            }
                        }, 10);
                    };

                    busItem.onclick = (event) => {
                        safeVibrate([50, 300, 50, 30, 50], true);
                        map.setView(bus.vehicle.getLatLng(), 15);
                        bus.vehicle.openPopup();
                        menu.classList.add('hidden');
                        window.isMenuShowed = false;
                        menu.addEventListener('animationend', function onAnimationEnd(event) {
                            if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                                menu.style.display = 'none';
                            }
                        });
                        isMenuVisible = false;
                        if (selectedLine) {
                            resetMapView();
                        }
                        event.stopPropagation();
                    };

                    destinationSection.appendChild(busItem);
                });

                lineSection.appendChild(destinationSection);
            });

        menu.appendChild(lineSection);
    });
}

const menubottom1 = document.getElementById('menubtm');


        function showMenu() {
            window.isMenuShowed = true;
            const menu = document.getElementById('menu');
            const menubotom = document.getElementById('menubottom');
            menu.classList.remove('hidden');
            menu.style.display = 'block'; 
            isMenuVisible = true; 
            menubottom1.classList.remove('slide-downb');
            menubottom1.classList.add('slide-upb');
            if (selectedLine) {
                const filtre = document.getElementById('filtre');
                filtre.classList.add('slide-upc');
                filtre.classList.remove('slide-downc');
                filtre.addEventListener('animationend', () => {
                    filtre.style.display = 'none';
                });
        }

            menubottom1.addEventListener('transitionend', () => {
            if (menubottom1.classList.contains('slide-up')) {
            menubottom1.style.display = 'none';
            }
            }, { once: true });

        }

        const menubutton = document.getElementById('menubutton');
        menubutton.onclick = showMenu; 


        const closeMap = document.getElementById('map');
        closeMap.onclick = () => {
            const menu = document.getElementById('menu');
            menu.classList.add('hidden');
            window.isMenuShowed = false;
            menu.addEventListener('animationend', function onAnimationEnd(event) {
                if (event.animationName === 'slideInBounceInv' && menu.classList.contains('hidden')) { 
                    menu.style.display = 'none';
                }
            });
            isMenuVisible = false; 
            if (!isBottomSheetOpen) {
                menubottom1.style.display = 'flex';
                setTimeout(() => {
                    menubottom1.classList.remove('slide-upb');
                    menubottom1.classList.add('slide-downb');
                    if (selectedLine) {
                    const filtre = document.getElementById('filtre');
                    filtre.classList.remove('slide-upc');
                    filtre.classList.add('slide-downc');
                    filtre.style.display = 'flex';
                    }
                }, 10);
            }
        };

        updateMenu();

    } catch (error) {
        console.error('Err récup des données ! ', error);
        toastBottomRight.info('Aucun bus ne circule actuellement... 💤 à très vite !!');

    }
}




let lastTripUpdateTimestamp = 0;
let worker;
let fetchInProgress = false;
const FETCH_INTERVAL = 8000; 

function initWorker() {
    worker = new Worker('worker.js');
    
    worker.onerror = (error) => {
        console.error('Erreur worker', error);
        setTimeout(() => {
            worker.terminate();
            initWorker();
        }, 1000);
    };
}

async function fetchTripUpdates() {
    if (fetchInProgress) return Promise.resolve(null);
    
    fetchInProgress = true;
    const fetchStartTime = performance.now();
    
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // timeout après 5s
        
        const response = await fetch('proxy-cors/proxy_tripupdate.php', {
            signal: controller.signal,
            cache: 'no-store' 
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const buffer = await response.arrayBuffer();
        const data = await decodeProtobuf(buffer);
        
        const fetchTime = performance.now() - fetchStartTime;
        console.debug(`Téléchargement gtfs en ${fetchTime.toFixed(2)}ms`);
        
        return new Promise((resolve, reject) => {
            const workerTimeoutId = setTimeout(() => {
                reject(new Error('Worker timeout'));
            }, 3000);
            
            worker.onmessage = (e) => {
                clearTimeout(workerTimeoutId);
                const processTime = performance.now() - fetchStartTime;
                
                tripUpdates = e.data.tripUpdates;
                
                
                resolve(e.data.tripUpdates);
                fetchInProgress = false;
            };
            
            worker.postMessage(data);
        });
    } catch (error) {
        console.error('Erreur récupération trip updates:', error);
        fetchInProgress = false;
        throw error;
    }
}

let lastUpdateTime = 0;
function scheduleFetchUpdates(timestamp) {
    if (!lastUpdateTime || timestamp - lastUpdateTime >= FETCH_INTERVAL) {
        lastUpdateTime = timestamp;
        
        Promise.all([
            fetchTripUpdates().catch(() => null),
            fetchVehiclePositions().catch(() => null)
        ]).catch(error => {
            console.warn('Erreur lors des mises à jour', error);
        });
    }
    
    requestAnimationFrame(scheduleFetchUpdates);
}


async function main() {
    try {
        initWorker();
        
        const gtfsData = await initializeGTFS();
        gtfsInitialized = true;
        
        await loadGeoJsonLines();
        
        await Promise.all([
            fetchTripUpdates().catch(console.error),
            fetchVehiclePositions(),
            hideLoadingScreen()
        ]);
        
        requestAnimationFrame(scheduleFetchUpdates);
        
    } catch (error) {
        console.error("Erreur critique dans main():", error);
        toastBottomRight.error("Une erreur critique est survenue. Nous investigons actuellement sur la cause de la panne.");
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', main);
} else {
    main();
}    
</script>
</html>
